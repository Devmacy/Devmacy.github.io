[{"id":"c5bc8627b03c6a3119499ed2f4664121","title":"Zoom to Fit Selected Elements","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\nSimilar to Excalidraw standard SHIFT+2 feature: Zoom to fit selected elements, but with the ability to zoom to 1000%. Inspiration: #272\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nelements = ea.getViewSelectedElements();\napi = ea.getExcalidrawAPI();\napi.zoomToFit(elements,10);\n\n","slug":"Zoom to Fit Selected Elements","date":"2023-07-29T10:00:19.324Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"bd0d208203deb7eab85851c1be6fe6ef","title":"Uniform size","content":"&#x2F;*\n\nThe script will standardize the sizes of rectangles, diamonds and ellipses adjusting all the elements to match the largest width and height within the group.\n*/\nconst boxShapesDispaly=[&quot;○ ellipse&quot;,&quot;□ rectangle&quot;,&quot;◇ diamond&quot;];\nconst boxShapes=[&quot;ellipse&quot;,&quot;rectangle&quot;,&quot;diamond&quot;];\n\nlet editedElements = [];\n\nconst elements = ea.getViewSelectedElements().filter(el=&gt;boxShapes.contains(el.type));\nif(elements.length===0) &#123;\n  new Notice(&quot;No rectangle, or diamond or ellipse elements are selected. Please select some elements&quot;);\n  return;\n&#125;\n\nconst typeSet = new Set();\nelements.forEach(el=&gt;typeSet.add(el.type));\n\nconst elementType = await utils.suggester(\n  Array.from(typeSet).map((item) =&gt; &#123; \n    switch(item) &#123;\n      case &quot;ellipse&quot;: return &quot;○ ellipse&quot;;\n      case &quot;rectangle&quot;: return &quot;□ rectangle&quot;;\n      case &quot;diamond&quot;: return &quot;◇ diamond&quot;;\n      default: return item;\n    &#125;\n  &#125;),\n  Array.from(typeSet),\n  &quot;Select element types to resize&quot;\n);\n\nif(!elementType) return;\n\nea.copyViewElementsToEAforEditing(elements.filter(el=&gt;el.type===elementType));\nlet width = height = 0;\nea.getElements().forEach(el=&gt;&#123;\n  if(el.width&gt;width) width = el.width;\n  if(el.height&gt;height) height = el.height;\n&#125;)\n\nea.getElements().forEach(el=&gt;&#123;\n  el.width = width;\n  el.height = height;\n&#125;)\n\nconst ids = ea.getElements().map(el=&gt;el.id);\nawait ea.addElementsToView(false,true);\nea.getExcalidrawAPI().updateContainerSize(ea.getViewElements().filter(el=&gt;ids.contains(el.id)));\n\n","slug":"Uniform size","date":"2023-07-29T10:00:19.322Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"57f6881fb5562e51f74a8f79e9f7cd82","title":"Text to Sticky Notes","content":"&#x2F;*\nConverts selected plain text element to sticky notes by dividing the text element line by line into separate sticky notes. The color of the stikcy note as well as the arrangement of the grid can be configured in plugin settings.\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nlet settings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Border color&quot;]) &#123;\n    settings = &#123;\n      &quot;Border color&quot; : &#123;\n            value: &quot;black&quot;,\n      description: &quot;Any legal HTML color (#000000, rgb, color-name, etc.). Set to &#39;transparent&#39; for transparent color.&quot;\n        &#125;,\n        &quot;Background color&quot; : &#123;\n            value: &quot;gold&quot;,\n      description: &quot;Background color of the sticky note. Set to &#39;transparent&#39; for transparent color.&quot;\n        &#125;,\n        &quot;Background fill style&quot; : &#123;\n            value: &quot;solid&quot;,\n      description: &quot;Fill style of the sticky note&quot;,\n          valueset: [&quot;hachure&quot;,&quot;cross-hatch&quot;,&quot;solid&quot;]\n        &#125;\n    &#125;;\n    await ea.setScriptSettings(settings);\n&#125;\n\nif(!settings[&quot;Max sticky note width&quot;]) &#123;\n  settings[&quot;Max sticky note width&quot;] = &#123;\n    value: &quot;600&quot;,\n    description: &quot;Maximum width of new sticky note. If text is longer, it will be wrapped&quot;,\n      valueset: [&quot;400&quot;,&quot;600&quot;,&quot;800&quot;,&quot;1000&quot;,&quot;1200&quot;,&quot;1400&quot;,&quot;2000&quot;]\n  &#125;\n  await ea.setScriptSettings(settings);\n&#125;\n\nif(!settings[&quot;Sticky note width&quot;]) &#123;\n  settings[&quot;Sticky note width&quot;] = &#123;\n    value: &quot;100&quot;,\n    description: &quot;Preferred width of the sticky note. Set to 0 if unset.&quot;,\n  &#125;\n  settings[&quot;Sticky note height&quot;] = &#123;\n    value: &quot;120&quot;,\n    description: &quot;Preferred height of the sticky note. Set to 0 if unset.&quot;,\n  &#125;\n  settings[&quot;Rows per column&quot;] = &#123;\n    value: &quot;3&quot;,\n    description: &quot;If multiple text elements are converted to sticky notes in one step, how many rows before a next column is created. Only effective if fixed width &amp; height are given. 0 for unset.&quot;,\n  &#125;\n  settings[&quot;Gap&quot;] = &#123;\n    value: &quot;10&quot;,\n    description: &quot;Gap between rows and columns&quot;,\n  &#125;\n  await ea.setScriptSettings(settings);\n&#125;\n\nconst pref_width = parseInt(settings[&quot;Sticky note width&quot;].value);\nconst pref_height = parseInt(settings[&quot;Sticky note height&quot;].value);\nconst pref_rows = parseInt(settings[&quot;Rows per column&quot;].value);\nconst pref_gap = parseInt(settings[&quot;Gap&quot;].value);\n\nconst maxWidth = parseInt(settings[&quot;Max sticky note width&quot;].value);\nconst strokeColor = settings[&quot;Border color&quot;].value;\nconst backgroundColor = settings[&quot;Background color&quot;].value;\nconst fillStyle = settings[&quot;Background fill style&quot;].value;\n\nelements = ea.getViewSelectedElements().filter((el)=&gt;el.type===&quot;text&quot;);\nelements.forEach((el)=&gt;&#123;\n  ea.style.strokeColor = el.strokeColor;\n  ea.style.fontFamily  = el.fontFamily;\n  ea.style.fontSize    = el.fontSize;\n  const text = el.text.split(&quot;\\n&quot;);\n  for(i=0;i&lt;text.length;i++) &#123;\n      ea.addText(el.x,el.y+i*el.height/text.length,text[i].trim());\n  &#125;\n&#125;);\nea.deleteViewElements(elements);\n\nea.style.strokeColor = strokeColor;\nea.style.backgroundColor = backgroundColor;\nea.style.fillStyle = fillStyle;\nconst padding = 6;\nconst boxes = [];\n\nconst doMatrix = pref_width &gt; 0 &amp;&amp; pref_height &gt; 0 &amp;&amp; pref_rows &gt; 0 &amp;&amp; pref_gap &gt; 0;\nlet row = 0;\nlet col = doMatrix ? -1 : 0;\n\nea.getElements().forEach((el, idx)=&gt;&#123;\n  if(doMatrix) &#123;\n        if(idx % pref_rows === 0) &#123;\n            row=0;\n            col++;\n        &#125; else &#123;\n            row++;\n        &#125;\n    &#125;\n  const width = pref_width &gt; 0 ? pref_width : el.width+2*padding;\n  const widthOK = pref_width &gt; 0 || width&lt;=maxWidth;\n  const id = ea.addRect(\n    (doMatrix?col*pref_width+col*pref_gap:0)+el.x-padding,\n    (doMatrix?row*pref_height+row*pref_gap:0),\n    widthOK?width:maxWidth,pref_height &gt; 0 ? pref_height : el.height+2*padding\n  );\n  boxes.push(id);\n  ea.getElement(id).boundElements=[&#123;type:&quot;text&quot;,id:el.id&#125;];\n  el.containerId = id;\n&#125;);\n\nconst els = Object.entries(ea.elementsDict);\nlet newEls = [];\nfor(i=0;i&lt;els.length/2;i++) &#123;\n    newEls.push(els[els.length/2+i]);\n    newEls.push(els[i])\n&#125;\nea.elementsDict = Object.fromEntries(newEls);\n\nawait ea.addElementsToView(false,true);\nconst containers = ea.getViewElements().filter(el=&gt;boxes.includes(el.id));\nea.getExcalidrawAPI().updateContainerSize(containers);\nea.selectElementsInView(containers);\n\n","slug":"Text to Sticky Notes","date":"2023-07-29T10:00:19.320Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"b8b3f7ebb395b48818bfda76a53e2384","title":"Text Arch","content":"&#x2F;*\nFit a text to the arch of a circle. The script will prompt you for the radius of the circle and then split your text to individual letters and place each letter to the arch defined by the radius. Setting a lower radius value will increase the arching of the text. Note that the arched-text will no longer be editable as a text element and it will no longer function as a markdown link. Emojis are currently not supported.\n*/\nel = ea.getViewSelectedElement();\nif(!el || el.type!==&quot;text&quot;) &#123;\n    new Notice(&quot;Please select a text element&quot;);\n  return;\n&#125;\n\nea.style.fontSize = el.fontSize;\nea.style.fontFamily = el.fontFamily;\nea.style.strokeColor = el.strokeColor;\nea.style.opacity = el.opacity;\n\nconst r = parseInt (await utils.inputPrompt(&quot;The radius of the arch you&#39;d like to fit the text to&quot;,&quot;number&quot;,&quot;150&quot;));\nconst archAbove = await utils.suggester([&quot;Arch above&quot;,&quot;Arch below&quot;],[true,false]);\n\nif(isNaN(r)) &#123;\n  new Notice(&quot;The radius is not a number&quot;);\n  return;\n&#125;\n\ncirclePoint = (angle) =&gt; archAbove\n  ? [\n        r * Math.sin(angle),\n        -r * Math.cos(angle)\n    ]\n    : [\n        -r * Math.sin(angle),\n        r * Math.cos(angle)\n    ];\n\nlet rot = (archAbove ? -0.5 : 0.5) * ea.measureText(el.text).width/r;\n\nlet objectIDs = [];\nfor(i=0;i&lt;el.text.length;i++) &#123;\n    const character = el.text.substring(i,i+1);\n    const width = ea.measureText(character).width;\n  ea.style.angle = rot;\n  const [x,y] = circlePoint(rot);\n  rot += (archAbove ? 1 : -1) *width / r;\n  objectIDs.push(ea.addText(x,y,character));\n&#125;\nea.addToGroup(objectIDs);\nea.addElementsToView(true);\n\n","slug":"Text Arch","date":"2023-07-29T10:00:19.317Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"c45800b27edeeb531f5f9c3216180b5e","title":"Split text by lines","content":"&#x2F;*\nrequires Excalidraw 1.5.1 or higher\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nSplit lines of text into separate text elements for easier reorganization\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nelements = ea.getViewSelectedElements().filter((el)=&gt;el.type===&quot;text&quot;);\nelements.forEach((el)=&gt;&#123;\n  ea.style.strokeColor = el.strokeColor;\n  ea.style.fontFamily  = el.fontFamily;\n  ea.style.fontSize    = el.fontSize;\n  const text = el.text.split(&quot;\\n&quot;);\n  for(i=0;i&lt;text.length;i++) &#123;\n    ea.addText(el.x,el.y+i*el.height/text.length,text[i]);\n  &#125;\n&#125;);\nea.addElementsToView(false,false);\nea.deleteViewElements(elements);\n\n","slug":"Split text by lines","date":"2023-07-29T10:00:19.315Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"ce8d4e25ac25aaa27d96a2f188be8be7","title":"Slideshow","content":"&#x2F;*\n\n\nThe script will convert your drawing into a slideshow presentation.If you select an arrow or line element, the script will use that as the presentation path.If you select nothing, but the file has a hidden presentation path, the script will use that for determining the slide sequence.If there are frames, the script will use the frames for the presentation. Frames are played in alphabetical order of their titles.\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.8.17&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nconst statusBarElement = document.querySelector(&quot;div.status-bar&quot;);\nconst ctrlKey = ea.targetView.modifierKeyDown.ctrlKey || ea.targetView.modifierKeyDown.metaKey;\nconst altKey = ea.targetView.modifierKeyDown.altKey || ctrlKey;\n\n//-------------------------------\n//constants\n//-------------------------------\nconst TRANSITION_STEP_COUNT = 100;\nconst TRANSITION_DELAY = 1000; //maximum time for transition between slides in milliseconds\nconst FRAME_SLEEP = 1; //milliseconds\nconst EDIT_ZOOMOUT = 0.7; //70% of original slide zoom, set to a value between 1 and 0\nconst FADE_LEVEL = 0.15; //opacity of the slideshow controls after fade delay (value between 0 and 1)\n//using outerHTML because the SVG object returned by Obsidin is in the main workspace window\n//but excalidraw might be open in a popout window which has a different document object\nconst SVG_COG = ea.obsidian.getIcon(&quot;lucide-settings&quot;).outerHTML;\nconst SVG_FINISH = ea.obsidian.getIcon(&quot;lucide-x&quot;).outerHTML;\nconst SVG_RIGHT_ARROW = ea.obsidian.getIcon(&quot;lucide-arrow-right&quot;).outerHTML;\nconst SVG_LEFT_ARROW = ea.obsidian.getIcon(&quot;lucide-arrow-left&quot;).outerHTML;\nconst SVG_EDIT = ea.obsidian.getIcon(&quot;lucide-pencil&quot;).outerHTML;\nconst SVG_MAXIMIZE = ea.obsidian.getIcon(&quot;lucide-maximize&quot;).outerHTML;\nconst SVG_MINIMIZE = ea.obsidian.getIcon(&quot;lucide-minimize&quot;).outerHTML;\n\n//-------------------------------\n//utility &amp; convenience functions\n//-------------------------------\nlet slide = 0;\nlet isFullscreen = false;\nconst ownerDocument = ea.targetView.ownerDocument;\nconst startFullscreen = !altKey;\n//The plugin and Obsidian App run in the window object\n//When Excalidraw is open in a popout window, the Excalidraw component will run in the ownerWindow\n//and in this case ownerWindow !== window\n//For this reason event handlers are distributed between window and owner window depending on their role\nconst ownerWindow = ea.targetView.ownerWindow;\nconst excalidrawAPI = ea.getExcalidrawAPI();\nconst contentEl = ea.targetView.contentEl;\nconst sleep = async (ms) =&gt; new Promise((resolve) =&gt; ownerWindow.setTimeout(resolve, ms));\n\n//-------------------------------\n//clean up potential clutter from previous run\n//-------------------------------\nwindow.removePresentationEventHandlers?.();\n\n//1. check if line or arrow is selected, if not check if frames are available, if not inform the user and terminate presentation\nlet presentationPathLineEl = ea.getViewElements()\n  .filter(el=&gt;[&quot;line&quot;,&quot;arrow&quot;].contains(el.type) &amp;&amp; el.customData?.slideshow)[0];\nlet frames = ea.getViewElements()\n  .filter(el=&gt;el.type===&quot;frame&quot;)\n  .map((f,i)=&gt;[f,i]) //because frame.name is null until set\n  .sort((el1,el2)=&gt;((el1[0].name??`Frame $&#123;el1[1]&#125;`)&gt;(el2[0].name??`Frame $&#123;el2[1]&#125;`))?1:-1)\n  .map(el=&gt;el[0]); \nlet presentationPathType = &quot;line&quot;; // &quot;frame&quot;\nconst selectedEl = ea.getViewSelectedElement();\nlet shouldHideArrowAfterPresentation = true; //this controls if the hide arrow button is available in settings\nif(presentationPathLineEl &amp;&amp; selectedEl &amp;&amp; [&quot;line&quot;,&quot;arrow&quot;].contains(selectedEl.type)) &#123;\n  excalidrawAPI.setToast(&#123;\n    message:&quot;Using selected line instead of hidden line. Note that there is a hidden presentation path for this drawing. Run the slideshow script without selecting any elements to access the hidden presentation path&quot;,\n    duration: 5000,\n    closable: true\n  &#125;)\n  shouldHideArrowAfterPresentation = false;\n  presentationPathLineEl = selectedEl;\n&#125;\nif(!presentationPathLineEl) presentationPathLineEl = selectedEl;\nif(!presentationPathLineEl || ![&quot;line&quot;,&quot;arrow&quot;].contains(presentationPathLineEl.type)) &#123;\n    if(frames.length &gt; 0) &#123;\n      presentationPathType = &quot;frame&quot;;\n    &#125; else &#123;\n      excalidrawAPI.setToast(&#123;\n        message:&quot;Please select the line or arrow for the presentation path or add frames.&quot;,\n        duration: 3000,\n        closable: true\n      &#125;)\n      return;\n    &#125;\n&#125;\n\n//---------------------------------------------\n// generate slides[] array\n//---------------------------------------------\nlet slides = [];\n\nif(presentationPathType === &quot;line&quot;) &#123;\n    const getLineSlideRect = (&#123;pointA, pointB&#125;) =&gt; &#123;\n      const x1 = presentationPathLineEl.x+pointA[0];\n      const y1 = presentationPathLineEl.y+pointA[1];\n      const x2 = presentationPathLineEl.x+pointB[0];\n      const y2 = presentationPathLineEl.y+pointB[1];\n      return &#123; x1, y1, x2, y2&#125;;\n    &#125;\n    \n    const slideCount = Math.floor(presentationPathLineEl.points.length/2)-1;\n    for(i=0;i&lt;=slideCount;i++) &#123;\n      slides.push(getLineSlideRect(&#123;\n        pointA:presentationPathLineEl.points[i*2],\n        pointB:presentationPathLineEl.points[i*2+1]\n      &#125;))\n    &#125;\n&#125;\n\nif(presentationPathType === &quot;frame&quot;) &#123;\n    for(frame of frames) &#123;\n        slides.push(&#123;\n          x1: frame.x,\n          y1: frame.y,\n          x2: frame.x + frame.width,\n          y2: frame.y + frame.height\n        &#125;);\n    &#125;\n    excalidrawAPI.updateScene(&#123;appState:&#123;shouldRenderFrames:false&#125;&#125;);\n&#125;\n\n//---------------------------------------\n// Toggle fullscreen\n//---------------------------------------\nlet toggleFullscreenButton;\nlet controlPanelEl;\nlet selectSlideDropdown;\n\nconst resetControlPanelElPosition = () =&gt; &#123;\n  if(!controlPanelEl) return;\n  const top = contentEl.innerHeight; \n  const left = contentEl.innerWidth/2; \n  controlPanelEl.style.top = `calc($&#123;top&#125;px - var(--default-button-size)*2)`;\n  controlPanelEl.style.left = `calc($&#123;left&#125;px - var(--default-button-size)*5)`;\n  slide--;\n  navigate(&quot;fwd&quot;);\n&#125;\n\nconst waitForExcalidrawResize = async () =&gt; &#123;\n  await sleep(100);\n    const deltaWidth = () =&gt; Math.abs(contentEl.clientWidth-excalidrawAPI.getAppState().width);\n    const deltaHeight = () =&gt; Math.abs(contentEl.clientHeight-excalidrawAPI.getAppState().height);\n    let watchdog = 0;\n    while ((deltaWidth()&gt;50 || deltaHeight()&gt;50) &amp;&amp; watchdog++&lt;20) await sleep(50); //wait for Excalidraw to resize to fullscreen\n&#125;\n\nlet preventFullscreenExit = true;\nconst gotoFullscreen = async () =&gt; &#123;\n  if(isFullscreen) return;\n  preventFullscreenExit = true;\n    if(app.isMobile) &#123;\n      ea.viewToggleFullScreen();\n    &#125; else &#123;\n        await contentEl.webkitRequestFullscreen();\n    &#125;\n    await waitForExcalidrawResize();\n    const layerUIWrapper = contentEl.querySelector(&quot;.layer-ui__wrapper&quot;);\n    if(!layerUIWrapper.hasClass(&quot;excalidraw-hidden&quot;)) layerUIWrapper.addClass(&quot;excalidraw-hidden&quot;);\n    if(toggleFullscreenButton) toggleFullscreenButton.innerHTML = SVG_MINIMIZE;\n    resetControlPanelElPosition();\n    isFullscreen = true;\n&#125;\n\nconst exitFullscreen = async () =&gt; &#123;\n  if(!isFullscreen) return;\n  preventFullscreenExit = true;\n  if(!app.isMobile &amp;&amp; ownerDocument?.fullscreenElement) await ownerDocument.exitFullscreen();\n  if(app.isMobile) ea.viewToggleFullScreen();\n  if(toggleFullscreenButton) toggleFullscreenButton.innerHTML = SVG_MAXIMIZE;\n  await waitForExcalidrawResize();\n  resetControlPanelElPosition();\n  isFullscreen = false;\n&#125;\n\nconst toggleFullscreen = async () =&gt; &#123;\n if (isFullscreen) &#123;\n   await exitFullscreen();\n &#125; else &#123;\n     await gotoFullscreen();\n &#125;\n&#125;\n\n//-----------------------------------------------------\n// hide the arrow for the duration of the presentation\n// and save the arrow color before doing so\n//-----------------------------------------------------\nlet isHidden;\nlet originalProps;\nconst toggleArrowVisibility = async (setToHidden) =&gt; &#123;\n    ea.clear();\n    ea.copyViewElementsToEAforEditing(ea.getViewElements().filter(el=&gt;el.id === presentationPathLineEl.id));\n    const el = ea.getElement(presentationPathLineEl.id);\n    el.strokeColor = &quot;transparent&quot;;\n    el.backgroundColor = &quot;transparent&quot;;\n    const customData = el.customData;\n    if(setToHidden &amp;&amp; shouldHideArrowAfterPresentation) &#123;\n        el.locked = true;\n        el.customData = &#123;\n            ...customData,\n            slideshow: &#123;\n                originalProps,\n                hidden: true\n            &#125;\n        &#125;\n        isHidden = true;\n    &#125; else &#123;\n        if(customData) delete el.customData.slideshow;\n        isHidden = false;\n    &#125;\n    await ea.addElementsToView();\n&#125;\n\nif(presentationPathType===&quot;line&quot;) &#123;\n    originalProps = presentationPathLineEl.customData?.slideshow?.hidden\n      ? presentationPathLineEl.customData.slideshow.originalProps\n      : &#123;\n          strokeColor: presentationPathLineEl.strokeColor,\n          backgroundColor: presentationPathLineEl.backgroundColor,\n          locked: presentationPathLineEl.locked,\n      &#125;;\n    isHidden = presentationPathLineEl.customData?.slideshow?.hidden ?? false;\n&#125;\n\n//-----------------------------\n// scroll-to-location functions\n//-----------------------------\nconst getNavigationRect = (&#123; x1, y1, x2, y2 &#125;) =&gt; &#123;\n  const &#123; width, height &#125; = excalidrawAPI.getAppState();\n  const ratioX = width / Math.abs(x1 - x2);\n  const ratioY = height / Math.abs(y1 - y2);\n  let ratio = Math.min(Math.max(ratioX, ratioY), 10);\n\n  const scaledWidth = Math.abs(x1 - x2) * ratio;\n  const scaledHeight = Math.abs(y1 - y2) * ratio;\n\n  if (scaledWidth &gt; width || scaledHeight &gt; height) &#123;\n    ratio = Math.min(width / Math.abs(x1 - x2), height / Math.abs(y1 - y2));\n  &#125;\n\n  const deltaX = (width / ratio - Math.abs(x1 - x2)) / 2;\n  const deltaY = (height / ratio - Math.abs(y1 - y2)) / 2;\n\n  return &#123;\n    left: (x1 &lt; x2 ? x1 : x2) - deltaX,\n    top: (y1 &lt; y2 ? y1 : y2) - deltaY,\n    right: (x1 &lt; x2 ? x2 : x1) + deltaX,\n    bottom: (y1 &lt; y2 ? y2 : y1) + deltaY,\n    nextZoom: ratio,\n  &#125;;\n&#125;;\n\nconst getNextSlideRect = (forward) =&gt; &#123;\n  slide = forward\n    ? slide &lt; slides.length-1 ? slide + 1     : 0\n    : slide &lt;= 0            ? slides.length-1 : slide - 1;\n    return getNavigationRect(slides[slide]);\n&#125;\n\nlet busy = false;\nconst scrollToNextRect = async (&#123;left,top,right,bottom,nextZoom&#125;,steps = TRANSITION_STEP_COUNT) =&gt; &#123;\n  const startTimer = Date.now();\n  let watchdog = 0;\n  while(busy &amp;&amp; watchdog++&lt;15) await(100);\n  if(busy &amp;&amp; watchdog &gt;= 15) return;\n  busy = true;\n  excalidrawAPI.updateScene(&#123;appState:&#123;shouldCacheIgnoreZoom:true&#125;&#125;);\n  const &#123;scrollX, scrollY, zoom&#125; = excalidrawAPI.getAppState();\n  const zoomStep = (zoom.value-nextZoom)/steps;\n  const xStep = (left+scrollX)/steps;\n  const yStep = (top+scrollY)/steps;\n  let i=1;\n  while(i&lt;=steps) &#123;\n    excalidrawAPI.updateScene(&#123;\n      appState: &#123;\n        scrollX:scrollX-(xStep*i),\n        scrollY:scrollY-(yStep*i),\n        zoom:&#123;value:zoom.value-zoomStep*i&#125;,\n      &#125;\n    &#125;);\n    const ellapsed = Date.now()-startTimer;\n    if(ellapsed &gt; TRANSITION_DELAY) &#123;\n      i = i&lt;steps ? steps : steps+1;\n    &#125; else &#123;\n      const timeProgress = ellapsed / TRANSITION_DELAY;\n      i=Math.min(Math.round(steps*timeProgress),steps)\n      await sleep(FRAME_SLEEP);\n    &#125;\n  &#125;\n  excalidrawAPI.updateScene(&#123;appState:&#123;shouldCacheIgnoreZoom:false&#125;&#125;);\n  busy = false;\n&#125;\n\nconst navigate = async (dir) =&gt; &#123;\n  const forward = dir === &quot;fwd&quot;;\n  const prevSlide = slide;\n  const nextRect = getNextSlideRect(forward);\n  \n  //exit if user navigates from last slide forward or first slide backward\n  const shouldExit = forward\n    ? slide&lt;=prevSlide\n    : slide&gt;=prevSlide;\n  if(shouldExit) &#123;\n    exitPresentation();\n    return;\n  &#125;\n  if(selectSlideDropdown) selectSlideDropdown.value = slide+1;\n  await scrollToNextRect(nextRect);\n&#125;\n\nconst navigateToSlide = (slideNumber) =&gt; &#123;\n  if(slideNumber &gt; slides.length) slideNumber = slides.length;\n  if(slideNumber &lt; 1) slideNumber = 1;\n  slide = slideNumber - 2;\n  navigate(&quot;fwd&quot;);\n&#125;\n\n//--------------------------------------\n// Slideshow control panel\n//--------------------------------------\nlet controlPanelFadeTimout = 0;\nconst setFadeTimeout = (delay) =&gt; &#123;\n  delay = delay ?? TRANSITION_DELAY;\n  controlPanelFadeTimeout = ownerWindow.setTimeout(()=&gt;&#123;\n    controlPanelFadeTimout = 0;\n    if(ownerDocument.activeElement === selectSlideDropdown) &#123;\n      setFadeTimeout(delay);\n      return;\n    &#125;\n      controlPanelEl.style.opacity = FADE_LEVEL;\n  &#125;,delay);\n&#125;\nconst clearFadeTimeout = () =&gt; &#123;\n  if(controlPanelFadeTimeout) &#123;\n      ownerWindow.clearTimeout(controlPanelFadeTimeout);\n      controlPanelFadeTimeout = 0;\n  &#125;\n  controlPanelEl.style.opacity = 1;\n&#125;\n\nconst createPresentationNavigationPanel = () =&gt; &#123;\n  //create slideshow controlpanel container\n  const top = contentEl.innerHeight; \n  const left = contentEl.innerWidth/2; \n  controlPanelEl = contentEl.querySelector(&quot;.excalidraw&quot;).createDiv(&#123;\n    cls: [&quot;excalidraw-presentation-panel&quot;],\n    attr: &#123;\n      style: `\n        width: fit-content;\n        z-index:5;\n        position: absolute;\n        top:calc($&#123;top&#125;px - var(--default-button-size)*2);\n        left:calc($&#123;left&#125;px - var(--default-button-size)*5);`\n    &#125;\n  &#125;);\n  setFadeTimeout(TRANSITION_DELAY*3);\n  \n  const panelColumn = controlPanelEl.createDiv(&#123;\n    cls: &quot;panelColumn&quot;,\n  &#125;);\n  \n    panelColumn.createDiv(&#123;\n      cls: [&quot;Island&quot;, &quot;buttonList&quot;],\n      attr: &#123;\n        style: `\n          max-width: unset;\n          justify-content: space-between;\n          height: calc(var(--default-button-size)*1.5);\n          width: 100%;\n          background: var(--island-bg-color);\n          display: flex;\n          align-items: center;`,\n      &#125;\n    &#125;, el=&gt;&#123;\n      el.createEl(&quot;style&quot;, \n        &#123; text: ` select:focus &#123; box-shadow: var(--input-shadow);&#125; `&#125;);\n      el.createEl(&quot;button&quot;,&#123;\n        attr: &#123;\n          style: `\n            margin-left: calc(var(--default-button-size)*0.25);`,\n          &quot;aria-label&quot;: &quot;Previous slide&quot;,\n          title: &quot;Previous slide&quot;\n        &#125;\n      &#125;, button =&gt; &#123;\n        button.innerHTML = SVG_LEFT_ARROW;\n        button.onclick = () =&gt; navigate(&quot;bkwd&quot;)\n      &#125;);\n    selectSlideDropdown = el.createEl(&quot;select&quot;, &#123;\n      attr: &#123;\n        style: `\n          font-size: inherit;\n          background-color: var(--island-bg-color);\n          border: none;\n          color: var(--color-gray-100);\n          cursor: pointer;\n        &#125;`,\n        title: &quot;Navigate to slide&quot;\n      &#125;\n    &#125;, selectEl =&gt; &#123;\n        for (let i = 0; i &lt; slides.length; i++) &#123;\n          const option = document.createElement(&quot;option&quot;);\n          option.text = `Slide $&#123;i + 1&#125;/$&#123;slides.length&#125;`;\n          option.value = i + 1;\n          selectEl.add(option);\n        &#125;\n        selectEl.addEventListener(&quot;change&quot;, () =&gt; &#123;\n          const selectedSlideNumber = parseInt(selectEl.value);\n          selectEl.blur();\n          navigateToSlide(selectedSlideNumber);\n        &#125;);\n      &#125;);\n      el.createEl(&quot;button&quot;,&#123;\n        attr: &#123;\n          title: &quot;Next slide&quot;\n        &#125;,\n      &#125;, button =&gt; &#123;\n        button.innerHTML = SVG_RIGHT_ARROW;\n        button.onclick = () =&gt; navigate(&quot;fwd&quot;);\n      &#125;);\n      el.createDiv(&#123;\n          attr: &#123;\n          style: `\n            width: 1px;\n            height: var(--default-button-size);\n            background-color: var(--default-border-color);\n            margin: 0px auto;`\n          &#125;\n        &#125;);\n       el.createEl(&quot;button&quot;,&#123;\n        attr: &#123;\n          title: &quot;Toggle fullscreen. If you hold ALT/OPT when starting the presentation it will not go fullscreen.&quot;\n        &#125;,\n      &#125;, button =&gt; &#123;\n        toggleFullscreenButton = button;\n        button.innerHTML = isFullscreen ? SVG_MINIMIZE : SVG_MAXIMIZE;\n        button.onclick = () =&gt; toggleFullscreen();\n      &#125;);\n      if(presentationPathType === &quot;line&quot;) &#123;\n        if(shouldHideArrowAfterPresentation) &#123;\n            new ea.obsidian.ToggleComponent(el)\n              .setValue(isHidden)\n              .onChange(value =&gt; &#123;\n                if(value) &#123;\n                  excalidrawAPI.setToast(&#123;\n                            message:&quot;The presentation path remain hidden after the presentation. No need to select the line again. Just click the slideshow button to start the next presentation.&quot;,\n                            duration: 5000,\n                            closable: true\n                          &#125;)\n                &#125;\n                toggleArrowVisibility(value);\n              &#125;)\n              .toggleEl.setAttribute(&quot;title&quot;,&quot;Arrow visibility. ON: hidden after presentation, OFF: visible after presentation&quot;);\n          &#125;\n          el.createEl(&quot;button&quot;,&#123;\n            attr: &#123;\n              title: &quot;Edit slide&quot;\n            &#125;,\n          &#125;, button =&gt; &#123;\n            button.innerHTML = SVG_EDIT;\n            button.onclick = () =&gt; &#123;\n              if(shouldHideArrowAfterPresentation) toggleArrowVisibility(false);\n              exitPresentation(true);\n            &#125;\n          &#125;);\n        &#125;\n      el.createEl(&quot;button&quot;,&#123;\n        attr: &#123;\n          style: `\n            margin-right: calc(var(--default-button-size)*0.25);`,\n          title: &quot;End presentation&quot;\n        &#125;\n      &#125;, button =&gt; &#123;\n        button.innerHTML = SVG_FINISH;\n        button.onclick = () =&gt; exitPresentation()\n      &#125;);\n    &#125;);\n&#125;\n\n//--------------------\n// keyboard navigation\n//--------------------\nconst keydownListener = (e) =&gt; &#123;\n  if(ea.targetView.leaf !== app.workspace.activeLeaf) return;\n  e.preventDefault();\n  switch(e.key) &#123;\n    case &quot;Escape&quot;:\n      exitPresentation();\n      break;\n    case &quot;ArrowRight&quot;:\n    case &quot;ArrowDown&quot;: \n      navigate(&quot;fwd&quot;);\n      break;\n    case &quot;ArrowLeft&quot;:\n    case &quot;ArrowUp&quot;:\n      navigate(&quot;bkwd&quot;);\n      break;\n    case &quot;End&quot;:\n      slide = slides.length - 2;\n      navigate(&quot;fwd&quot;);\n      break;\n    case &quot;Home&quot;:\n      slide = -1;\n      navigate(&quot;fwd&quot;);\n      break;\n    case &quot;e&quot;: \n      if(presentationPathType !== &quot;line&quot;) return;\n      (async ()=&gt;&#123;\n        await toggleArrowVisibility(false);\n        exitPresentation(true);\n      &#125;)()\n      break;\n  &#125;\n&#125;\n\n//---------------------\n// slideshow panel drag\n//---------------------\nlet posX1 = posY1 = posX2 = posY2 = 0;\n\nconst updatePosition = (deltaY = 0, deltaX = 0) =&gt; &#123;\n  const &#123;\n    offsetTop,\n    offsetLeft,\n    clientWidth: width,\n    clientHeight: height,\n   &#125; = controlPanelEl;\n  controlPanelEl.style.top = (offsetTop - deltaY) + &#39;px&#39;;\n  controlPanelEl.style.left = (offsetLeft - deltaX) + &#39;px&#39;;\n&#125;\n   \nconst onPointerUp = () =&gt; &#123;\n  ownerWindow.removeEventListener(&#39;pointermove&#39;, onDrag, true);\n&#125;\n\nconst onPointerDown = (e) =&gt; &#123;\n    clearFadeTimeout();\n    setFadeTimeout();\n  const now = Date.now();\n  posX2 = e.clientX;\n  posY2 = e.clientY;\n  ownerWindow.addEventListener(&#39;pointermove&#39;, onDrag, true);\n&#125;\n\nconst onDrag = (e) =&gt; &#123;\n  e.preventDefault();\n  posX1 = posX2 - e.clientX;\n  posY1 = posY2 - e.clientY;\n  posX2 = e.clientX;\n  posY2 = e.clientY;\n  updatePosition(posY1, posX1);\n&#125;\n\nconst onMouseEnter = () =&gt; &#123;\n    clearFadeTimeout();\n&#125;\n\nconst onMouseLeave = () =&gt; &#123;\n    setFadeTimeout();\n&#125;\n\nconst fullscreenListener = (e) =&gt; &#123;\n  if(preventFullscreenExit) &#123;\n      preventFullscreenExit = false;\n    return;\n  &#125;\n  e.preventDefault();\n  exitPresentation();\n&#125;\n\nconst initializeEventListners = () =&gt; &#123;\n    ownerWindow.addEventListener(&#39;keydown&#39;,keydownListener);\n  controlPanelEl.addEventListener(&#39;pointerdown&#39;, onPointerDown, false);\n  controlPanelEl.addEventListener(&#39;mouseenter&#39;, onMouseEnter, false);\n  controlPanelEl.addEventListener(&#39;mouseleave&#39;, onMouseLeave, false);\n  ownerWindow.addEventListener(&#39;pointerup&#39;, onPointerUp, false);\n\n    //event listners for terminating the presentation\n    window.removePresentationEventHandlers = () =&gt; &#123;\n      ea.onLinkClickHook = null;\n      controlPanelEl.removeEventListener(&#39;pointerdown&#39;, onPointerDown, false);\n      controlPanelEl.removeEventListener(&#39;mouseenter&#39;, onMouseEnter, false);\n      controlPanelEl.removeEventListener(&#39;mouseleave&#39;, onMouseLeave, false);\n      controlPanelEl.parentElement?.removeChild(controlPanelEl);\n      if(!app.isMobile) &#123;\n        contentEl.removeEventListener(&#39;webkitfullscreenchange&#39;, fullscreenListener);\n        contentEl.removeEventListener(&#39;fullscreenchange&#39;, fullscreenListener);\n      &#125;\n      ownerWindow.removeEventListener(&#39;keydown&#39;,keydownListener);\n      ownerWindow.removeEventListener(&#39;pointerup&#39;,onPointerUp);\n      contentEl.querySelector(&quot;.layer-ui__wrapper&quot;)?.removeClass(&quot;excalidraw-hidden&quot;);\n      delete window.removePresentationEventHandlers;\n    &#125;\n\n    ea.onLinkClickHook = () =&gt; &#123;\n    exitPresentation();\n    return true;\n  &#125;;\n  \n  if(!app.isMobile) &#123;\n    contentEl.addEventListener(&#39;webkitfullscreenchange&#39;, fullscreenListener);\n    contentEl.addEventListener(&#39;fullscreenchange&#39;, fullscreenListener);\n  &#125;\n&#125;\n\n//----------------------------\n// Exit presentation\n//----------------------------\nconst exitPresentation = async (openForEdit = false) =&gt; &#123;\n  statusBarElement.style.display = &quot;inherit&quot;;\n  if(openForEdit) ea.targetView.preventAutozoom();\n  await exitFullscreen();\n  await waitForExcalidrawResize();\n  ea.setViewModeEnabled(false);\n  if(presentationPathType === &quot;line&quot;) &#123;\n      ea.clear();\n      ea.copyViewElementsToEAforEditing(ea.getViewElements().filter(el=&gt;el.id === presentationPathLineEl.id));\n      const el = ea.getElement(presentationPathLineEl.id);\n      if(!isHidden) &#123;\n        el.strokeColor = originalProps.strokeColor;\n        el.backgroundProps = originalProps.backgroundColor;\n        el.locked = openForEdit ? false : originalProps.locked;\n      &#125;\n      await ea.addElementsToView();\n      if(!isHidden) ea.selectElementsInView([el]);\n      if(openForEdit) &#123;\n        let nextRect = getNextSlideRect(--slide);\n        const offsetW = (nextRect.right-nextRect.left)*(1-EDIT_ZOOMOUT)/2;\n        const offsetH = (nextRect.bottom-nextRect.top)*(1-EDIT_ZOOMOUT)/2\n        nextRect = &#123;\n          left: nextRect.left-offsetW,\n          right: nextRect.right+offsetW,\n          top: nextRect.top-offsetH,\n          bottom: nextRect.bottom+offsetH,\n          nextZoom: nextRect.nextZoom*EDIT_ZOOMOUT &gt; 0.1 ? nextRect.nextZoom*EDIT_ZOOMOUT : 0.1 //0.1 is the minimu zoom value\n        &#125;;\n        await scrollToNextRect(nextRect,1);\n        excalidrawAPI.startLineEditor(\n          ea.getViewSelectedElement(),\n          [slide*2,slide*2+1]\n        );\n      &#125;\n    &#125; else &#123;\n      excalidrawAPI.updateScene(&#123;appState:&#123;shouldRenderFrames:true&#125;&#125;);\n    &#125;\n  window.removePresentationEventHandlers?.();\n  ownerWindow.setTimeout(()=&gt;&#123;\n    //Resets pointer offsets. Ugly solution. \n    //During testing offsets were wrong after presentation, but don&#39;t know why.\n    //This should solve it even if they are wrong.\n    ea.targetView.refresh(); \n  &#125;)\n&#125;\n\n//--------------------------\n// Start presentation or open presentation settings on double click\n//--------------------------\nconst start = async () =&gt; &#123;\n  statusBarElement.style.display = &quot;none&quot;;\n  ea.setViewModeEnabled(true);\n  createPresentationNavigationPanel();\n  initializeEventListners();\n  if(startFullscreen) &#123;\n    await gotoFullscreen();\n  &#125; else &#123;\n    resetControlPanelElPosition();\n  &#125;\n  if(presentationPathType === &quot;line&quot;) await toggleArrowVisibility(isHidden);\n&#125;\n\nconst timestamp = Date.now();\nif(window.ExcalidrawSlideshow &amp;&amp; (window.ExcalidrawSlideshow.script === utils.scriptFile.path) &amp;&amp; (timestamp - window.ExcalidrawSlideshow.timestamp &lt;400) ) &#123;\n  if(window.ExcalidrawSlideshowStartTimer) &#123;\n    window.clearTimeout(window.ExcalidrawSlideshowStartTimer);\n    delete window.ExcalidrawSlideshowStartTimer;\n  &#125;\n  await start();\n&#125; else &#123;\n  if(window.ExcalidrawSlideshowStartTimer) &#123;\n    window.clearTimeout(window.ExcalidrawSlideshowStartTimer);\n    delete window.ExcalidrawSlideshowStartTimer;\n  &#125;\n  window.ExcalidrawSlideshow = &#123;\n    script: utils.scriptFile.path,\n    timestamp\n  &#125;;\n  window.ExcalidrawSlideshowStartTimer = window.setTimeout(start,500);\n&#125;\n\n","slug":"Slideshow","date":"2023-07-29T10:00:19.313Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"d37cd5b7639fe7782428852b11a0610c","title":"Set Text Alignment","content":"&#x2F;*\nSets text alignment of text block (cetner, right, left). Useful if you want to set a keyboard shortcut for selecting text alignment.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nelements = ea.getViewSelectedElements().filter((el)=&gt;el.type===&quot;text&quot;);\nif(elements.length===0) return;\nlet align = [&quot;left&quot;,&quot;right&quot;,&quot;center&quot;];\nalign = await utils.suggester(align,align);\nelements.forEach((el)=&gt;el.textAlign = align);\nea.copyViewElementsToEAforEditing(elements);\nea.addElementsToView(false,false);\n\n","slug":"Set Text Alignment","date":"2023-07-29T10:00:19.310Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"9a8550c64fa90eb259c71d9e03c5fa95","title":"Set Stroke Width of Selected Elements","content":"&#x2F;*\nThis script will set the stroke width of selected elements. This is helpful, for example, when you scale freedraw sketches and want to reduce or increase their line width.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nlet width = (ea.getViewSelectedElement().strokeWidth??1).toString();\nwidth = await utils.inputPrompt(&quot;Width?&quot;,&quot;number&quot;,width);\nconst elements=ea.getViewSelectedElements();\nea.copyViewElementsToEAforEditing(elements);\nea.getElements().forEach((el)=&gt;el.strokeWidth=width);\nea.addElementsToView(false,false);\n\n","slug":"Set Stroke Width of Selected Elements","date":"2023-07-29T10:00:19.308Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"b8a59cd07c9db13b8323543f90989d95","title":"Set Link Alias","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nIterates all of the links in the selected TextElements and prompts the user to set or modify the alias for each link found.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nelements = ea.getViewSelectedElements().filter((el)=&gt;el.type===&quot;text&quot;);\n// `[[markdown links]]`\nfor(el of elements) &#123; //doing for instead of .forEach due to await inputPrompt\n  parts = el.rawText.split(/(\\[\\[[\\w\\W]*?]])/);\n  newText = &quot;&quot;;\n  for(t of parts) &#123; //doing for instead of .map due to await inputPrompt\n    if(!t.match(/(\\[\\[[\\w\\W]*?]])/)) &#123;\n      newText += t;\n    &#125; else &#123;\n      original = t.split(/\\[\\[|]]/)[1];\n      cut = original.indexOf(&quot;|&quot;);\n      alias = cut === -1 ? &quot;&quot; : original.substring(cut+1);\n      link = cut === -1 ? original : original.substring(0,cut);\n      alias = await utils.inputPrompt(`Alias for [[$&#123;link&#125;]]`,&quot;type alias here&quot;,alias);\n      newText += `[[$&#123;link&#125;|$&#123;alias&#125;]]`;\n    &#125;\n  &#125;\n  el.rawText = newText;\n&#125;;\n\n// `[wiki](links)`\nfor(el of elements) &#123; //doing for instead of .forEach due to await inputPrompt\n  parts = el.rawText.split(/(\\[[\\w\\W]*?]\\([\\w\\W]*?\\))/);\n  newText = &quot;&quot;;\n  for(t of parts) &#123; //doing for instead of .map due to await inputPrompt\n    if(!t.match(/(\\[[\\w\\W]*?]\\([\\w\\W]*?\\))/)) &#123;\n      newText += t;\n    &#125; else &#123;\n      alias = t.match(/\\[([\\w\\W]*?)]/)[1];\n      link = t.match(/\\(([\\w\\W]*?)\\)/)[1];\n      alias = await utils.inputPrompt(`Alias for [[$&#123;link&#125;]]`,&quot;type alias here&quot;,alias);\n      newText += `[[$&#123;link&#125;|$&#123;alias&#125;]]`;\n    &#125;\n  &#125;\n  el.rawText = newText;\n&#125;;\n\nea.copyViewElementsToEAforEditing(elements);\nea.addElementsToView(false,false);\n\n","slug":"Set Link Alias","date":"2023-07-29T10:00:19.306Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"52331c3cbeee9322bcec9e71574c7928","title":"Set Grid","content":"&#x2F;*\nThe default grid size in Excalidraw is 20. Currently there is no way to change the grid size via the user interface. This script offers a way to bridge this gap.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.8.11&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nconst api = ea.getExcalidrawAPI();\nlet appState = api.getAppState();\nconst grid = parseInt(await utils.inputPrompt(&quot;Grid size?&quot;,null,appState.previousGridSize?.toString()??&quot;20&quot;));\nif(isNaN(grid)) return; //this is to avoid passing an illegal value to Excalidraw\nappState.gridSize = grid;\nappState.previousGridSize = grid;\napi.updateScene(&#123;\n  appState,\n  commitToHistory:false\n&#125;);\n\n","slug":"Set Grid","date":"2023-07-29T10:00:19.303Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"c0f512e8731cac419be071f0bba36d94","title":"Set Font Family","content":"&#x2F;*\nSets font family of the text block (Virgil, Helvetica, Cascadia). Useful if you want to set a keyboard shortcut for selecting font family.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nelements = ea.getViewSelectedElements().filter((el)=&gt;el.type===&quot;text&quot;);\nif(elements.length===0) return;\nlet font = [&quot;Virgil&quot;,&quot;Helvetica&quot;,&quot;Cascadia&quot;];\nfont = parseInt(await utils.suggester(font,[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]));\nif (isNaN(font)) return;\nelements.forEach((el)=&gt;el.fontFamily = font);\nea.copyViewElementsToEAforEditing(elements);\nea.addElementsToView(false,false);\n\n","slug":"Set Font Family","date":"2023-07-29T10:00:19.300Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"1dbc4fb7c1571db30247f5cd85752d10","title":"Set Dimensions","content":"&#x2F;*\n\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nCurrently there is no way to specify the exact location and size of objects in Excalidraw. You can bridge this gap with the following simple script. \nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nconst elements = ea.getViewSelectedElements();\nif(elements.length === 0) return;\nconst el = ea.getLargestElement(elements);\nconst sizeIn = [\n  Math.round(el.x),\n  Math.round(el.y),\n  Math.round(el.width),\n  Math.round(el.height)\n].join(&quot;,&quot;);\nlet res = await utils.inputPrompt(&quot;x,y,width,height?&quot;,null,sizeIn);\nres = res.split(&quot;,&quot;);\nif(res.length !== 4) return;\nlet size = [];\nfor (v of res) &#123;\n  const i = parseInt(v);\n  if(isNaN(i)) return;\n  size.push(i);\n&#125;\nel.x = size[0];\nel.y = size[1];\nel.width = size[2];\nel.height = size[3];\nea.copyViewElementsToEAforEditing([el]);\nea.addElementsToView(false,false);\n\n","slug":"Set Dimensions","date":"2023-07-29T10:00:19.298Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"83e6e3c9ec496d8b2a732e3ac4601a3c","title":"Set background color of unclosed line object by adding a shadow clone","content":"&#x2F;*\nUse this script to set the background color of unclosed (i.e. open) line, arrow and freedraw objects by creating a clone of the object. The script will set the stroke color of the clone to transparent and will add a straight line to close the object. Use settings to define the default background color, the fill style, and the strokeWidth of the clone. By default the clone will be grouped with the original object, you can disable this also in settings.\n*/\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.26&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Background Color&quot;]) &#123;\n  settings = &#123;\n    &quot;Background Color&quot; : &#123;\n      value: &quot;DimGray&quot;,\n      description: &quot;Default background color of the &#39;shadow&#39; object. Any valid html css color value&quot;,\n    &#125;,\n      &quot;Fill Style&quot;: &#123;\n          value: &quot;hachure&quot;,\n            valueset: [&quot;hachure&quot;,&quot;cross-hatch&quot;,&quot;solid&quot;],\n            description: &quot;Default fill style of the &#39;shadow&#39; object.&quot;\n        &#125;,\n      &quot;Inherit fill stroke width&quot;: &#123;\n          value: true,\n            description: &quot;This will impact the densness of the hachure or cross-hatch fill. Use the stroke width of the line object for which the shadow is created. If set to false, the script will use a stroke width of 2.&quot;\n        &#125;,\n        &quot;Group &#39;shadow&#39; with original&quot;: &#123;\n          value: true,\n            description: &quot;If the toggle is on then the shadow object that is created will be grouped with the unclosed original object.&quot;\n        &#125;\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125;\n\nconst inheritStrokeWidth = settings[&quot;Inherit fill stroke width&quot;].value;\nconst backgroundColor = settings[&quot;Background Color&quot;].value;\nconst fillStyle = settings[&quot;Fill Style&quot;].value;\nconst shouldGroup = settings[&quot;Group &#39;shadow&#39; with original&quot;].value;\n\nconst elements = ea.getViewSelectedElements().filter(el=&gt;el.type===&quot;line&quot; || el.type===&quot;freedraw&quot; || el.type===&quot;arrow&quot;);\nif(elements.length === 0) &#123;\n  new Notice(&quot;No line or freedraw object is selected&quot;);\n&#125;\n\nea.copyViewElementsToEAforEditing(elements);\nelementsToMove = [];\n\nelements.forEach((el)=&gt;&#123;\n  const newEl = ea.cloneElement(el);\n  ea.elementsDict[newEl.id] = newEl;\n  newEl.roughness = 1;\n  if(!inheritStrokeWidth) newEl.strokeWidth = 2;\n  newEl.strokeColor = &quot;transparent&quot;;\n  newEl.backgroundColor = backgroundColor;\n  newEl.fillStyle = fillStyle;\n  if (newEl.type === &quot;arrow&quot;) newEl.type = &quot;line&quot;;\n  const i = el.points.length-1;\n  newEl.points.push([ \n  //adding an extra point close to the last point in case distance is long from last point to origin and there is a sharp bend. This will avoid a spike due to a tight curve.\n    el.points[i][0]*0.9,\n    el.points[i][1]*0.9,\n  ]);\n  newEl.points.push([0,0]);\n  if(shouldGroup) ea.addToGroup([el.id,newEl.id]);\n  elementsToMove.push(&#123;fillId: newEl.id, shapeId: el.id&#125;);\n&#125;);\n\nawait ea.addElementsToView(false,false);\nelementsToMove.forEach((x)=&gt;&#123;\n  const viewElements = ea.getViewElements();\n  ea.moveViewElementToZIndex(\n    x.fillId,\n    viewElements.indexOf(viewElements.filter(el=&gt;el.id === x.shapeId)[0])-1\n  )\n&#125;);\n\nea.selectElementsInView(ea.getElements());\n\n","slug":"Set background color of unclosed line object by adding a shadow clone","date":"2023-07-29T10:00:19.296Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"d63d52fab50d4e7787db7464cd2acc66","title":"Select Elements of Type","content":"&#x2F;*Prompts you with a list of the different element types in the active image. Only elements of the selected type will be selected on the canvas. If nothing is selected when running the script, then the script will process all the elements on the canvas. If some elements are selected when the script is executed, then the script will only process the selected elements.\nThe script is useful when, for example, you want to bring to front all the arrows, or want to change the color of all the text elements, etc.\n*/\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.24&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nlet elements = ea.getViewSelectedElements();\nif(elements.length === 0) elements = ea.getViewElements();\nif(elements.length === 0) &#123;\n  new Notice(&quot;There are no elements in the view&quot;);\n  return;\n&#125;\n\ntypeSet = new Set();\nelements.forEach(el=&gt;typeSet.add(el.type));\nlet elementType = Array.from(typeSet)[0];\n        \nif(typeSet.size &gt; 1) &#123;\n    elementType = await utils.suggester(\n      Array.from(typeSet).map((item) =&gt; &#123; \n          switch(item) &#123;\n                case &quot;line&quot;: return &quot;— line&quot;;\n                case &quot;ellipse&quot;: return &quot;○ ellipse&quot;;\n          case &quot;rectangle&quot;: return &quot;□ rectangle&quot;;\n          case &quot;diamond&quot;: return &quot;◇ diamond&quot;;\n          case &quot;arrow&quot;: return &quot;→ arrow&quot;;\n          case &quot;freedraw&quot;: return &quot;✎ freedraw&quot;;\n          case &quot;image&quot;: return &quot;🖼 image&quot;;\n          case &quot;text&quot;: return &quot;A text&quot;;\n          default: return item;\n        &#125;\n        &#125;),\n      Array.from(typeSet)\n    );\n&#125; \n\nif(!elementType) return;\n\nea.selectElementsInView(elements.filter(el=&gt;el.type === elementType));\n\n","slug":"Select Elements of Type","date":"2023-07-29T10:00:19.293Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"783f38c95bffc6fc70117678c5bd20cf","title":"Scribble Helper","content":"&#x2F;*\nScribble Helper can improve handwriting and add links. It lets you create and edit text elements, including wrapped text and sticky notes, by double-tapping on the canvas. When you run the script, it creates an event handler that will activate the editor when you double-tap. If you select a text element on the canvas before running the script, it will open the editor for that element. If you use a pen, you can set it up to only activate Scribble Helper when you double-tap with the pen. The event handler is removed when you run the script a second time or switch to a different tab.\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.8.25&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nconst helpLINK = &quot;https://youtu.be/BvYkOaly-QM&quot;;\nconst DBLCLICKTIMEOUT = 300;\nconst maxWidth = 600;\nconst padding = 6;\nconst api = ea.getExcalidrawAPI();\nconst win = ea.targetView.ownerWindow;\nif(!win.ExcalidrawScribbleHelper) win.ExcalidrawScribbleHelper = &#123;&#125;;\nif(typeof win.ExcalidrawScribbleHelper.penOnly === &quot;undefined&quot;) &#123;\n  win.ExcalidrawScribbleHelper.penOnly = false;\n&#125;\nlet windowOpen = false; //to prevent the modal window to open again while writing with scribble\nlet prevZoomValue = api.getAppState().zoom.value; //used to avoid trigger on pinch zoom\n\n// -------------\n// Load settings\n// -------------\nlet settings = ea.getScriptSettings();\n//set default values on first-ever run of the script\nif(!settings[&quot;Default action&quot;]) &#123;\n  settings = &#123;\n    &quot;Default action&quot; : &#123;\n      value: &quot;Text&quot;,\n      valueset: [&quot;Text&quot;,&quot;Sticky&quot;,&quot;Wrap&quot;],\n      description: &quot;What type of element should CTRL/CMD+ENTER create. TEXT: A regular text element. &quot; +\n        &quot;STICKY: A sticky note with border color and background color &quot; +\n        &quot;(using the current setting of the canvas). STICKY: A sticky note with transparent &quot; +\n        &quot;border and background color.&quot;\n    &#125;,\n  &#125;;\n  await ea.setScriptSettings(settings);\n&#125;\n\nif(typeof win.ExcalidrawScribbleHelper.action === &quot;undefined&quot;) &#123;\n  win.ExcalidrawScribbleHelper.action = settings[&quot;Default action&quot;].value;\n&#125;\n\n//---------------------------------------\n// Color Palette for stroke color setting\n//---------------------------------------\n// https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.6.8\nconst defaultStrokeColors = [\n    &quot;#000000&quot;, &quot;#343a40&quot;, &quot;#495057&quot;, &quot;#c92a2a&quot;, &quot;#a61e4d&quot;,\n    &quot;#862e9c&quot;, &quot;#5f3dc4&quot;, &quot;#364fc7&quot;, &quot;#1864ab&quot;, &quot;#0b7285&quot;,\n    &quot;#087f5b&quot;, &quot;#2b8a3e&quot;, &quot;#5c940d&quot;, &quot;#e67700&quot;, &quot;#d9480f&quot;\n  ];\n\nconst loadColorPalette = () =&gt; &#123;\n  const st = api.getAppState();\n  const strokeColors = new Set();\n  let strokeColorPalette = st.colorPalette?.elementStroke ?? defaultStrokeColors;\n  if(Object.entries(strokeColorPalette).length === 0) &#123;\n    strokeColorPalette = defaultStrokeColors;\n  &#125;\n\n  ea.getViewElements().forEach(el =&gt; &#123;\n    if(el.strokeColor.toLowerCase()===&quot;transparent&quot;) return;\n    strokeColors.add(el.strokeColor);\n  &#125;);\n\n  strokeColorPalette.forEach(color =&gt; &#123;\n    strokeColors.add(color)\n  &#125;);\n\n  strokeColors.add(st.currentItemStrokeColor ?? ea.style.strokeColor);\n  return strokeColors;\n&#125;\n\n//----------------------------------------------------------\n// Define variables to cache element location on first click\n//----------------------------------------------------------\n// if a single element is selected when the action is started, update that existing text\nlet containerElements = ea.getViewSelectedElements()\n  .filter(el=&gt;[&quot;arrow&quot;,&quot;rectangle&quot;,&quot;ellipse&quot;,&quot;line&quot;,&quot;diamond&quot;].contains(el.type));\nlet selectedTextElements = ea.getViewSelectedElements().filter(el=&gt;el.type===&quot;text&quot;);\n\n//-------------------------------------------\n// Functions to add and remove event listners\n//-------------------------------------------\nconst addEventHandler = (handler) =&gt; &#123;\n  if(win.ExcalidrawScribbleHelper.eventHandler) &#123;\n    win.removeEventListner(&quot;pointerdown&quot;, handler);\n  &#125;\n  win.addEventListener(&quot;pointerdown&quot;,handler);\n  win.ExcalidrawScribbleHelper.eventHandler = handler;\n  win.ExcalidrawScribbleHelper.window = win;\n&#125;\n\nconst removeEventHandler = (handler) =&gt; &#123;\n  win.removeEventListener(&quot;pointerdown&quot;,handler);\n  delete win.ExcalidrawScribbleHelper.eventHandler;\n  delete win.ExcalidrawScribbleHelper.window;\n&#125;\n\n//Stop the script if scribble helper is clicked and no eligable element is selected\nlet silent = false;\nif (win.ExcalidrawScribbleHelper?.eventHandler) &#123;\n  removeEventHandler(win.ExcalidrawScribbleHelper.eventHandler);\n  delete win.ExcalidrawScribbleHelper.eventHandler;\n  delete win.ExcalidrawScribbleHelper.window;\n  if(!(containerElements.length === 1 || selectedTextElements.length === 1)) &#123;\n    new Notice (&quot;Scribble Helper was stopped&quot;,1000);\n    return;\n  &#125;\n  silent = true;\n&#125;\n\n// ----------------------\n// Custom dialog controls\n// ----------------------\nif (typeof win.ExcalidrawScribbleHelper.penOnly === &quot;undefined&quot;) &#123;\n  win.ExcalidrawScribbleHelper.penOnly = undefined;\n&#125;\nif (typeof win.ExcalidrawScribbleHelper.penDetected === &quot;undefined&quot;) &#123;\n  win.ExcalidrawScribbleHelper.penDetected = false;\n&#125;\nlet timer = Date.now();\nlet eventHandler = () =&gt; &#123;&#125;;\n\nconst customControls =  (container) =&gt; &#123;\n  const helpDIV = container.createDiv();\n  helpDIV.innerHTML = `&lt;a href=&quot;$&#123;helpLINK&#125;&quot; target=&quot;_blank&quot;&gt;Click here for help&lt;/a&gt;`;\n  const viewBackground = api.getAppState().viewBackgroundColor;\n  const el1 = new ea.obsidian.Setting(container)\n    .setName(`Text color`)\n    .addDropdown(dropdown =&gt; &#123;\n      Array.from(loadColorPalette()).forEach(color =&gt; &#123;\n        const options = dropdown.addOption(color, color).selectEl.options;\n        options[options.length-1].setAttribute(&quot;style&quot;,`color: $&#123;color\n          &#125;; background: $&#123;viewBackground&#125;;`);\n      &#125;);\n      dropdown\n        .setValue(ea.style.strokeColor)\n        .onChange(value =&gt; &#123;\n          ea.style.strokeColor = value;\n          el1.nameEl.style.color = value;\n        &#125;)\n    &#125;)\n  el1.nameEl.style.color = ea.style.strokeColor;\n  el1.nameEl.style.background = viewBackground;\n  el1.nameEl.style.fontWeight = &quot;bold&quot;;\n                                 \n  const el2 = new ea.obsidian.Setting(container)\n    .setName(`Trigger editor by pen double tap only`)\n    .addToggle((toggle) =&gt; toggle\n      .setValue(win.ExcalidrawScribbleHelper.penOnly)\n      .onChange(value =&gt; &#123;\n        win.ExcalidrawScribbleHelper.penOnly = value;\n      &#125;)\n    )\n  el2.settingEl.style.border = &quot;none&quot;;\n  el2.settingEl.style.display = win.ExcalidrawScribbleHelper.penDetected ? &quot;&quot; : &quot;none&quot;;\n&#125;\n\n// -------------------------------\n// Click / dbl click event handler\n// -------------------------------\neventHandler = async (evt) =&gt; &#123;\n  if(windowOpen) return;\n  if(ea.targetView !== app.workspace.activeLeaf.view) removeEventHandler(eventHandler);\n  if(evt &amp;&amp; evt.target &amp;&amp; !evt.target.hasClass(&quot;excalidraw__canvas&quot;)) return;\n  if(evt &amp;&amp; (evt.ctrlKey || evt.altKey || evt.metaKey || evt.shiftKey)) return;  \n  const st = api.getAppState();\n  win.ExcalidrawScribbleHelper.penDetected = st.penDetected;\n  \n  //don&#39;t trigger text editor when editing a line or arrow\n  if(st.editingElement &amp;&amp; [&quot;arrow&quot;,&quot;line&quot;].contains(st.editingElment.type)) return; \n  \n  if(typeof win.ExcalidrawScribbleHelper.penOnly === &quot;undefined&quot;) &#123;\n    win.ExcalidrawScribbleHelper.penOnly = false;\n  &#125;\n  \n  if (evt &amp;&amp; win.ExcalidrawScribbleHelper.penOnly &amp;&amp;\n    win.ExcalidrawScribbleHelper.penDetected &amp;&amp; evt.pointerType !== &quot;pen&quot;) return;\n  const now = Date.now();\n  \n  //the &lt;50 condition is to avoid false double click when pinch zooming\n  if((now-timer &gt; DBLCLICKTIMEOUT) || (now-timer &lt; 50)) &#123;\n    prevZoomValue = st.zoom.value;\n    timer = now;\n    containerElements = ea.getViewSelectedElements()\n      .filter(el=&gt;[&quot;arrow&quot;,&quot;rectangle&quot;,&quot;ellipse&quot;,&quot;line&quot;,&quot;diamond&quot;].contains(el.type));\n    selectedTextElements = ea.getViewSelectedElements().filter(el=&gt;el.type===&quot;text&quot;);\n      return;\n  &#125;\n  //further safeguard against triggering when pinch zooming\n  if(st.zoom.value !== prevZoomValue) return;\n  \n  //sleeping to allow keyboard to pop up on mobile devices\n  await sleep(200);\n  ea.clear();\n\n  //if a single element with text is selected, edit the text\n  //(this can be an arrow, a sticky note, or just a text element)\n  if(selectedTextElements.length === 1) &#123;\n    editExistingTextElement(selectedTextElements);\n    return;\n  &#125;\n  \n  let containerID;\n  let container;\n  //if no text elements are selected (i.e. not multiple text  elements selected),\n  //check if there is a single eligeable container selected\n  if(selectedTextElements.length === 0) &#123;\n    if(containerElements.length === 1) &#123;\n      ea.copyViewElementsToEAforEditing(containerElements);\n      containerID = containerElements[0].id\n      container = ea.getElement(containerID);\n    &#125;\n  &#125;\n  \n  const &#123;x,y&#125; = ea.targetView.currentPosition;\n\n  if(ea.targetView !== app.workspace.activeLeaf.view) return;\n  const actionButtons = [\n    &#123;\n      caption: `A`,\n      tooltip: &quot;Add as Text Element&quot;,\n      action: () =&gt; &#123;\n        win.ExcalidrawScribbleHelper.action=&quot;Text&quot;;\n        if(settings[&quot;Default action&quot;].value!==&quot;Text&quot;) &#123;\n          settings[&quot;Default action&quot;].value = &quot;Text&quot;;\n          ea.setScriptSettings(settings);\n        &#125;;\n        return;\n      &#125;\n    &#125;,\n    &#123;\n      caption: &quot;📝&quot;,\n      tooltip: &quot;Add as Sticky Note (rectangle with border color and background color)&quot;,\n      action: () =&gt; &#123;\n        win.ExcalidrawScribbleHelper.action=&quot;Sticky&quot;;\n        if(settings[&quot;Default action&quot;].value!==&quot;Sticky&quot;) &#123;\n          settings[&quot;Default action&quot;].value = &quot;Sticky&quot;;\n          ea.setScriptSettings(settings);\n        &#125;;\n        return;\n      &#125;\n    &#125;,\n    &#123;\n      caption: &quot;☱&quot;,\n      tooltip: &quot;Add as Wrapped Text (rectangle with transparent border and background)&quot;,\n      action: () =&gt; &#123;\n        win.ExcalidrawScribbleHelper.action=&quot;Wrap&quot;;\n        if(settings[&quot;Default action&quot;].value!==&quot;Wrap&quot;) &#123;\n          settings[&quot;Default action&quot;].value = &quot;Wrap&quot;;\n          ea.setScriptSettings(settings);\n        &#125;;\n        return;\n      &#125;\n    &#125;\n  ];\n  if(win.ExcalidrawScribbleHelper.action !== &quot;Text&quot;) actionButtons.push(actionButtons.shift());\n  if(win.ExcalidrawScribbleHelper.action === &quot;Wrap&quot;) actionButtons.push(actionButtons.shift());\n\n  ea.style.strokeColor = st.currentItemStrokeColor ?? ea.style.strokeColor;\n  ea.style.roughness = st.currentItemRoughness ?? ea.style.roughness;\n  ea.setStrokeSharpness(st.currentItemRoundness === &quot;round&quot; ? 0 : st.currentItemRoundness)\n  ea.style.backgroundColor = st.currentItemBackgroundColor ?? ea.style.backgroundColor;\n  ea.style.fillStyle = st.currentItemFillStyle ?? ea.style.fillStyle;\n  ea.style.fontFamily = st.currentItemFontFamily ?? ea.style.fontFamily;\n  ea.style.fontSize = st.currentItemFontSize ?? ea.style.fontSize;\n  ea.style.textAlign = (container &amp;&amp; [&quot;arrow&quot;,&quot;line&quot;].contains(container.type))\n    ? &quot;center&quot;\n    : (container &amp;&amp; [&quot;rectangle&quot;,&quot;diamond&quot;,&quot;ellipse&quot;].contains(container.type))\n      ? &quot;center&quot;\n      : st.currentItemTextAlign ?? &quot;center&quot;;\n  ea.style.verticalAlign = &quot;middle&quot;;\n\n  windowOpen = true;\n  const text = await utils.inputPrompt (\n    &quot;Edit text&quot;, &quot;&quot;, &quot;&quot;, containerID?undefined:actionButtons, 5, true, customControls, true\n  );\n  windowOpen = false;\n\n  if(!text || text.trim() === &quot;&quot;) return;\n\n  const textId = ea.addText(x,y, text);\n  if (!container &amp;&amp; (win.ExcalidrawScribbleHelper.action === &quot;Text&quot;)) &#123;\n    ea.addElementsToView(false, false, true);\n    addEventHandler(eventHandler);\n    return;\n  &#125;\n  const textEl = ea.getElement(textId);\n\n  if(!container &amp;&amp; (win.ExcalidrawScribbleHelper.action === &quot;Wrap&quot;)) &#123;\n    ea.style.backgroundColor = &quot;transparent&quot;;\n    ea.style.strokeColor = &quot;transparent&quot;;\n  &#125;\n\n  if(!container &amp;&amp; (win.ExcalidrawScribbleHelper.action === &quot;Sticky&quot;)) &#123;\n    textEl.textAlign = &quot;center&quot;;\n  &#125;\n\n  const boxes = [];\n  if(container) &#123;\n    boxes.push(containerID);\n    const linearElement = [&quot;arrow&quot;,&quot;line&quot;].contains(container.type);\n    const l = linearElement ? container.points.length-1 : 0;\n    const dx = linearElement &amp;&amp; (container.points[l][0] &lt; 0) ? -1 : 1;\n    const dy = linearElement &amp;&amp; (container.points[l][1] &lt; 0) ? -1 : 1;\n    cx = container.x + dx*container.width/2;\n    cy = container.y + dy*container.height/2;\n    textEl.x = cx - textEl.width/2;\n    textEl.y = cy - textEl.height/2;\n  &#125;\n\n  if(!container) &#123;\n    const width = textEl.width+2*padding;\n    const widthOK = width&lt;=maxWidth;\n    containerID = ea.addRect(\n      textEl.x-padding,\n      textEl.y-padding,\n      widthOK ? width : maxWidth,\n      textEl.height + 2 * padding\n    );\n    container = ea.getElement(containerID);\n  &#125; \n  boxes.push(containerID);\n  container.boundElements=[&#123;type:&quot;text&quot;,id: textId&#125;];\n  textEl.containerId = containerID;\n  //ensuring the correct order of elements, first container, then text\n  delete ea.elementsDict[textEl.id];\n  ea.elementsDict[textEl.id] = textEl;\n\n  await ea.addElementsToView(false,false,true);\n  const containers = ea.getViewElements().filter(el=&gt;boxes.includes(el.id));\n  if([&quot;rectangle&quot;,&quot;diamond&quot;,&quot;ellipse&quot;].includes(container.type)) api.updateContainerSize(containers);\n  ea.selectElementsInView(containers);\n&#125;;\n\n// ---------------------\n// Edit Existing Element\n// ---------------------\nconst editExistingTextElement = async (elements) =&gt; &#123;\n  windowOpen = true;\n  ea.copyViewElementsToEAforEditing(elements);\n  const el = ea.getElements()[0];\n  ea.style.strokeColor = el.strokeColor;\n  const text = await utils.inputPrompt(\n    &quot;Edit text&quot;,&quot;&quot;,elements[0].rawText,undefined,5,true,customControls,true\n  ); \n  windowOpen = false;\n  if(!text) return;\n  \n  el.strokeColor = ea.style.strokeColor;\n  el.originalText = text;\n  el.text = text;\n  el.rawText = text;\n  ea.refreshTextElementSize(el.id);\n  await ea.addElementsToView(false,false);\n  if(el.containerId) &#123;\n    const containers = ea.getViewElements().filter(e=&gt;e.id === el.containerId);\n    api.updateContainerSize(containers);\n    ea.selectElementsInView(containers);\n  &#125;\n&#125;\n\n//--------------\n// Start actions\n//--------------\nif(!win.ExcalidrawScribbleHelper?.eventHandler) &#123;\n  if(!silent) new Notice(\n    &quot;To create a new text element,\\ndouble-tap the screen.\\n\\n&quot; +\n    &quot;To edit text,\\ndouble-tap an existing element.\\n\\n&quot; +\n    &quot;To stop the script,\\ntap it again or switch to a different tab.&quot;,\n    5000\n  );\n  addEventHandler(eventHandler);\n&#125;\n\nif(containerElements.length === 1 || selectedTextElements.length === 1) &#123;\n  timer = timer - 100;\n  eventHandler();\n&#125;\n\n","slug":"Scribble Helper","date":"2023-07-29T10:00:19.291Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"19078ee4c978271aa8e1231ea4870b9c","title":"Reverse arrows","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nReverse the direction of arrows within the scope of selected elements.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nelements = ea.getViewSelectedElements().filter((el)=&gt;el.type===&quot;arrow&quot;);\nif(!elements || elements.length===0) return;\nelements.forEach((el)=&gt;&#123;\n    const start = el.startArrowhead;\n    el.startArrowhead = el.endArrowhead;\n    el.endArrowhead = start;\n&#125;);\nea.copyViewElementsToEAforEditing(elements);\nea.addElementsToView(false,false);\n\n","slug":"Reverse arrows","date":"2023-07-29T10:00:19.289Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"157ce0eee3d9c2ed779f4b047afcb6dc","title":"Repeat Elements","content":"&#x2F;*\n\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script will detect the difference between 2 selected elements, including position, size, angle, stroke and background color, and create several elements that repeat these differences based on the number of repetitions entered by the user.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.7.19&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nlet repeatNum = parseInt(await utils.inputPrompt(&quot;repeat times?&quot;,&quot;number&quot;,&quot;5&quot;));\nif(!repeatNum) &#123;\n    new Notice(&quot;Please enter a number.&quot;);\n    return;\n&#125;\n\nconst selectedElements = ea.getViewSelectedElements().sort((lha,rha) =&gt; \n    lha.x === rha.x? (lha.y === rha.y? \n    (lha.width === rha.width? \n    (lha.height - rha.height) : lha.width - rha.width) \n    : lha.y - rha.y) : lha.x - rha.x);\n\nif(selectedElements.length !== 2) &#123;\n    new Notice(&quot;Please select 2 elements.&quot;);\n    return;\n&#125;\n\nif(selectedElements[0].type !== selectedElements[1].type) &#123;\n    new Notice(&quot;The selected elements must be of the same type.&quot;);\n    return;\n&#125;\n\nconst xDistance = selectedElements[1].x - selectedElements[0].x;\nconst yDistance = selectedElements[1].y - selectedElements[0].y;\nconst widthDistance = selectedElements[1].width - selectedElements[0].width;\nconst heightDistance = selectedElements[1].height - selectedElements[0].height;\nconst angleDistance = selectedElements[1].angle - selectedElements[0].angle;\n\nconst bgColor1 = ea.colorNameToHex(selectedElements[0].backgroundColor);\nconst cmBgColor1 = ea.getCM(bgColor1);\nconst bgColor2 = ea.colorNameToHex(selectedElements[1].backgroundColor);\nlet   cmBgColor2 = ea.getCM(bgColor2);\nconst isBgTransparent = cmBgColor1.alpha === 0  || cmBgColor2.alpha === 0;\nconst bgHDistance = cmBgColor2.hue - cmBgColor1.hue;\nconst bgSDistance = cmBgColor2.saturation - cmBgColor1.saturation;\nconst bgLDistance = cmBgColor2.lightness - cmBgColor1.lightness;\nconst bgADistance = cmBgColor2.alpha - cmBgColor1.alpha;\n\nconst strokeColor1 = ea.colorNameToHex(selectedElements[0].strokeColor);\nconst cmStrokeColor1 = ea.getCM(strokeColor1);\nconst strokeColor2 = ea.colorNameToHex(selectedElements[1].strokeColor);\nlet   cmStrokeColor2 = ea.getCM(strokeColor2);\nconst isStrokeTransparent = cmStrokeColor1.alpha === 0 || cmStrokeColor2.alpha ===0;\nconst strokeHDistance = cmStrokeColor2.hue - cmStrokeColor1.hue;\nconst strokeSDistance = cmStrokeColor2.saturation - cmStrokeColor1.saturation;\nconst strokeLDistance = cmStrokeColor2.lightness - cmStrokeColor1.lightness;\nconst strokeADistance = cmStrokeColor2.alpha - cmStrokeColor1.alpha;\n\n\nea.copyViewElementsToEAforEditing(selectedElements);\nfor(let i=0; i&lt;repeatNum; i++) &#123;\n    const newEl = ea.cloneElement(selectedElements[1]);\n    ea.elementsDict[newEl.id] = newEl;\n    newEl.x += xDistance * (i + 1);\n    newEl.y += yDistance * (i + 1);\n    newEl.angle += angleDistance * (i + 1);\n    const originWidth = newEl.width;\n    const originHeight = newEl.height;\n    const newWidth = newEl.width + widthDistance * (i + 1);\n    const newHeight = newEl.height + heightDistance * (i + 1);\n    if(newWidth &gt;= 0 &amp;&amp; newHeight &gt;= 0) &#123;\n        if(newEl.type === &#39;arrow&#39; || newEl.type === &#39;line&#39; || newEl.type === &#39;freedraw&#39;) &#123;\n          const minX = Math.min(...newEl.points.map(pt =&gt; pt[0]));\n          const minY = Math.min(...newEl.points.map(pt =&gt; pt[1]));\n          for(let j = 0; j &lt; newEl.points.length; j++) &#123;\n            if(newEl.points[j][0] &gt; minX) &#123;\n              newEl.points[j][0] = newEl.points[j][0] + ((newEl.points[j][0] - minX) / originWidth) * (newWidth - originWidth);\n            &#125;\n            if(newEl.points[j][1] &gt; minY) &#123;\n              newEl.points[j][1] = newEl.points[j][1] + ((newEl.points[j][1] - minY) / originHeight) * (newHeight - originHeight);\n            &#125;\n          &#125;\n        &#125;\n        else &#123;\n          newEl.width = newWidth;\n          newEl.height = newHeight;\n        &#125;\n    &#125;\n\n    if(!isBgTransparent) &#123;\n        cmBgColor2 = cmBgColor2.hueBy(bgHDistance).saturateBy(bgSDistance).lighterBy(bgLDistance).alphaBy(bgADistance);\n        newEl.backgroundColor = cmBgColor2.stringHEX();\n    &#125; else &#123;\n      newEl.backgroundColor = &quot;transparent&quot;;\n    &#125;\n\n    if(!isStrokeTransparent) &#123;\n        cmStrokeColor2 = cmStrokeColor2.hueBy(strokeHDistance).saturateBy(strokeSDistance).lighterBy(strokeLDistance).alphaBy(strokeADistance);\n        newEl.strokeColor = cmStrokeColor2.stringHEX();\n    &#125; else &#123;\n      newEl.strokeColor = &quot;transparent&quot;;\n    &#125;\n&#125;\n\nawait ea.addElementsToView(false, false, true);\n\n","slug":"Repeat Elements","date":"2023-07-29T10:00:19.287Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"0979f76108535de26ea84ad0bdc87200","title":"Rename Image","content":"&#x2F;*\n\nSelect an image on the canvas and run the script. You will be prompted to provide a new filename &#x2F; filepath. This cuts down the time to name images you paste from the web or drag and drop from your file system.\n*/\nawait ea.addElementsToView(); //to ensure all images are saved into the file\n\nconst img = ea.getViewSelectedElements().filter(el=&gt;el.type === &quot;image&quot;);\nif(img.length === 0) &#123;\n  new Notice(&quot;No image is selected&quot;);\n  return;\n&#125;\n\nfor(i of img) &#123;\n  const currentPath = ea.plugin.filesMaster.get(i.fileId).path;\n  const file = app.vault.getAbstractFileByPath(currentPath);\n  if(!file) &#123;\n      new Notice(&quot;Can&#39;t find file: &quot; + currentPath);\n      continue;\n  &#125;\n  const pathNoExtension = file.path.substring(0,file.path.length-file.extension.length-1);\n  const newPath = await utils.inputPrompt(&quot;Please provide the filename&quot;,&quot;file path&quot;,pathNoExtension);\n  if(newPath &amp;&amp; newPath !== pathNoExtension) &#123;\n      await app.fileManager.renameFile(file,`$&#123;newPath&#125;.$&#123;file.extension&#125;`);\n  &#125;\n&#125;\n\n","slug":"Rename Image","date":"2023-07-29T10:00:19.285Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"c8987ed647e3062b499b6ebe7475f48f","title":"PDF Page Text to Clipboard","content":"&#x2F;*Copies the text from the selected PDF page on the Excalidraw canvas to the clipboard.\n\nLink:: https://youtu.be/Kwt_8WdOUT4\n\n\nconst el = ea.getViewSelectedElements().filter(el=&gt;el.type===&quot;image&quot;)[0];\nif(!el) &#123;\n  new Notice(&quot;Select a PDF page&quot;);\n  return;\n&#125;\nconst f = ea.getViewFileForImageElement(el);\nif(f.extension.toLowerCase() !== &quot;pdf&quot;) &#123;\n  new Notice(&quot;Select a PDF page&quot;);\n  return;\n&#125;\n\nconst pageNum = parseInt(ea.targetView.excalidrawData.getFile(el.fileId).linkParts.ref.replace(/\\D/g, &quot;&quot;));\nif(isNaN(pageNum)) &#123;\n  new Notice(&quot;Can&#39;t find page number&quot;);\n  return;\n&#125;\n\nconst pdfDoc = await window.pdfjsLib.getDocument(app.vault.getResourcePath(f)).promise;\nconst page = await pdfDoc.getPage(pageNum);\nconst text = await page.getTextContent();\nif(!text) &#123;\n    new Notice(&quot;Could not get text&quot;);\n    return;\n&#125;\npdfDoc.destroy();\nwindow.navigator.clipboard.writeText(\n  text.items.reduce((acc, cur) =&gt; acc + cur.str.replace(/\\x00/ug, &#39;&#39;) + (cur.hasEOL ? &quot;\\n&quot; : &quot;&quot;),&quot;&quot;)\n);\nnew Notice(&quot;Page text is available on the clipboard&quot;);\n\n","slug":"PDF Page Text to Clipboard","date":"2023-07-29T10:00:19.283Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"0b0066a8613d76f0c8f7aecf59e585d7","title":"Palette loader","content":"&#x2F;*\n\nLink:: https://youtu.be/epYNx2FSf2w\n\n\nLink:: https://youtu.be/diBT5iaoAYo\n\nDesign your palette at http://paletton.com/Once you are happy with your colors, click Tables&#x2F;Export in the bottom right of the screen:Then click “Color swatches&#x2F;as Sketch Palette”\nCopy the contents of the page to a markdown file in your vault. Place the file in the Excalidraw&#x2F;Palettes folder (you can change this folder in settings).\n\n\nExcalidraw  appState Custom Palette Data Object:\ncolorPalette: &#123;\n  canvasBackground: [string, string, string, string, string][] | string[],\n  elementBackground: [string, string, string, string, string][] | string[],\n  elementStroke: [string, string, string, string, string][] | string[],\n  topPicks: &#123;\n    canvasBackground: [string, string, string, string, string],\n    elementStroke: [string, string, string, string, string],\n    elementBackground: [string, string, string, string, string] \n  &#125;,\n&#125;\n\n*/\n//--------------------------\n// Load settings\n//--------------------------\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.9.2&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nconst api = ea.getExcalidrawAPI();\nlet settings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Palette folder&quot;]) &#123;\n  settings = &#123;\n    &quot;Palette folder&quot; : &#123;\n      value: &quot;Excalidraw/Palettes&quot;,\n      description: &quot;The path to the folder where you store the Excalidraw Palettes&quot;\n    &#125;,\n    &quot;Light-gray&quot; : &#123;\n      value: &quot;#505050&quot;,\n      description: &quot;Base light-gray used for mixing with the accent color to generate the palette light-gray&quot;\n    &#125;,\n    &quot;Dark-gray&quot; : &#123;\n      value: &quot;#e0e0e0&quot;,\n      description: &quot;Base dark-gray used for mixing with the accent color to generate the palette dark-gray&quot;\n    &#125;\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125;\n\nconst lightGray = settings[&quot;Light-gray&quot;].value;\nconst darkGray = settings[&quot;Dark-gray&quot;].value;\n\nlet paletteFolder = settings[&quot;Palette folder&quot;].value.toLowerCase();\nif(paletteFolder === &quot;&quot; || paletteFolder === &quot;/&quot;) &#123;\n  new Notice(&quot;The palette folder cannot be the root folder of your vault&quot;);\n  return;\n&#125;\n\nif(!paletteFolder.endsWith(&quot;/&quot;)) paletteFolder += &quot;/&quot;;\n\n\n//-----------------------\n// UPDATE CustomPalette\n//-----------------------\nconst updateColorPalette = (paletteFragment) =&gt; &#123;\n  const st = ea.getExcalidrawAPI().getAppState();\n  colorPalette = st.colorPalette ?? &#123;&#125;;\n  if(paletteFragment?.topPicks) &#123;\n    if(!colorPalette.topPicks) &#123;\n      colorPalette.topPicks = &#123;\n        ...paletteFragment.topPicks\n      &#125;;\n    &#125; else &#123;\n      colorPalette.topPicks = &#123;\n        ...colorPalette.topPicks,\n        ...paletteFragment.topPicks\n      &#125;\n    &#125;\n  &#125; else &#123;\n    colorPalette = &#123;\n      ...colorPalette,\n      ...paletteFragment\n    &#125;\n  &#125;\n  ea.viewUpdateScene(&#123;appState: &#123;colorPalette&#125;&#125;);\n  ea.addElementsToView(true,true); //elements is empty, but this will save the file\n&#125;\n\n\n//----------------\n// LOAD PALETTE\n//----------------\nconst loadPalette = async () =&gt; &#123;\n  //--------------------------\n  // Select palette\n  //--------------------------\n  const palettes = app.vault.getFiles()\n    .filter(f=&gt;f.extension === &quot;md&quot; &amp;&amp; f.path.toLowerCase() === paletteFolder + f.name.toLowerCase())\n    .sort((a,b)=&gt;a.basename.toLowerCase()&lt;b.basename.toLowerCase()?-1:1);\n  const file = await utils.suggester([&quot;Excalidraw Default&quot;].concat(palettes.map(f=&gt;f.name)),[&quot;Default&quot;].concat(palettes), &quot;Choose a palette, press ESC to abort&quot;);\n  if(!file) return;\n\n  if(file === &quot;Default&quot;) &#123;\n    api.updateScene(&#123;\n      appState: &#123;\n        colorPalette: &#123;&#125;\n      &#125;\n    &#125;);\n    return;\n  &#125;\n\n  //--------------------------\n  // Load palette\n  //--------------------------\n  const sketchPalette = await app.vault.read(file);\n\n  const parseJSON = (data) =&gt; &#123;\n    try &#123;\n      return JSON.parse(data);\n    &#125; catch(e) &#123;\n      return;\n    &#125;\n  &#125;\n\n  const loadPaletteFromPlainText = (data) =&gt; &#123;\n    const colors = [];\n    data.replaceAll(&quot;\\r&quot;,&quot;&quot;).split(&quot;\\n&quot;).forEach(c=&gt;&#123;\n      c = c.trim();\n      if(c===&quot;&quot;) return;\n      if(c.match(/[^hslrga-fA-F\\(\\d\\.\\,\\%\\s)#]/)) return;\n      const cm = ea.getCM(c);\n      if(cm) colors.push(cm.stringHEX(&#123;alpha: false&#125;));\n    &#125;)\n    return colors;\n  &#125;\n\n  const paletteJSON = parseJSON(sketchPalette);\n\n  const colors = paletteJSON\n    ? paletteJSON.colors.map(c=&gt;ea.getCM(&#123;r:c.red*255,g:c.green*255,b:c.blue*255,a:c.alpha&#125;).stringHEX(&#123;alpha: false&#125;))\n    : loadPaletteFromPlainText(sketchPalette);\n  const baseColor = ea.getCM(colors[0]);\n\n  // Add black, white, transparent, gary\n  const palette = [[\n    &quot;transparent&quot;,\n    &quot;black&quot;,\n    baseColor.mix(&#123;color: lightGray, ratio:0.95&#125;).stringHEX(&#123;alpha: false&#125;),\n    baseColor.mix(&#123;color: darkGray, ratio:0.95&#125;).stringHEX(&#123;alpha: false&#125;),\n    &quot;white&quot;\n  ]];\n\n  // Create Excalidraw palette\n  for(i=0;i&lt;Math.floor(colors.length/5);i++) &#123;\n    palette.push([\n      colors[i*5+1],\n      colors[i*5+2],\n      colors[i*5],\n      colors[i*5+3],\n      colors[i*5+4]\n    ]);\n  &#125;\n\n  const getShades = (c,type) =&gt; &#123;\n    cm = ea.getCM(c);\n    const lightness = cm.lightness;\n    if(lightness === 0 || lightness === 100) return c;\n\n    switch(type) &#123;\n      case &quot;canvas&quot;:\n        return [\n          c,\n          ea.getCM(c).lightnessTo((100-lightness)*0.5+lightness).stringHEX(&#123;alpha: false&#125;),\n          ea.getCM(c).lightnessTo((100-lightness)*0.25+lightness).stringHEX(&#123;alpha: false&#125;),\n          ea.getCM(c).lightnessTo(lightness*0.5).stringHEX(&#123;alpha: false&#125;),\n          ea.getCM(c).lightnessTo(lightness*0.25).stringHEX(&#123;alpha: false&#125;),\n        ];\n      case &quot;stroke&quot;:\n        return [\n          ea.getCM(c).lightnessTo((100-lightness)*0.5+lightness).stringHEX(&#123;alpha: false&#125;),\n          ea.getCM(c).lightnessTo((100-lightness)*0.25+lightness).stringHEX(&#123;alpha: false&#125;),\n          ea.getCM(c).lightnessTo(lightness*0.5).stringHEX(&#123;alpha: false&#125;),\n          ea.getCM(c).lightnessTo(lightness*0.25).stringHEX(&#123;alpha: false&#125;),\n          c,\n        ];\n      case &quot;background&quot;:\n        return [\n          ea.getCM(c).lightnessTo((100-lightness)*0.5+lightness).stringHEX(&#123;alpha: false&#125;),\n          c,\n          ea.getCM(c).lightnessTo((100-lightness)*0.25+lightness).stringHEX(&#123;alpha: false&#125;),\n          ea.getCM(c).lightnessTo(lightness*0.5).stringHEX(&#123;alpha: false&#125;),\n          ea.getCM(c).lightnessTo(lightness*0.25).stringHEX(&#123;alpha: false&#125;),\n        ];\n    &#125;\n  &#125;\n\n  const paletteSize = palette.flat().length;\n  const newPalette = &#123;\n    canvasBackground: palette.flat().map(c=&gt;getShades(c,&quot;canvas&quot;)),\n    elementStroke: palette.flat().map(c=&gt;getShades(c,&quot;stroke&quot;)),\n    elementBackground: palette.flat().map(c=&gt;getShades(c,&quot;background&quot;))\n  &#125;;\n\n\n  //--------------------------\n  // Check if palette has the same size as the current. Is re-paint possible?\n  //--------------------------\n  const oldPalette = api.getAppState().colorPalette;\n\n  //You can only switch and repaint equal size palettes\n  let canRepaint = Boolean(oldPalette) &amp;&amp; Object.keys(oldPalette).length === 3 &amp;&amp;\n    oldPalette.canvasBackground.length  === paletteSize &amp;&amp;\n    oldPalette.elementBackground.length === paletteSize &amp;&amp;\n    oldPalette.elementStroke.length     === paletteSize;\n\n  //Check that the palette for canvas background, element stroke and element background are the same\n  for(i=0;canRepaint &amp;&amp; i&lt;paletteSize;i++) &#123;\n    if(\n      oldPalette.canvasBackground[i] !== oldPalette.elementBackground[i] ||\n      oldPalette.canvasBackground[i] !== oldPalette.elementStroke[i]\n    ) &#123;\n      canRepaint = false;\n      break;\n    &#125;\n  &#125;\n\n  const shouldRepaint = canRepaint &amp;&amp; await utils.suggester([&quot;Try repainting the drawing with the new palette&quot;,&quot;Just load the new palette&quot;], [true, false],&quot;ESC will load the palette without repainting&quot;);\n\n\n  //--------------------------\n  // Apply palette\n  //--------------------------\n  if(shouldRepaint) &#123;\n    const map = new Map();\n    for(i=0;i&lt;paletteSize;i++) &#123;\n      map.set(oldPalette.canvasBackground[i],newPalette.canvasBackground[i])\n    &#125;\n\n    ea.copyViewElementsToEAforEditing(ea.getViewElements());\n    ea.getElements().forEach(el=&gt;&#123;\n      el.strokeColor = map.get(el.strokeColor)??el.strokeColor;\n      el.backgroundColor = map.get(el.backgroundColor)??el.backgroundColor;\n    &#125;)\n\n    const canvasColor = api.getAppState().viewBackgroundColor;\n\n    await api.updateScene(&#123;\n      appState: &#123;\n        viewBackgroundColor: map.get(canvasColor)??canvasColor\n      &#125;\n    &#125;);\n\n    ea.addElementsToView();\n  &#125;\n  updateColorPalette(newPalette);\n&#125;\n\n//-------------\n// TOP PICKS\n//-------------\nconst topPicks = async () =&gt; &#123;\n  const elements = ea.getViewSelectedElements().filter(el=&gt;[&quot;rectangle&quot;, &quot;diamond&quot;, &quot;ellipse&quot;, &quot;line&quot;].includes(el.type));\n  if(elements.length !== 5) &#123;\n    new Notice(&quot;Select 5 elements, the script will use the background color of these elements&quot;,6000);\n    return;\n  &#125;\n\n  const colorType = await utils.suggester([&quot;View Background&quot;, &quot;Element Background&quot;, &quot;Stroke&quot;],[&quot;view&quot;, &quot;background&quot;, &quot;stroke&quot;], &quot;Which top-picks would you like to set?&quot;);\n\n  if(!colorType) &#123;\n    new Notice(&quot;You did not select which color to set&quot;);\n    return;\n  &#125;\n\n  const topPicks = elements.map(el=&gt;el.backgroundColor);\n  switch(colorType) &#123;\n    case &quot;view&quot;: updateColorPalette(&#123;topPicks: &#123;canvasBackground: topPicks&#125;&#125;); break;\n    case &quot;stroke&quot;: updateColorPalette(&#123;topPicks: &#123;elementStroke: topPicks&#125;&#125;); break;\n    default: updateColorPalette(&#123;topPicks: &#123;elementBackground: topPicks&#125;&#125;); break;\n  &#125;\n&#125;\n\n//-----------------------------------\n// Copy palette from another file\n//-----------------------------------\nconst copyPaletteFromFile = async () =&gt; &#123;\n  const files = app.vault.getFiles().filter(f =&gt; ea.isExcalidrawFile(f)).sort((a,b)=&gt;a.name &gt; b.name ? 1 : -1);\n  const file = await utils.suggester(files.map(f=&gt;f.path),files,&quot;Select the file to copy from&quot;);\n  if(!file) &#123;\n    return;\n  &#125;\n  scene = await ea.getSceneFromFile(file);\n  if(!scene || !scene.appState) &#123;\n      new Notice(&quot;unknown error&quot;);\n      return;\n  &#125;\n  ea.viewUpdateScene(&#123;appState: &#123;colorPalette: &#123;...scene.appState.colorPalette&#125;&#125;&#125;);\n  ea.addElementsToView(true,true);\n&#125;\n\n//----------\n// START\n//----------\nconst action = await utils.suggester(\n  [&quot;Load palette from file&quot;, &quot;Set top-picks based on the background color of 5 selected elements&quot;, &quot;Copy palette from another Excalidraw File&quot;],\n  [&quot;palette&quot;,&quot;top-picks&quot;,&quot;copy&quot;]\n);\nif(!action) return;\n\nswitch(action) &#123;\n  case &quot;palette&quot;: loadPalette(); break;\n  case &quot;top-picks&quot;: topPicks(); break;\n  case &quot;copy&quot;: copyPaletteFromFile(); break;\n&#125;\n\n","slug":"Palette loader","date":"2023-07-29T10:00:19.281Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"9d7a3d3fc9a4ed838ec1aaa19f2b5092","title":"Organic Line","content":"&#x2F;*\nConverts selected freedraw lines such that pencil pressure will decrease from maximum to minimum from the beginning of the line to its end. The resulting line is placed at the back of the layers, under all other items. Helpful when drawing organic mindmaps.\n*/\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.8.8&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nlet elements = ea.getViewSelectedElements().filter((el)=&gt;[&quot;freedraw&quot;,&quot;line&quot;,&quot;arrow&quot;].includes(el.type));\n\n//if nothing is selected find the last element that was drawn and use it if it is the right element type\nif(elements.length === 0) &#123;\n  elements = ea.getViewSelectedElements();\n  const len = elements.length;\n  if(len === 0 || [&quot;freedraw&quot;,&quot;line&quot;,&quot;arrow&quot;].includes(elements[len].type)) &#123;\n    return;\n  &#125;\n  elements = [elements[len]];\n&#125; \n\nconst lineType = await utils.suggester([&quot;Thick to thin&quot;, &quot;Thin to thick to thin&quot;],[&quot;l1&quot;,&quot;l2&quot;],&quot;Select the type of line&quot;);\nif(!lineType) return;\n\nea.copyViewElementsToEAforEditing(elements);\n\nea.getElements().forEach((el)=&gt;&#123;\n  el.simulatePressure = false;\n  el.type = &quot;freedraw&quot;;\n  el.pressures = Array(el.points.length).fill(1);\n  el.customData = &#123;\n    strokeOptions: &#123;\n      ... lineType === &quot;l1&quot;\n      ? &#123;\n          options: &#123;\n            thinning: 1,\n            smoothing: 0.5,\n            streamline: 0.5,\n            easing: &quot;linear&quot;,\n            start: &#123;\n              taper: 0,\n              cap: true\n            &#125;,\n            end: &#123;\n              taper: true,\n              easing: &quot;linear&quot;,\n              cap: false\n            &#125;\n          &#125;\n        &#125;\n      : &#123;\n          options: &#123;\n            thinning: 4,\n            smoothing: 0.5,\n            streamline: 0.5,\n            easing: &quot;linear&quot;,\n            start: &#123;\n              taper: true,\n              easing: &quot;linear&quot;,\n              cap: true\n            &#125;,\n            end: &#123;\n              taper: true,\n              easing: &quot;linear&quot;,\n              cap: false\n            &#125;\n          &#125;\n        &#125;\n    &#125;\n  &#125;;\n&#125;);\n\nawait ea.addElementsToView(false,true);\nelements.forEach((el)=&gt;ea.moveViewElementToZIndex(el.id,0));\nconst ids=ea.getElements().map(el=&gt;el.id);\nea.selectElementsInView(ea.getViewElements().filter(el=&gt;ids.contains(el.id)));\n\n","slug":"Organic Line","date":"2023-07-29T10:00:19.279Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"94dd5736dc50981b37c31780ed9dd77f","title":"Normalize Selected Arrows","content":"&#x2F;*\nThis script will reset the start and end positions of the selected arrows. The arrow will point to the center of the connected box and will have a gap of 8px from the box.\nTips: If you are drawing a flowchart, you can use Normalize Selected Arrows script to correct the position of the start and end points of the arrows, then use Elbow connectors script, and you will get the perfect connecting line!\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Gap&quot;]) &#123;\n    settings = &#123;\n      &quot;Gap&quot; : &#123;\n            value: 8,\n          description: &quot;The value of the gap between the connection line and the element, which must be greater than 0. If you want the connector to be next to the element, set it to 1.&quot;\n        &#125;\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nlet gapValue = settings[&quot;Gap&quot;].value;\n\nconst selectedIndividualArrows = ea.getMaximumGroups(ea.getViewSelectedElements())\n    .reduce((result, g) =&gt; [...result, ...g.filter(el =&gt; el.type === &#39;arrow&#39;)], []);\n\nconst allElements = ea.getViewElements();\nfor(const arrow of selectedIndividualArrows) &#123;\n    const startBindingEl = allElements.filter(el =&gt; el.id === (arrow.startBinding||&#123;&#125;).elementId)[0];\n    const endBindingEl = allElements.filter(el =&gt; el.id === (arrow.endBinding||&#123;&#125;).elementId)[0];\n\n    if(startBindingEl) &#123;\n        recalculateStartPointOfLine(arrow, startBindingEl, endBindingEl, gapValue);\n    &#125;\n    if(endBindingEl) &#123;\n        recalculateEndPointOfLine(arrow, endBindingEl, startBindingEl, gapValue);\n    &#125;\n&#125;\n\nea.copyViewElementsToEAforEditing(selectedIndividualArrows);\nawait ea.addElementsToView(false,false);\n\nfunction recalculateStartPointOfLine(line, el, elB, gapValue) &#123;\n    const aX = el.x + el.width/2;\n    const bX = (line.points.length &lt;=2 &amp;&amp; elB) ? elB.x + elB.width/2 : line.x + line.points[1][0];\n    const aY = el.y + el.height/2;\n    const bY = (line.points.length &lt;=2 &amp;&amp; elB) ? elB.y + elB.height/2 : line.y + line.points[1][1];\n\n    line.startBinding.gap = gapValue;\n    line.startBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.startBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[0] = [0, 0];\n        for(var i = 1; i&lt;line.points.length; i++) &#123;\n            line.points[i][0] -= intersectA[0][0] - line.x;\n            line.points[i][1] -= intersectA[0][1] - line.y;\n        &#125;\n        line.x = intersectA[0][0];\n        line.y = intersectA[0][1];\n    &#125;\n&#125;\n\nfunction recalculateEndPointOfLine(line, el, elB, gapValue) &#123;\n    const aX = el.x + el.width/2;\n    const bX = (line.points.length &lt;=2 &amp;&amp; elB) ? elB.x + elB.width/2 : line.x + line.points[line.points.length-2][0];\n    const aY = el.y + el.height/2;\n    const bY = (line.points.length &lt;=2 &amp;&amp; elB) ? elB.y + elB.height/2 : line.y + line.points[line.points.length-2][1];\n\n    line.endBinding.gap = gapValue;\n    line.endBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.endBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[line.points.length - 1] = [intersectA[0][0] - line.x, intersectA[0][1] - line.y];\n    &#125;\n&#125;\n\n","slug":"Normalize Selected Arrows","date":"2023-07-29T10:00:19.277Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"8fc5f303927e140b24df3a557a9ee147","title":"Modify background color opacity","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script changes the opacity of the background color of the selected boxes.\nThe default background color in Excalidraw is so dark that the text is hard to read. You can lighten the color a bit by setting transparency. And you can tweak the transparency over and over again until you’re happy with it.\nAlthough excalidraw has the opacity option in its native property Settings, it also changes the transparency of the border. Use this script to change only the opacity of the background color without affecting the border.\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Default opacity&quot;]) &#123;\n    settings = &#123;\n      &quot;Prompt for opacity?&quot;: true,\n      &quot;Default opacity&quot; : &#123;\n        value: 0.6,\n        description: &quot;Element&#39;s background color transparency&quot;\n      &#125;,\n      &quot;Remember last opacity?&quot;: false\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nlet opacityStr = settings[&quot;Default opacity&quot;].value.toString();\nconst rememberLastOpacity = settings[&quot;Remember last opacity?&quot;];\n\nif(settings[&quot;Prompt for opacity?&quot;]) &#123;\n    opacityStr = await utils.inputPrompt(&quot;Background color opacity?&quot;,&quot;number&quot;,opacityStr);\n&#125;\n\nconst alpha = parseFloat(opacityStr);\nif(isNaN(alpha)) &#123;\n  return;\n&#125;\nif(rememberLastOpacity) &#123;\n    settings[&quot;Default opacity&quot;].value = alpha;\n    ea.setScriptSettings(settings);\n&#125;\nconst elements=ea.getViewSelectedElements().filter((el)=&gt;[&quot;rectangle&quot;,&quot;ellipse&quot;,&quot;diamond&quot;,&quot;line&quot;,&quot;image&quot;].includes(el.type));\nea.copyViewElementsToEAforEditing(elements);\nea.getElements().forEach((el)=&gt;&#123;\n    const color = colorNameToHex(el.backgroundColor);\n    const rgbColor = /^#?([a-f\\d]&#123;2&#125;)([a-f\\d]&#123;2&#125;)([a-f\\d]&#123;2&#125;)$/i.exec(color);\n    if(rgbColor) &#123;\n        const r = parseInt(rgbColor[1], 16);\n        const g = parseInt(rgbColor[2], 16);\n        const b = parseInt(rgbColor[3], 16);\n        el.backgroundColor=`rgba($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;,$&#123;alpha&#125;)`;\n    &#125;\n    else &#123;\n        const rgbaColor = /^rgba\\((\\d+,\\d+,\\d+,)(\\d*\\.?\\d*)\\)$/i.exec(color);\n        if(rgbaColor) &#123;\n            el.backgroundColor=`rgba($&#123;rgbaColor[1]&#125;$&#123;alpha&#125;)`;\n        &#125;\n    &#125;\n&#125;);\nawait ea.addElementsToView(false, false);\n\nfunction colorNameToHex(color) &#123;\n  const colors = &#123;\n    &quot;aliceblue&quot;:&quot;#f0f8ff&quot;,\n    &quot;antiquewhite&quot;:&quot;#faebd7&quot;,\n    &quot;aqua&quot;:&quot;#00ffff&quot;,\n    &quot;aquamarine&quot;:&quot;#7fffd4&quot;,\n    &quot;azure&quot;:&quot;#f0ffff&quot;,\n    &quot;beige&quot;:&quot;#f5f5dc&quot;,\n    &quot;bisque&quot;:&quot;#ffe4c4&quot;,\n    &quot;black&quot;:&quot;#000000&quot;,\n    &quot;blanchedalmond&quot;:&quot;#ffebcd&quot;,\n    &quot;blue&quot;:&quot;#0000ff&quot;,\n    &quot;blueviolet&quot;:&quot;#8a2be2&quot;,\n    &quot;brown&quot;:&quot;#a52a2a&quot;,\n    &quot;burlywood&quot;:&quot;#deb887&quot;,\n    &quot;cadetblue&quot;:&quot;#5f9ea0&quot;,\n    &quot;chartreuse&quot;:&quot;#7fff00&quot;,\n    &quot;chocolate&quot;:&quot;#d2691e&quot;,\n    &quot;coral&quot;:&quot;#ff7f50&quot;,\n    &quot;cornflowerblue&quot;:&quot;#6495ed&quot;,\n    &quot;cornsilk&quot;:&quot;#fff8dc&quot;,\n    &quot;crimson&quot;:&quot;#dc143c&quot;,\n    &quot;cyan&quot;:&quot;#00ffff&quot;,\n    &quot;darkblue&quot;:&quot;#00008b&quot;,\n    &quot;darkcyan&quot;:&quot;#008b8b&quot;,\n    &quot;darkgoldenrod&quot;:&quot;#b8860b&quot;,\n    &quot;darkgray&quot;:&quot;#a9a9a9&quot;,\n    &quot;darkgreen&quot;:&quot;#006400&quot;,\n    &quot;darkkhaki&quot;:&quot;#bdb76b&quot;,\n    &quot;darkmagenta&quot;:&quot;#8b008b&quot;,\n    &quot;darkolivegreen&quot;:&quot;#556b2f&quot;,\n    &quot;darkorange&quot;:&quot;#ff8c00&quot;,\n    &quot;darkorchid&quot;:&quot;#9932cc&quot;,\n    &quot;darkred&quot;:&quot;#8b0000&quot;,\n    &quot;darksalmon&quot;:&quot;#e9967a&quot;,\n    &quot;darkseagreen&quot;:&quot;#8fbc8f&quot;,\n    &quot;darkslateblue&quot;:&quot;#483d8b&quot;,\n    &quot;darkslategray&quot;:&quot;#2f4f4f&quot;,\n    &quot;darkturquoise&quot;:&quot;#00ced1&quot;,\n    &quot;darkviolet&quot;:&quot;#9400d3&quot;,\n    &quot;deeppink&quot;:&quot;#ff1493&quot;,\n    &quot;deepskyblue&quot;:&quot;#00bfff&quot;,\n    &quot;dimgray&quot;:&quot;#696969&quot;,\n    &quot;dodgerblue&quot;:&quot;#1e90ff&quot;,\n    &quot;firebrick&quot;:&quot;#b22222&quot;,\n    &quot;floralwhite&quot;:&quot;#fffaf0&quot;,\n    &quot;forestgreen&quot;:&quot;#228b22&quot;,\n    &quot;fuchsia&quot;:&quot;#ff00ff&quot;,\n    &quot;gainsboro&quot;:&quot;#dcdcdc&quot;,\n    &quot;ghostwhite&quot;:&quot;#f8f8ff&quot;,\n    &quot;gold&quot;:&quot;#ffd700&quot;,\n    &quot;goldenrod&quot;:&quot;#daa520&quot;,\n    &quot;gray&quot;:&quot;#808080&quot;,\n    &quot;green&quot;:&quot;#008000&quot;,\n    &quot;greenyellow&quot;:&quot;#adff2f&quot;,\n    &quot;honeydew&quot;:&quot;#f0fff0&quot;,\n    &quot;hotpink&quot;:&quot;#ff69b4&quot;,\n    &quot;indianred &quot;:&quot;#cd5c5c&quot;,\n    &quot;indigo&quot;:&quot;#4b0082&quot;,\n    &quot;ivory&quot;:&quot;#fffff0&quot;,\n    &quot;khaki&quot;:&quot;#f0e68c&quot;,\n    &quot;lavender&quot;:&quot;#e6e6fa&quot;,\n    &quot;lavenderblush&quot;:&quot;#fff0f5&quot;,\n    &quot;lawngreen&quot;:&quot;#7cfc00&quot;,\n    &quot;lemonchiffon&quot;:&quot;#fffacd&quot;,\n    &quot;lightblue&quot;:&quot;#add8e6&quot;,\n    &quot;lightcoral&quot;:&quot;#f08080&quot;,\n    &quot;lightcyan&quot;:&quot;#e0ffff&quot;,\n    &quot;lightgoldenrodyellow&quot;:&quot;#fafad2&quot;,\n    &quot;lightgrey&quot;:&quot;#d3d3d3&quot;,\n    &quot;lightgreen&quot;:&quot;#90ee90&quot;,\n    &quot;lightpink&quot;:&quot;#ffb6c1&quot;,\n    &quot;lightsalmon&quot;:&quot;#ffa07a&quot;,\n    &quot;lightseagreen&quot;:&quot;#20b2aa&quot;,\n    &quot;lightskyblue&quot;:&quot;#87cefa&quot;,\n    &quot;lightslategray&quot;:&quot;#778899&quot;,\n    &quot;lightsteelblue&quot;:&quot;#b0c4de&quot;,\n    &quot;lightyellow&quot;:&quot;#ffffe0&quot;,\n    &quot;lime&quot;:&quot;#00ff00&quot;,\n    &quot;limegreen&quot;:&quot;#32cd32&quot;,\n    &quot;linen&quot;:&quot;#faf0e6&quot;,\n    &quot;magenta&quot;:&quot;#ff00ff&quot;,\n    &quot;maroon&quot;:&quot;#800000&quot;,\n    &quot;mediumaquamarine&quot;:&quot;#66cdaa&quot;,\n    &quot;mediumblue&quot;:&quot;#0000cd&quot;,\n    &quot;mediumorchid&quot;:&quot;#ba55d3&quot;,\n    &quot;mediumpurple&quot;:&quot;#9370d8&quot;,\n    &quot;mediumseagreen&quot;:&quot;#3cb371&quot;,\n    &quot;mediumslateblue&quot;:&quot;#7b68ee&quot;,\n    &quot;mediumspringgreen&quot;:&quot;#00fa9a&quot;,\n    &quot;mediumturquoise&quot;:&quot;#48d1cc&quot;,\n    &quot;mediumvioletred&quot;:&quot;#c71585&quot;,\n    &quot;midnightblue&quot;:&quot;#191970&quot;,\n    &quot;mintcream&quot;:&quot;#f5fffa&quot;,\n    &quot;mistyrose&quot;:&quot;#ffe4e1&quot;,\n    &quot;moccasin&quot;:&quot;#ffe4b5&quot;,\n    &quot;navajowhite&quot;:&quot;#ffdead&quot;,\n    &quot;navy&quot;:&quot;#000080&quot;,\n    &quot;oldlace&quot;:&quot;#fdf5e6&quot;,\n    &quot;olive&quot;:&quot;#808000&quot;,\n    &quot;olivedrab&quot;:&quot;#6b8e23&quot;,\n    &quot;orange&quot;:&quot;#ffa500&quot;,\n    &quot;orangered&quot;:&quot;#ff4500&quot;,\n    &quot;orchid&quot;:&quot;#da70d6&quot;,\n    &quot;palegoldenrod&quot;:&quot;#eee8aa&quot;,\n    &quot;palegreen&quot;:&quot;#98fb98&quot;,\n    &quot;paleturquoise&quot;:&quot;#afeeee&quot;,\n    &quot;palevioletred&quot;:&quot;#d87093&quot;,\n    &quot;papayawhip&quot;:&quot;#ffefd5&quot;,\n    &quot;peachpuff&quot;:&quot;#ffdab9&quot;,\n    &quot;peru&quot;:&quot;#cd853f&quot;,\n    &quot;pink&quot;:&quot;#ffc0cb&quot;,\n    &quot;plum&quot;:&quot;#dda0dd&quot;,\n    &quot;powderblue&quot;:&quot;#b0e0e6&quot;,\n    &quot;purple&quot;:&quot;#800080&quot;,\n    &quot;rebeccapurple&quot;:&quot;#663399&quot;,\n    &quot;red&quot;:&quot;#ff0000&quot;,\n    &quot;rosybrown&quot;:&quot;#bc8f8f&quot;,\n    &quot;royalblue&quot;:&quot;#4169e1&quot;,\n    &quot;saddlebrown&quot;:&quot;#8b4513&quot;,\n    &quot;salmon&quot;:&quot;#fa8072&quot;,\n    &quot;sandybrown&quot;:&quot;#f4a460&quot;,\n    &quot;seagreen&quot;:&quot;#2e8b57&quot;,\n    &quot;seashell&quot;:&quot;#fff5ee&quot;,\n    &quot;sienna&quot;:&quot;#a0522d&quot;,\n    &quot;silver&quot;:&quot;#c0c0c0&quot;,\n    &quot;skyblue&quot;:&quot;#87ceeb&quot;,\n    &quot;slateblue&quot;:&quot;#6a5acd&quot;,\n    &quot;slategray&quot;:&quot;#708090&quot;,\n    &quot;snow&quot;:&quot;#fffafa&quot;,\n    &quot;springgreen&quot;:&quot;#00ff7f&quot;,\n    &quot;steelblue&quot;:&quot;#4682b4&quot;,\n    &quot;tan&quot;:&quot;#d2b48c&quot;,\n    &quot;teal&quot;:&quot;#008080&quot;,\n    &quot;thistle&quot;:&quot;#d8bfd8&quot;,\n    &quot;tomato&quot;:&quot;#ff6347&quot;,\n    &quot;turquoise&quot;:&quot;#40e0d0&quot;,\n    &quot;violet&quot;:&quot;#ee82ee&quot;,\n    &quot;wheat&quot;:&quot;#f5deb3&quot;,\n    &quot;white&quot;:&quot;#ffffff&quot;,\n    &quot;whitesmoke&quot;:&quot;#f5f5f5&quot;,\n    &quot;yellow&quot;:&quot;#ffff00&quot;,\n    &quot;yellowgreen&quot;:&quot;#9acd32&quot;\n  &#125;;\n  if (typeof colors[color.toLowerCase()] != &#39;undefined&#39;)\n    return colors[color.toLowerCase()];\n  return color;\n&#125;\n\n","slug":"Modify background color opacity","date":"2023-07-29T10:00:19.275Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"a270c09cac3c70483286bc10905557fc","title":"Mindmap format","content":"&#x2F;*\nformat the left to right mind map\n\ntreeMind map is actually a tree, so you must have a root node. The script will determine the leftmost element of the selected element as the root element (node is excalidraw element, e.g. rectangle, diamond, ellipse, text, image, but it can’t be arrow, line, freedraw, group)\nThe element connecting node and node must be an arrow and  have the correct direction, e.g. parent node -&gt; children node\nsortThe order of nodes in the Y axis or vertical direction is determined by the creation time of the arrow connecting it\n\nSo if you want to readjust the order, you can delete arrows and reconnect them\nsettingScript provides options to adjust the style of mind map, The option is at the bottom of the option of the exalidraw plugin(e.g. Settings -&gt; Community plugins -&gt; Excalidraw -&gt; drag to bottom)\nproblem\nsince the start bingding and end bingding of the arrow are easily disconnected from the node, so if there are unformatted parts, please check the connection and use the script to reformat\n\n*/\n\nlet settings = ea.getScriptSettings();\n//set default values on first run\nif (!settings[&quot;MindMap Format&quot;]) &#123;\n  settings = &#123;\n    &quot;MindMap Format&quot;: &#123;\n      value: &quot;Excalidraw/MindMap Format&quot;,\n      description:\n        &quot;This is prepared for the namespace of MindMap Format and does not need to be modified&quot;,\n    &#125;,\n    &quot;default gap&quot;: &#123;\n      value: 10,\n      description: &quot;Interval size of element&quot;,\n    &#125;,\n    &quot;curve length&quot;: &#123;\n      value: 40,\n      description: &quot;The length of the curve part in the mind map line&quot;,\n    &#125;,\n    &quot;length between element and line&quot;: &#123;\n      value: 50,\n      description:\n        &quot;The distance between the tail of the connection and the connecting elements of the mind map&quot;,\n    &#125;,\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125;\n\nconst sceneElements = ea.getExcalidrawAPI().getSceneElements();\n\n// default X coordinate of the middle point of the arc\nconst defaultDotX = Number(settings[&quot;curve length&quot;].value);\n// The default length from the middle point of the arc on the X axis\nconst defaultLengthWithCenterDot = Number(\n  settings[&quot;length between element and line&quot;].value\n);\n// Initial trimming distance of the end point on the Y axis\nconst initAdjLength = 4;\n// default gap\nconst defaultGap = Number(settings[&quot;default gap&quot;].value);\n\nconst setCenter = (parent, line) =&gt; &#123;\n  // Focus and gap need the api calculation of excalidraw\n  // e.g. determineFocusDistance, but they are not available now\n  // so they are uniformly set to 0/1\n  line.startBinding.focus = 0;\n  line.startBinding.gap = 1;\n  line.endBinding.focus = 0;\n  line.endBinding.gap = 1;\n  line.x = parent.x + parent.width;\n  line.y = parent.y + parent.height / 2;\n&#125;;\n\n/**\n * set the middle point of curve\n * @param &#123;any&#125; lineEl the line element of excalidraw\n * @param &#123;number&#125; height height of dot on Y axis\n * @param &#123;number&#125; [ratio=1] ，coefficient of the initial trimming distance of the end point on the Y axis, default is 1\n */\nconst setTopCurveDotOnLine = (lineEl, height, ratio = 1) =&gt; &#123;\n  if (lineEl.points.length &lt; 3) &#123;\n    lineEl.points.splice(1, 0, [defaultDotX, lineEl.points[0][1] - height]);\n  &#125; else if (lineEl.points.length === 3) &#123;\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] - height];\n  &#125; else &#123;\n    lineEl.points.splice(2, lineEl.points.length - 3);\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] - height];\n  &#125;\n  lineEl.points[2][0] = lineEl.points[1][0] + defaultLengthWithCenterDot;\n  // adjust the curvature of the second line segment\n  lineEl.points[2][1] = lineEl.points[1][1] - initAdjLength * ratio * 0.8;\n&#125;;\n\nconst setMidCurveDotOnLine = (lineEl) =&gt; &#123;\n  if (lineEl.points.length &lt; 3) &#123;\n    lineEl.points.splice(1, 0, [defaultDotX, lineEl.points[0][1]]);\n  &#125; else if (lineEl.points.length === 3) &#123;\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1]];\n  &#125; else &#123;\n    lineEl.points.splice(2, lineEl.points.length - 3);\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1]];\n  &#125;\n  lineEl.points[2][0] = lineEl.points[1][0] + defaultLengthWithCenterDot;\n  lineEl.points[2][1] = lineEl.points[1][1];\n&#125;;\n\n/**\n * set the middle point of curve\n * @param &#123;any&#125; lineEl the line element of excalidraw\n * @param &#123;number&#125; height height of dot on Y axis\n * @param &#123;number&#125; [ratio=1] ，coefficient of the initial trimming distance of the end point on the Y axis, default is 1\n */\nconst setBottomCurveDotOnLine = (lineEl, height, ratio = 1) =&gt; &#123;\n  if (lineEl.points.length &lt; 3) &#123;\n    lineEl.points.splice(1, 0, [defaultDotX, lineEl.points[0][1] + height]);\n  &#125; else if (lineEl.points.length === 3) &#123;\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] + height];\n  &#125; else &#123;\n    lineEl.points.splice(2, lineEl.points.length - 3);\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] + height];\n  &#125;\n  lineEl.points[2][0] = lineEl.points[1][0] + defaultLengthWithCenterDot;\n  // adjust the curvature of the second line segment\n  lineEl.points[2][1] = lineEl.points[1][1] + initAdjLength * ratio * 0.8;\n&#125;;\n\nconst setTextXY = (rect, text) =&gt; &#123;\n  text.x = rect.x + (rect.width - text.width) / 2;\n  text.y = rect.y + (rect.height - text.height) / 2;\n&#125;;\n\nconst setChildrenXY = (parent, children, line, elementsMap) =&gt; &#123;\n  x = parent.x + parent.width + line.points[2][0];\n  y = parent.y + parent.height / 2 + line.points[2][1] - children.height / 2;\n  distX = children.x - x;\n  distY = children.y - y;\n\n  ea.getElementsInTheSameGroupWithElement(children, sceneElements).forEach((el) =&gt; &#123;\n    el.x = el.x - distX;\n    el.y = el.y - distY;\n  &#125;);\n\n  if (\n    [&quot;rectangle&quot;, &quot;diamond&quot;, &quot;ellipse&quot;].includes(children.type) &amp;&amp;\n    ![null, undefined].includes(children.boundElements)\n  ) &#123;\n    const textDesc = children.boundElements.filter(\n      (el) =&gt; el.type === &quot;text&quot;\n    )[0];\n    if (textDesc !== undefined) &#123;\n      const textEl = elementsMap.get(textDesc.id);\n      setTextXY(children, textEl);\n    &#125;\n  &#125;\n&#125;;\n\n/**\n * returns the height of the upper part of all child nodes\n * and the height of the lower part of all child nodes\n * @param &#123;Number[]&#125; childrenTotalHeightArr\n * @returns &#123;Number[]&#125; [topHeight, bottomHeight]\n */\nconst getNodeCurrentHeight = (childrenTotalHeightArr) =&gt; &#123;\n  if (childrenTotalHeightArr.length &lt;= 0) return [0, 0];\n  else if (childrenTotalHeightArr.length === 1)\n    return [childrenTotalHeightArr[0] / 2, childrenTotalHeightArr[0] / 2];\n  const heightArr = childrenTotalHeightArr;\n  let topHeight = 0,\n    bottomHeight = 0;\n  const isEven = heightArr.length % 2 === 0;\n  const mid = Math.floor(heightArr.length / 2);\n  const topI = mid - 1;\n  const bottomI = isEven ? mid : mid + 1;\n  topHeight = isEven ? 0 : heightArr[mid] / 2;\n  for (let i = topI; i &gt;= 0; i--) &#123;\n    topHeight += heightArr[i];\n  &#125;\n  bottomHeight = isEven ? 0 : heightArr[mid] / 2;\n  for (let i = bottomI; i &lt; heightArr.length; i++) &#123;\n    bottomHeight += heightArr[i];\n  &#125;\n  return [topHeight, bottomHeight];\n&#125;;\n\n/**\n * handle the height of each point in the single-level tree\n * @param &#123;Array&#125; lines\n * @param &#123;Map&#125; elementsMap\n * @param &#123;Boolean&#125; isEven\n * @param &#123;Number&#125; mid &#39;lines&#39; array midpoint index\n * @returns &#123;Array&#125; height array corresponding to &#39;lines&#39;\n */\nconst handleDotYValue = (lines, elementsMap, isEven, mid) =&gt; &#123;\n  const getTotalHeight = (line, elementsMap) =&gt; &#123;\n    return elementsMap.get(line.endBinding.elementId).totalHeight;\n  &#125;;\n  const getTopHeight = (line, elementsMap) =&gt; &#123;\n    return elementsMap.get(line.endBinding.elementId).topHeight;\n  &#125;;\n  const getBottomHeight = (line, elementsMap) =&gt; &#123;\n    return elementsMap.get(line.endBinding.elementId).bottomHeight;\n  &#125;;\n  const heightArr = new Array(lines.length).fill(0);\n  const upI = mid === 0 ? 0 : mid - 1;\n  const bottomI = isEven ? mid : mid + 1;\n  let initHeight = isEven ? 0 : getTopHeight(lines[mid], elementsMap);\n  for (let i = upI; i &gt;= 0; i--) &#123;\n    heightArr[i] = initHeight + getBottomHeight(lines[i], elementsMap);\n    initHeight += getTotalHeight(lines[i], elementsMap);\n  &#125;\n  initHeight = isEven ? 0 : getBottomHeight(lines[mid], elementsMap);\n  for (let i = bottomI; i &lt; lines.length; i++) &#123;\n    heightArr[i] = initHeight + getTopHeight(lines[i], elementsMap);\n    initHeight += getTotalHeight(lines[i], elementsMap);\n  &#125;\n  return heightArr;\n&#125;;\n\n/**\n * format single-level tree\n * @param &#123;any&#125; parent\n * @param &#123;Array&#125; lines\n * @param &#123;Map&#125; childrenDescMap\n * @param &#123;Map&#125; elementsMap\n */\nconst formatTree = (parent, lines, childrenDescMap, elementsMap) =&gt; &#123;\n  lines.forEach((item) =&gt; setCenter(parent, item));\n\n  const isEven = lines.length % 2 === 0;\n  const mid = Math.floor(lines.length / 2);\n  const heightArr = handleDotYValue(lines, childrenDescMap, isEven, mid);\n  lines.forEach((item, index) =&gt; &#123;\n    if (isEven) &#123;\n      if (index &lt; mid) setTopCurveDotOnLine(item, heightArr[index], index + 1);\n      else setBottomCurveDotOnLine(item, heightArr[index], index - mid + 1);\n    &#125; else &#123;\n      if (index &lt; mid) setTopCurveDotOnLine(item, heightArr[index], index + 1);\n      else if (index === mid) setMidCurveDotOnLine(item);\n      else setBottomCurveDotOnLine(item, heightArr[index], index - mid);\n    &#125;\n  &#125;);\n  lines.forEach((item) =&gt; &#123;\n    if (item.endBinding !== null) &#123;\n      setChildrenXY(\n        parent,\n        elementsMap.get(item.endBinding.elementId),\n        item,\n        elementsMap\n      );\n    &#125;\n  &#125;);\n&#125;;\n\nconst generateTree = (elements) =&gt; &#123;\n  const elIdMap = new Map([[elements[0].id, elements[0]]]);\n  let minXEl = elements[0];\n  for (let i = 1; i &lt; elements.length; i++) &#123;\n    elIdMap.set(elements[i].id, elements[i]);\n    if (\n      !(elements[i].type === &quot;arrow&quot; || elements[i].type === &quot;line&quot;) &amp;&amp;\n      elements[i].x &lt; minXEl.x\n    ) &#123;\n      minXEl = elements[i];\n    &#125;\n  &#125;\n  const root = &#123;\n    el: minXEl,\n    totalHeight: minXEl.height,\n    topHeight: 0,\n    bottomHeight: 0,\n    linkChildrensLines: [],\n    isLeafNode: false,\n    children: [],\n  &#125;;\n  const preIdSet = new Set(); // The id_set of Elements that is already in the tree, avoid a dead cycle\n  const dfsForTreeData = (root) =&gt; &#123;\n    if (preIdSet.has(root.el.id)) &#123;\n      return 0;\n    &#125;\n    preIdSet.add(root.el.id);\n    let lines = root.el.boundElements.filter(\n      (el) =&gt;\n        el.type === &quot;arrow&quot; &amp;&amp;\n        !preIdSet.has(el.id) &amp;&amp;\n        elIdMap.get(el.id)?.startBinding?.elementId === root.el.id\n    );\n    if (lines.length === 0) &#123;\n      root.isLeafNode = true;\n      root.totalHeight = root.el.height + 2 * defaultGap;\n      [root.topHeight, root.bottomHeight] = [\n        root.totalHeight / 2,\n        root.totalHeight / 2,\n      ];\n      return root.totalHeight;\n    &#125; else &#123;\n      lines = lines.map((elementDesc) =&gt; &#123;\n        preIdSet.add(elementDesc.id);\n        return elIdMap.get(elementDesc.id);\n      &#125;);\n    &#125;\n\n    const linkChildrensLines = [];\n    lines.forEach((el) =&gt; &#123;\n      const line = el;\n      if (\n        line &amp;&amp;\n        line.endBinding !== null &amp;&amp;\n        line.endBinding !== undefined &amp;&amp;\n        !preIdSet.has(elIdMap.get(line.endBinding.elementId).id)\n      ) &#123;\n        const children = elIdMap.get(line.endBinding.elementId);\n        linkChildrensLines.push(line);\n        root.children.push(&#123;\n          el: children,\n          totalHeight: 0,\n          topHeight: 0,\n          bottomHeight: 0,\n          linkChildrensLines: [],\n          isLeafNode: false,\n          children: [],\n        &#125;);\n      &#125;\n    &#125;);\n\n    let totalHeight = 0;\n    root.children.forEach((el) =&gt; (totalHeight += dfsForTreeData(el)));\n\n    root.linkChildrensLines = linkChildrensLines;\n    if (root.children.length === 0) &#123;\n      root.isLeafNode = true;\n      root.totalHeight = root.el.height + 2 * defaultGap;\n      [root.topHeight, root.bottomHeight] = [\n        root.totalHeight / 2,\n        root.totalHeight / 2,\n      ];\n    &#125; else if (root.children.length &gt; 0) &#123;\n      root.totalHeight = Math.max(root.el.height + 2 * defaultGap, totalHeight);\n      [root.topHeight, root.bottomHeight] = getNodeCurrentHeight(\n        root.children.map((item) =&gt; item.totalHeight)\n      );\n    &#125;\n\n    return totalHeight;\n  &#125;;\n  dfsForTreeData(root);\n  const dfsForFormat = (root) =&gt; &#123;\n    if (root.isLeafNode) return;\n    const childrenDescMap = new Map(\n      root.children.map((item) =&gt; [item.el.id, item])\n    );\n    formatTree(root.el, root.linkChildrensLines, childrenDescMap, elIdMap);\n    root.children.forEach((el) =&gt; dfsForFormat(el));\n  &#125;;\n  dfsForFormat(root);\n&#125;;\n\nconst elements = ea.getViewSelectedElements();\ngenerateTree(elements);\n\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n\n","slug":"Mindmap format","date":"2023-07-29T10:00:19.273Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"5e921ced045f3ba1eac86cf604483afc","title":"Mindmap connector","content":"&#x2F;*\n\nThis script creates mindmap like lines(only right and down side are available). The line will starts according to the creation time of the elements. So you may need to create the header element first.\n*/\nconst elements = ea.getViewSelectedElements();\nea.copyViewElementsToEAforEditing(elements);\ngroups = ea.getMaximumGroups(elements);\n\nels=[];\nelsx=[];\nelsy=[];\nfor (i = 0, len =groups.length; i &lt; len; i++) &#123;\n  els.push(ea.getLargestElement(groups[i]));\n  elsx.push(ea.getLargestElement(groups[i]).x);\n  elsy.push(ea.getLargestElement(groups[i]).y);\n&#125;\n//line style setting\nea.style.strokeColor = els[0].strokeColor;\nea.style.strokeWidth = els[0].strokeWidth;\nea.style.strokeStyle = els[0].strokeStyle;\nea.style.strokeSharpness = els[0].strokeSharpness;\n//all min max x y\nlet maxy = Math.max.apply(null, elsy);\nlet indexmaxy=elsy.indexOf(maxy);\nlet miny = Math.min.apply(null, elsy);\nlet indexminy = elsy.indexOf(miny);\nlet maxx = Math.max.apply(null, elsx);\nlet indexmaxx = elsx.indexOf(maxx);\nlet minx = Math.min.apply(null, elsx);\nlet indexminx = elsx.indexOf(minx);\n//child max min x y\nlet gmaxy = Math.max.apply(null, elsy.slice(1));\nlet gindexmaxy=elsy.indexOf(gmaxy);\nlet gminy = Math.min.apply(null, elsy.slice(1));\nlet gindexminy = elsy.indexOf(gminy);\nlet gmaxx = Math.max.apply(null, elsx.slice(1));\nlet gindexmaxx = elsx.indexOf(gmaxx);\nlet gminx = Math.min.apply(null, elsx.slice(1));\nlet gindexminx = elsx.indexOf(gminx);\nlet s=0;//Set line direction down as default \nif (indexminx==0 &amp;&amp;  els[0].x + els[0].width&lt;=gminx) &#123;\n  s=1; \n&#125;\nelse if (indexminy == 0) &#123;\n  s=0;\n&#125;\nvar length_left;\nif(els[0].x + els[0].width * 2&lt;=gminx)&#123;length_left=els[0].x + els[0].width * 1.5;&#125;\nelse &#123;length_left=(els[0].x + els[0].width+gminx)/2;&#125;\n\nvar length_down;\nif(els[0].y + els[0].height* 2.5&lt;=gminy)&#123;length_down=els[0].y + els[0].height * 2;&#125;\nelse &#123;length_down=(els[0].y + els[0].height+gminy)/2;&#125;\nif(s) &#123;\n  ea.addLine(\n    [[length_left,\n    maxy + els[indexmaxy].height / 2],\n    [length_left,\n    miny + els[indexminy].height / 2]]\n  );\n  for (i = 1, len = groups.length; i &lt; len; i++) &#123;\n    ea.addLine(\n      [[els[i].x,\n      els[i].y + els[i].height/2],\n      [length_left,\n      els[i].y + els[i].height/2]]\n    );\n  &#125;\n  ea.addArrow(\n    [[els[0].x+els[0].width,\n    els[0].y + els[0].height / 2],\n    [length_left,\n    els[0].y + els[0].height / 2]],\n    &#123;\n      startArrowHead: &quot;none&quot;,\n      endArrowHead: &quot;dot&quot;\n    &#125;\n  )\n&#125;\n\nelse &#123;\n  ea.addLine(\n    [[maxx + els[indexmaxx].width / 2,\n    length_down],\n    [minx + els[indexminx].width / 2,\n    length_down]]\n  );\n  for (i = 1, len = groups.length; i &lt; len; i++) &#123;\n    ea.addLine(\n      [[els[i].x + els[i].width / 2,\n      els[i].y],\n      [els[i].x + els[i].width / 2,\n      length_down]]\n    );\n  &#125;\n  ea.addArrow(\n    [[els[0].x + els[0].width / 2,\n    els[0].y + els[0].height],\n    [els[0].x + els[0].width / 2,\n    length_down]],\n    &#123;\n      startArrowHead: &quot;none&quot;,\n      endArrowHead: &quot;dot&quot;\n    &#125;\n  );\n&#125;\n\nawait ea.addElementsToView(false,false,true);\n\n","slug":"Mindmap connector","date":"2023-07-29T10:00:19.271Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"61e0f09d98ca2d807aab8a4dcb946f8a","title":"Lighten background color","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script lightens the background color of the selected element by 2% at a time. \nYou can use this script several times until you are satisfied. It is recommended to set a shortcut key for this script so that you can quickly try to DARKEN and LIGHTEN the color effect.\nIn contrast to the Modify background color opacity script, the advantage is that the background color of the element is not affected by the canvas color, and the color value does not appear in a strange rgba() form.\nThe color conversion method was copied from color-convert.\n*/\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.7.19&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nlet settings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Step size&quot;]) &#123;\n  settings = &#123;\n    &quot;Step size&quot; : &#123;\n      value: 2,\n      description: &quot;Step size in percentage for making the color lighter&quot;\n    &#125;\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125;\n\nconst step = settings[&quot;Step size&quot;].value;\n\nconst elements = ea\n  .getViewSelectedElements()\n  .filter((el) =&gt;\n    [&quot;rectangle&quot;, &quot;ellipse&quot;, &quot;diamond&quot;, &quot;image&quot;, &quot;line&quot;, &quot;freedraw&quot;].includes(el.type)\n  );\nea.copyViewElementsToEAforEditing(elements);\nfor (const el of ea.getElements()) &#123;\n  const color = ea.colorNameToHex(el.backgroundColor);\n  const cm = ea.getCM(color);\n  if (cm) &#123;\n    const lighter = cm.lighterBy(step);\n    if(Math.ceil(lighter.lightness)&lt;100) el.backgroundColor = lighter.stringHSL();\n  &#125;\n&#125;\nawait ea.addElementsToView(false, false);\n\n","slug":"Lighten background color","date":"2023-07-29T10:00:19.268Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"516fdfc977076be85ee0c36a27a100d1","title":"Invert colors","content":"&#x2F;*\nThe script inverts the colors on the canvas including the color palette in Element Properties.\n*/\nconst defaultColorPalette = &#123; // https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/1.6.8\n  elementStroke:[&quot;#000000&quot;,&quot;#343a40&quot;,&quot;#495057&quot;,&quot;#c92a2a&quot;,&quot;#a61e4d&quot;,&quot;#862e9c&quot;,&quot;#5f3dc4&quot;,&quot;#364fc7&quot;,&quot;#1864ab&quot;,&quot;#0b7285&quot;,&quot;#087f5b&quot;,&quot;#2b8a3e&quot;,&quot;#5c940d&quot;,&quot;#e67700&quot;,&quot;#d9480f&quot;],\n  elementBackground:[&quot;transparent&quot;,&quot;#ced4da&quot;,&quot;#868e96&quot;,&quot;#fa5252&quot;,&quot;#e64980&quot;,&quot;#be4bdb&quot;,&quot;#7950f2&quot;,&quot;#4c6ef5&quot;,&quot;#228be6&quot;,&quot;#15aabf&quot;,&quot;#12b886&quot;,&quot;#40c057&quot;,&quot;#82c91e&quot;,&quot;#fab005&quot;,&quot;#fd7e14&quot;],\n  canvasBackground:[&quot;#ffffff&quot;,&quot;#f8f9fa&quot;,&quot;#f1f3f5&quot;,&quot;#fff5f5&quot;,&quot;#fff0f6&quot;,&quot;#f8f0fc&quot;,&quot;#f3f0ff&quot;,&quot;#edf2ff&quot;,&quot;#e7f5ff&quot;,&quot;#e3fafc&quot;,&quot;#e6fcf5&quot;,&quot;#ebfbee&quot;,&quot;#f4fce3&quot;,&quot;#fff9db&quot;,&quot;#fff4e6&quot;]\n&#125;;\n\nconst api = ea.getExcalidrawAPI();\nconst st = api.getAppState();\n\nlet colorPalette = st.colorPalette ?? defaultColorPalette;\nif (Object.entries(colorPalette).length === 0) colorPalette = defaultColorPalette;\nif(!colorPalette.elementStroke || Object.entries(colorPalette.elementStroke).length === 0) colorPalette.elementStroke = defaultColorPalette.elementStroke;\nif(!colorPalette.elementBackground || Object.entries(colorPalette.elementBackground).length === 0) colorPalette.elementBackground = defaultColorPalette.elementBackground;\nif(!colorPalette.canvasBackground || Object.entries(colorPalette.canvasBackground).length === 0) colorPalette.canvasBackground = defaultColorPalette.canvasBackground;\n\nconst invertColor = (color) =&gt; &#123;\n    if(color.toLowerCase()===&quot;transparent&quot;) return color;\n    const cm = ea.getCM(color);\n    const lightness = cm.lightness;\n    cm.lightnessTo(Math.abs(lightness-100));\n    switch (cm.format) &#123;\n        case &quot;hsl&quot;: return cm.stringHSL();\n        case &quot;rgb&quot;: return cm.stringRGB();\n        case &quot;hsv&quot;: return cm.stringHSV();\n        default: return cm.stringHEX(&#123;alpha: false&#125;);\n    &#125;\n&#125;\n\nconst invertPaletteColors = (palette) =&gt; Object.keys(palette).forEach(key =&gt; palette[key] = invertColor(palette[key]));\nObject.keys(colorPalette).forEach(key =&gt; invertPaletteColors(colorPalette[key]));\n\nea.copyViewElementsToEAforEditing(ea.getViewElements());\nea.getElements().forEach(el=&gt;&#123;\n    el.strokeColor = invertColor(el.strokeColor);\n    el.backgroundColor = invertColor(el.backgroundColor);\n&#125;);\n\nea.viewUpdateScene(&#123;\n  appState:&#123;\n      colorPalette,\n      viewBackgroundColor: invertColor(st.viewBackgroundColor),\n      currentItemStrokeColor: invertColor(st.currentItemStrokeColor),\n      currentItemBackgroundColor: invertColor(st.currentItemBackgroundColor)\n  &#125;,\n  elements: ea.getElements()\n&#125;);\n\n","slug":"Invert colors","date":"2023-07-29T10:00:19.266Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"4c444fb32f94eb6704b12be2b19ebd15","title":"Hardware Eraser Support","content":"&#x2F;*Adds support for pen inversion, a.k.a. the hardware eraser on the back of your pen.\nSimply use the eraser on a supported pen, and it will erase. Your previous tool will be restored when the eraser leaves the screen.(Tested with a surface pen, but should work with all windows ink devices, and probably others)\nNote: This script will stay active until the Obsidian window is closed.\nCompatible with my Auto Draw for Pen script\n*/\n\n(function() &#123;\n    &#39;use strict&#39;;\n\n    let activated\n    let revert\n    \n    function handlePointer(e) &#123;\n        const activeTool = ea.getExcalidrawAPI().getAppState().activeTool;\n        const isEraser = e.pointerType === &#39;pen&#39; &amp;&amp; e.buttons &amp; 32\n        function setActiveTool(t) &#123;\n            ea.getExcalidrawAPI().setActiveTool(t)\n        &#125;\n        if (!activated &amp;&amp; isEraser) &#123;\n            //Store previous tool\n            const btns = document.querySelectorAll(&#39;.App-toolbar input.ToolIcon_type_radio&#39;)\n            for (const i in btns) &#123;\n                if (btns[i]?.checked) &#123;\n                    revert = btns[i]\n                &#125;\n            &#125;\n            revert = activeTool\n\n            // Activate eraser tool\n            setActiveTool(&#123;type: &quot;eraser&quot;&#125;)\n            activated = true\n\n            // Force Excalidraw to recognize this the same as pen tip\n            // https://github.com/excalidraw/excalidraw/blob/4a9fac2d1e5c4fac334201ef53c6f5d2b5f6f9f5/src/components/App.tsx#L2945-L2951\n            Object.defineProperty(e, &#39;button&#39;, &#123;\n                value: 0,\n                writable: false\n            &#125;);\n        &#125;\n        // Keep on eraser!\n        if (isEraser &amp;&amp; activated) &#123;\n            setActiveTool(&#123;type: &quot;eraser&quot;&#125;)\n        &#125;\n        if (activated &amp;&amp; !isEraser) &#123;\n            // Revert tool on release\n            // revert.click()\n            setActiveTool(revert)\n            activated = false\n            \n            // Force delete &quot;limbo&quot; elements\n            // This doesn&#39;t happen on the web app\n            // It&#39;s a bug caused by switching to eraser during a stroke\n            ea.setView(&quot;active&quot;);\n            var del = []\n            for (const i in ea.getViewElements()) &#123;\n                const element = ea.getViewElements()[i];\n                if (element.opacity === 20) &#123;\n                    del.push(element)\n                &#125;\n            &#125;\n            ea.deleteViewElements(del)\n            setActiveTool(revert)\n        &#125;\n    &#125;\n    \n    window.addEventListener(&#39;pointerdown&#39;, handlePointer, &#123; capture: true &#125;)\n    window.addEventListener(&#39;pointermove&#39;, handlePointer, &#123; capture: true &#125;)\n&#125;)();\n\n","slug":"Hardware Eraser Support","date":"2023-07-29T10:00:19.264Z","categories_index":"","tags_index":"L2945","author_index":"Devmacy"},{"id":"324235689ce5c9f4bfe08baf6efd1e65","title":"Grid Selected Images","content":"&#x2F;*\nThis script arranges selected images into compact grid view, removing gaps in-between, resizing when necessary and breaking into multiple rows&#x2F;columns.\n*/\n\ntry &#123;\n  let els = ea.getViewSelectedElements().filter(el =&gt; el.type == &#39;image&#39;);\n\n  new Notice(els.length);\n\n  if (els.length == 0) throw new Error(&#39;No image elements selected&#39;);\n\n  const bounds = ea.getBoundingBox(els);\n  const &#123; topX, topY, width, height &#125; = bounds;\n  \n  els.sort((a, b) =&gt; a.x + a.y &lt; b.x + b.y);\n\n  const areaAvailable = width * height;\n\n  let elWidth = els[0].width;\n  let elHeight = els[0].height;\n\n  if (elWidth * elHeight &gt; areaAvailable) &#123;\n    while (elWidth * elHeight &gt; areaAvailable) &#123;\n      elWidth /= 1.1;\n      elHeight /= 1.1;\n    &#125;  \n  &#125; else if (elWidth * elHeight &lt; areaAvailable) &#123;\n    while (elWidth * elHeight &gt; areaAvailable) &#123;\n      elWidth *= 1.1;\n      elHeight *= 1.1;\n    &#125;\n  &#125;\n\n  const rows = (width - elWidth) / elWidth;\n  \n  let row = 0, column = 0;\n  for (const element of els) &#123;    \n    element.x = topX + (elWidth * row);\n    element.y = topY + (elHeight * column);\n    \n    if (element.width &gt; elWidth) &#123;\n      while (element.width &gt;= elWidth) &#123;\n        element.width /= 1.1;\n        element.height /= 1.1;\n      &#125;  \n    &#125; else if (element.width &lt; elWidth) &#123;\n      while (element.width &lt;= elWidth) &#123;\n        element.width *= 1.1;\n        element.height *= 1.1;  \n      &#125;\n    &#125;\n\n    row++;\n    if (row &gt; rows) &#123;\n      row = 0;\n      column++;\n    &#125;\n  &#125;\n\n  ea.addElementsToView(false, true, true);\n&#125; catch (err) &#123;\n  _ = new Notice(err.toString())\n&#125;\n\n","slug":"Grid Selected Images","date":"2023-07-29T10:00:19.262Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"93f25646f3e0482094b2f4de6d2309a0","title":"Folder Note Core - Make Current Drawing a Folder","content":"&#x2F;*This script adds the Folder Note Core: Make current document folder note function to Excalidraw drawings. Running this script will convert the active Excalidraw drawing into a folder note. If you already have embedded images in your drawing, those attachments will not be moved when the folder note is created. You need to take care of those attachments separately, or convert the drawing to a folder note prior to adding the attachments. The script requires the Folder Note Core plugin. \nconst FNC = app.plugins.plugins[&#39;folder-note-core&#39;]?.resolver;\nconst file = ea.targetView.file;\nif(!FNC) return;\nif(!FNC.createFolderForNoteCheck(file)) return;\nFNC.createFolderForNote(file);\n\n","slug":"Folder Note Core - Make Current Drawing a Folder","date":"2023-07-29T10:00:19.260Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"0258d5b0ed5cc2cef372602c3d6c3aa4","title":"Fixed vertical distance","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThe script arranges the selected elements vertically with a fixed spacing.\nWhen we create an architecture diagram or mind map, we often need to arrange a large number of elements in a fixed spacing. Fixed spacing and Fixed vertical Distance scripts can save us a lot of time.\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Default spacing&quot;]) &#123;\n    settings = &#123;\n      &quot;Prompt for spacing?&quot;: true,\n      &quot;Default spacing&quot; : &#123;\n        value: 10,\n        description: &quot;Fixed vertical spacing between elements&quot;\n      &#125;,\n      &quot;Remember last spacing?&quot;: false\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nlet spacingStr = settings[&quot;Default spacing&quot;].value.toString();\nconst rememberLastSpacing = settings[&quot;Remember last spacing?&quot;];\n\nif(settings[&quot;Prompt for spacing?&quot;]) &#123;\n    spacingStr = await utils.inputPrompt(&quot;spacing?&quot;,&quot;number&quot;,spacingStr);\n&#125;\n\nconst spacing = parseInt(spacingStr);\nif(isNaN(spacing)) &#123;\n  return;\n&#125;\nif(rememberLastSpacing) &#123;\n    settings[&quot;Default spacing&quot;].value = spacing;\n    ea.setScriptSettings(settings);\n&#125;\nconst elements=ea.getViewSelectedElements(); \nconst topGroups = ea.getMaximumGroups(elements)\n    .filter(els =&gt; !(els.length === 1 &amp;&amp; els[0].type ===&quot;arrow&quot;)) // ignore individual arrows\n    .filter(els =&gt; !(els.length === 1 &amp;&amp; (els[0].containerId))); // ignore text in stickynote\n    \nconst groups = topGroups.sort((lha,rha) =&gt; lha[0].y - rha[0].y);\n\nfor(var i=0; i&lt;groups.length; i++) &#123;\n    if(i &gt; 0) &#123;\n        const preGroup = groups[i-1];\n        const curGroup = groups[i];\n\n        const preBottom = Math.max(...preGroup.map(el =&gt; el.y + el.height));\n        const curTop = Math.min(...curGroup.map(el =&gt; el.y));\n        const distance = curTop -  preBottom - spacing;\n\n        for(const curEl of curGroup) &#123;\n            curEl.y = curEl.y - distance;\n        &#125;\n    &#125;\n&#125;\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n\n","slug":"Fixed vertical distance","date":"2023-07-29T10:00:19.257Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"d160413eb0d290aa3759d43b095a5f21","title":"Fixed vertical distance between centers","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script arranges the selected elements vertically with a fixed center spacing.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Default distance&quot;]) &#123;\n    settings = &#123;\n      &quot;Prompt for distance?&quot;: true,\n      &quot;Default distance&quot; : &#123;\n        value: 10,\n        description: &quot;Fixed vertical distance between centers&quot;\n      &#125;,\n      &quot;Remember last distance?&quot;: false\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nlet distanceStr = settings[&quot;Default distance&quot;].value.toString();\nconst rememberLastDistance = settings[&quot;Remember last distance?&quot;];\n\nif(settings[&quot;Prompt for distance?&quot;]) &#123;\n    distanceStr = await utils.inputPrompt(&quot;distance?&quot;,&quot;number&quot;,distanceStr);\n&#125;\n\nconst distance = parseInt(distanceStr);\nif(isNaN(distance)) &#123;\n  return;\n&#125;\nif(rememberLastDistance) &#123;\n    settings[&quot;Default distance&quot;].value = distance;\n    ea.setScriptSettings(settings);\n&#125;\nconst elements=ea.getViewSelectedElements(); \nconst topGroups = ea.getMaximumGroups(elements)\n    .filter(els =&gt; !(els.length === 1 &amp;&amp; els[0].type ===&quot;arrow&quot;)) // ignore individual arrows\n    .filter(els =&gt; !(els.length === 1 &amp;&amp; (els[0].containerId))); // ignore text in stickynote\n\nconst groups = topGroups.sort((lha,rha) =&gt; lha[0].y - rha[0].y);\n\nfor(var i=0; i&lt;groups.length; i++) &#123;\n    if(i &gt; 0) &#123;\n        const preGroup = groups[i-1];\n        const curGroup = groups[i];\n\n        const preTop = Math.min(...preGroup.map(el =&gt; el.y));\n        const preBottom = Math.max(...preGroup.map(el =&gt; el.y + el.height));\n        const preCenter = preTop + (preBottom - preTop) / 2;\n        const curTop = Math.min(...curGroup.map(el =&gt; el.y));\n        const curBottom = Math.max(...curGroup.map(el =&gt; el.y + el.height));\n        const curCenter = curTop + (curBottom - curTop) / 2;\n        const distanceBetweenCenters = curCenter - preCenter - distance;\n\n        for(const curEl of curGroup) &#123;\n            curEl.y = curEl.y - distanceBetweenCenters;\n        &#125;\n    &#125;\n&#125;\n\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n\n","slug":"Fixed vertical distance between centers","date":"2023-07-29T10:00:19.254Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"567ae1c3b3ca221e66b212e6a524e8af","title":"Fixed spacing","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThe script arranges the selected elements horizontally with a fixed spacing.\nWhen we create an architecture diagram or mind map, we often need to arrange a large number of elements in a fixed spacing. Fixed spacing and Fixed vertical Distance scripts can save us a lot of time.\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Default spacing&quot;]) &#123;\n    settings = &#123;\n      &quot;Prompt for spacing?&quot;: true,\n      &quot;Default spacing&quot; : &#123;\n        value: 10,\n        description: &quot;Fixed horizontal spacing between elements&quot;\n      &#125;,\n      &quot;Remember last spacing?&quot;: false\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nlet spacingStr = settings[&quot;Default spacing&quot;].value.toString();\nconst rememberLastSpacing = settings[&quot;Remember last spacing?&quot;];\n\nif(settings[&quot;Prompt for spacing?&quot;]) &#123;\n    spacingStr = await utils.inputPrompt(&quot;spacing?&quot;,&quot;number&quot;,spacingStr);\n&#125;\n\nconst spacing = parseInt(spacingStr);\nif(isNaN(spacing)) &#123;\n  return;\n&#125;\nif(rememberLastSpacing) &#123;\n    settings[&quot;Default spacing&quot;].value = spacing;\n    ea.setScriptSettings(settings);\n&#125;\nconst elements=ea.getViewSelectedElements();\nconst topGroups = ea.getMaximumGroups(elements)\n    .filter(els =&gt; !(els.length === 1 &amp;&amp; els[0].type ===&quot;arrow&quot;)) // ignore individual arrows\n    .filter(els =&gt; !(els.length === 1 &amp;&amp; (els[0].containerId))); // ignore text in stickynote\n    \nconst groups = topGroups.sort((lha,rha) =&gt; lha[0].x - rha[0].x);\n\nfor(var i=0; i&lt;groups.length; i++) &#123;\n    if(i &gt; 0) &#123;\n        const preGroup = groups[i-1];\n        const curGroup = groups[i];\n\n        const preRight = Math.max(...preGroup.map(el =&gt; el.x + el.width));\n        const curLeft = Math.min(...curGroup.map(el =&gt; el.x));\n        const distance = curLeft -  preRight - spacing;\n\n        for(const curEl of curGroup) &#123;\n            curEl.x = curEl.x - distance;\n        &#125;\n    &#125;\n&#125;\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n\n","slug":"Fixed spacing","date":"2023-07-29T10:00:19.251Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"4909e6c65bbb40816d77d5c41608779a","title":"Fixed inner distance","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script arranges selected elements and groups with a fixed inner distance.\nTips: You can use the Box Selected Elements and Dimensions scripts to create rectangles of the desired size, then use the Change shape of selected elements script to convert the rectangles to ellipses, and then use the Fixed inner distance script regains a desired inner distance.\nInspiration: #394\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Default distance&quot;]) &#123;\n    settings = &#123;\n      &quot;Prompt for distance?&quot;: true,\n      &quot;Default distance&quot; : &#123;\n        value: 10,\n        description: &quot;Fixed horizontal distance between centers&quot;\n      &#125;,\n      &quot;Remember last distance?&quot;: false\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nlet distanceStr = settings[&quot;Default distance&quot;].value.toString();\nconst rememberLastDistance = settings[&quot;Remember last distance?&quot;];\n\nif(settings[&quot;Prompt for distance?&quot;]) &#123;\n    distanceStr = await utils.inputPrompt(&quot;distance?&quot;,&quot;number&quot;,distanceStr);\n&#125;\n\nconst borders = [&quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;];\nconst fromBorder = await utils.suggester(borders, borders, &quot;from border?&quot;);\n\nif(!fromBorder) &#123;\n  return;\n&#125;\n\nconst distance = parseInt(distanceStr);\nif(isNaN(distance)) &#123;\n  return;\n&#125;\nif(rememberLastDistance) &#123;\n    settings[&quot;Default distance&quot;].value = distance;\n    ea.setScriptSettings(settings);\n&#125;\nconst elements=ea.getViewSelectedElements();\nconst topGroups = ea.getMaximumGroups(elements)\n    .filter(els =&gt; !(els.length === 1 &amp;&amp; els[0].type ===&quot;arrow&quot;)) // ignore individual arrows\n    .filter(els =&gt; !(els.length === 1 &amp;&amp; (els[0].containerId))); // ignore text in stickynote\n\nif(topGroups.length &lt;= 1) &#123;\n  new Notice(&quot;At least 2 or more elements or groups should be selected.&quot;);\n  return;\n&#125;\n\nif(fromBorder === &#39;top&#39;) &#123;\n  const groups = topGroups.sort((lha,rha) =&gt; Math.min(...lha.map(t =&gt; t.y)) - Math.min(...rha.map(t =&gt; t.y)));\n  const firstGroupTop = Math.min(...groups[0].map(el =&gt; el.y));\n  \n  for(var i=0; i&lt;groups.length; i++) &#123;\n    if(i &gt; 0) &#123;\n        const curGroup = groups[i];\n        const moveDistance = distance * i;\n        for(const curEl of curGroup) &#123;\n          curEl.y = firstGroupTop + moveDistance;\n        &#125;\n    &#125;\n  &#125;   \n&#125;\nelse if(fromBorder === &#39;bottom&#39;) &#123;\n  const groups = topGroups.sort((lha,rha) =&gt; Math.min(...lha.map(t =&gt; t.y + t.height)) - Math.min(...rha.map(t =&gt; t.y + t.height))).reverse();\n  const firstGroupBottom = Math.max(...groups[0].map(el =&gt; el.y + el.height));\n  \n  for(var i=0; i&lt;groups.length; i++) &#123;\n    if(i &gt; 0) &#123;\n        const curGroup = groups[i];\n        const moveDistance = distance * i;\n        for(const curEl of curGroup) &#123;\n           curEl.y = firstGroupBottom - moveDistance - curEl.height;\n        &#125;\n    &#125;\n  &#125;   \n&#125;\nelse if(fromBorder === &#39;left&#39;) &#123;\n  const groups = topGroups.sort((lha,rha) =&gt; Math.min(...lha.map(t =&gt; t.x)) - Math.min(...rha.map(t =&gt; t.x)));\n  const firstGroupLeft = Math.min(...groups[0].map(el =&gt; el.x));\n  \n  for(var i=0; i&lt;groups.length; i++) &#123;\n    if(i &gt; 0) &#123;\n        const curGroup = groups[i];\n        const moveDistance = distance * i;\n        for(const curEl of curGroup) &#123;\n          curEl.x = firstGroupLeft + moveDistance;\n        &#125;\n    &#125;\n  &#125;   \n&#125;\nelse if(fromBorder === &#39;right&#39;) &#123;\n  const groups = topGroups.sort((lha,rha) =&gt; Math.min(...lha.map(t =&gt; t.x + t.width)) - Math.min(...rha.map(t =&gt; t.x + t.width))).reverse();\n  const firstGroupRight = Math.max(...groups[0].map(el =&gt; el.x + el.width));\n  \n  for(var i=0; i&lt;groups.length; i++) &#123;\n    if(i &gt; 0) &#123;\n        const curGroup = groups[i];\n        const moveDistance = distance * i;\n        for(const curEl of curGroup) &#123;\n           curEl.x = firstGroupRight - moveDistance - curEl.width;\n        &#125;\n    &#125;\n  &#125;   \n&#125;\n\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n\n","slug":"Fixed inner distance","date":"2023-07-29T10:00:19.249Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"c07aef96b0da563fb4e8cd01e51ff50c","title":"Fixed horizontal distance between centers","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script arranges the selected elements horizontally with a fixed center spacing.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Default distance&quot;]) &#123;\n    settings = &#123;\n      &quot;Prompt for distance?&quot;: true,\n      &quot;Default distance&quot; : &#123;\n        value: 10,\n        description: &quot;Fixed horizontal distance between centers&quot;\n      &#125;,\n      &quot;Remember last distance?&quot;: false\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nlet distanceStr = settings[&quot;Default distance&quot;].value.toString();\nconst rememberLastDistance = settings[&quot;Remember last distance?&quot;];\n\nif(settings[&quot;Prompt for distance?&quot;]) &#123;\n    distanceStr = await utils.inputPrompt(&quot;distance?&quot;,&quot;number&quot;,distanceStr);\n&#125;\n\nconst distance = parseInt(distanceStr);\nif(isNaN(distance)) &#123;\n  return;\n&#125;\nif(rememberLastDistance) &#123;\n    settings[&quot;Default distance&quot;].value = distance;\n    ea.setScriptSettings(settings);\n&#125;\nconst elements=ea.getViewSelectedElements();\nconst topGroups = ea.getMaximumGroups(elements)\n    .filter(els =&gt; !(els.length === 1 &amp;&amp; els[0].type ===&quot;arrow&quot;)) // ignore individual arrows\n    .filter(els =&gt; !(els.length === 1 &amp;&amp; (els[0].containerId))); // ignore text in stickynote\n    \nconst groups = topGroups.sort((lha,rha) =&gt; lha[0].x - rha[0].x);\n\nfor(var i=0; i&lt;groups.length; i++) &#123;\n    if(i &gt; 0) &#123;\n        const preGroup = groups[i-1];\n        const curGroup = groups[i];\n\n        const preLeft = Math.min(...preGroup.map(el =&gt; el.x));\n        const preRight = Math.max(...preGroup.map(el =&gt; el.x + el.width));\n        const preCenter = preLeft + (preRight - preLeft) / 2;\n        const curLeft = Math.min(...curGroup.map(el =&gt; el.x));\n        const curRight = Math.max(...curGroup.map(el =&gt; el.x + el.width));\n        const curCenter = curLeft + (curRight - curLeft) / 2;\n        const distanceBetweenCenters = curCenter -  preCenter - distance;\n\n        for(const curEl of curGroup) &#123;\n            curEl.x = curEl.x - distanceBetweenCenters;\n        &#125;\n    &#125;\n&#125;\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n\n","slug":"Fixed horizontal distance between centers","date":"2023-07-29T10:00:19.247Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"aa20de198c42e0389715b5676ed68a33","title":"Expand rectangles vertically","content":"&#x2F;*\n\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script expands the height of the selected rectangles until they are all the same height.\n*/\n\nconst elements = ea.getViewSelectedElements();\nconst topGroups = ea.getMaximumGroups(elements);\nconst allLines = ea.getViewElements().filter(el =&gt; el.type === &#39;arrow&#39; || el.type === &#39;line&#39;);\nconst allIndividualArrows = ea.getMaximumGroups(ea.getViewElements())\n    .reduce((result, group) =&gt; (group.length === 1 &amp;&amp; (group[0].type === &#39;arrow&#39; || group[0].type === &#39;line&#39;)) ? \n            [...result, group[0]] : result, []);\n\nconst groupHeights = topGroups\n  .map((g) =&gt; &#123;\n    if(g.length === 1 &amp;&amp; (g[0].type === &#39;arrow&#39; || g[0].type === &#39;line&#39;)) &#123;\n      // ignore individual lines\n      return &#123; minTop: 0, maxBottom: 0 &#125;;\n    &#125;\n    return g.reduce(\n      (pre, cur, i) =&gt; &#123;\n        if (i === 0) &#123;\n          return &#123;\n            minTop: cur.y,\n            maxBottom: cur.y + cur.height,\n            index: i,\n          &#125;;\n        &#125; else &#123;\n          return &#123;\n            minTop: cur.y &lt; pre.minTop ? cur.y : pre.minTop,\n            maxBottom:\n              cur.y + cur.height &gt; pre.maxBottom\n                ? cur.y + cur.height\n                : pre.maxBottom,\n            index: i,\n          &#125;;\n        &#125;\n      &#125;,\n      &#123; minTop: 0, maxBottom: 0 &#125;\n    );\n  &#125;)\n  .map((r) =&gt; &#123;\n    r.height = r.maxBottom - r.minTop;\n    return r;\n  &#125;);\n\nconst maxGroupHeight = Math.max(...groupHeights.map((g) =&gt; g.height));\n\nfor (var i = 0; i &lt; topGroups.length; i++) &#123;\n  const rects = topGroups[i]\n    .filter((el) =&gt; el.type === &quot;rectangle&quot;)\n    .sort((lha, rha) =&gt; lha.y - rha.y);\n    \n  const groupWidth = groupHeights[i].height;\n  if (groupWidth &lt; maxGroupHeight) &#123;\n    const distance = maxGroupHeight - groupWidth;\n    const perRectDistance = distance / rects.length;\n    for (var j = 0; j &lt; rects.length; j++) &#123;\n      const rect = rects[j];\n      rect.y = rect.y + perRectDistance * j;\n      rect.height += perRectDistance;\n\n      // recalculate the position of the points\n      const startBindingLines = allIndividualArrows.filter(el =&gt; (el.startBinding||&#123;&#125;).elementId === rect.id);\n         for(startBindingLine of startBindingLines) &#123;\n             recalculateStartPointOfLine(startBindingLine, rect);\n         &#125;\n     \n         const endBindingLines = allIndividualArrows.filter(el =&gt; (el.endBinding||&#123;&#125;).elementId === rect.id);\n         for(endBindingLine of endBindingLines) &#123;\n             recalculateEndPointOfLine(endBindingLine, rect);\n         &#125;\n    &#125;\n  &#125;\n&#125;\n\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n\nfunction recalculateStartPointOfLine(line, el) &#123;\n    const aX = el.x + el.width/2;\n    const bX = line.x + line.points[1][0];\n    const aY = el.y + el.height/2;\n    const bY = line.y + line.points[1][1];\n\n    line.startBinding.gap = 8;\n    line.startBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.startBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[0] = [0, 0];\n        for(var i = 1; i&lt;line.points.length; i++) &#123;\n            line.points[i][0] -= intersectA[0][0] - line.x;\n            line.points[i][1] -= intersectA[0][1] - line.y;\n        &#125;\n        line.x = intersectA[0][0];\n        line.y = intersectA[0][1];\n    &#125;\n&#125;\n\nfunction recalculateEndPointOfLine(line, el) &#123;\n    const aX = el.x + el.width/2;\n    const bX = line.x + line.points[line.points.length-2][0];\n    const aY = el.y + el.height/2;\n    const bY = line.y + line.points[line.points.length-2][1];\n\n    line.endBinding.gap = 8;\n    line.endBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.endBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[line.points.length - 1] = [intersectA[0][0] - line.x, intersectA[0][1] - line.y];\n    &#125;\n&#125;\n\n","slug":"Expand rectangles vertically","date":"2023-07-29T10:00:19.245Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"5ca1a57b4a16def73a8a03cc90761396","title":"Expand rectangles vertically keep text centered","content":"&#x2F;*\n\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script expands the height of the selected rectangles until they are all the same height and keep the text centered.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\n\nconst elements = ea.getViewSelectedElements();\nconst topGroups = ea.getMaximumGroups(elements);\nconst allIndividualArrows = ea.getMaximumGroups(ea.getViewElements())\n    .reduce((result, group) =&gt; (group.length === 1 &amp;&amp; (group[0].type === &#39;arrow&#39; || group[0].type === &#39;line&#39;)) ? \n            [...result, group[0]] : result, []);\n\nconst groupHeights = topGroups\n  .map((g) =&gt; &#123;\n    if(g.length === 1 &amp;&amp; (g[0].type === &#39;arrow&#39; || g[0].type === &#39;line&#39;)) &#123;\n      // ignore individual lines\n      return &#123; minTop: 0, maxBottom: 0 &#125;;\n    &#125;\n    return g.reduce(\n      (pre, cur, i) =&gt; &#123;\n        if (i === 0) &#123;\n          return &#123;\n            minTop: cur.y,\n            maxBottom: cur.y + cur.height,\n            index: i,\n          &#125;;\n        &#125; else &#123;\n          return &#123;\n            minTop: cur.y &lt; pre.minTop ? cur.y : pre.minTop,\n            maxBottom:\n              cur.y + cur.height &gt; pre.maxBottom\n                ? cur.y + cur.height\n                : pre.maxBottom,\n            index: i,\n          &#125;;\n        &#125;\n      &#125;,\n      &#123; minTop: 0, maxBottom: 0 &#125;\n    );\n  &#125;)\n  .map((r) =&gt; &#123;\n    r.height = r.maxBottom - r.minTop;\n    return r;\n  &#125;);\n\nconst maxGroupHeight = Math.max(...groupHeights.map((g) =&gt; g.height));\n\nfor (var i = 0; i &lt; topGroups.length; i++) &#123;\n  const rects = topGroups[i]\n    .filter((el) =&gt; el.type === &quot;rectangle&quot;)\n    .sort((lha, rha) =&gt; lha.y - rha.y);\n  const texts = topGroups[i]\n    .filter((el) =&gt; el.type === &quot;text&quot;)\n    .sort((lha, rha) =&gt; lha.y - rha.y);\n  const groupWith = groupHeights[i].height;\n  if (groupWith &lt; maxGroupHeight) &#123;\n    const distance = maxGroupHeight - groupWith;\n    const perRectDistance = distance / rects.length;\n    const textsWithRectIndex = [];\n    for (var j = 0; j &lt; rects.length; j++) &#123;\n      const rect = rects[j];\n      const rectLeft = rect.x;\n      const rectTop = rect.y;\n      const rectRight = rect.x + rect.width;\n      const rectBottom = rect.y + rect.height;\n\n      const textsWithRect = texts.filter(text =&gt; text.x &gt;= rectLeft &amp;&amp; text.x &lt;= rectRight\n        &amp;&amp; text.y &gt;= rectTop &amp;&amp; text.y &lt;= rectBottom);\n\n      textsWithRectIndex[j] = textsWithRect;\n    &#125;\n    for (var j = 0; j &lt; rects.length; j++) &#123;\n      const rect = rects[j];\n      rect.y = rect.y + perRectDistance * j - perRectDistance / 2;\n      rect.height += perRectDistance;\n\n      const textsWithRect = textsWithRectIndex[j];\n      \n      if(textsWithRect) &#123;\n        for(const text of textsWithRect) &#123;\n          text.y = text.y + perRectDistance * j;\n        &#125;\n      &#125;\n\n      // recalculate the position of the points\n      const startBindingLines = allIndividualArrows.filter(el =&gt; (el.startBinding||&#123;&#125;).elementId === rect.id);\n         for(startBindingLine of startBindingLines) &#123;\n             recalculateStartPointOfLine(startBindingLine, rect);\n         &#125;\n     \n         const endBindingLines = allIndividualArrows.filter(el =&gt; (el.endBinding||&#123;&#125;).elementId === rect.id);\n         for(endBindingLine of endBindingLines) &#123;\n             recalculateEndPointOfLine(endBindingLine, rect);\n         &#125;\n    &#125;\n  &#125;\n&#125;\n\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n\nfunction recalculateStartPointOfLine(line, el) &#123;\n    const aX = el.x + el.width/2;\n    const bX = line.x + line.points[1][0];\n    const aY = el.y + el.height/2;\n    const bY = line.y + line.points[1][1];\n\n    line.startBinding.gap = 8;\n    line.startBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.startBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[0] = [0, 0];\n        for(var i = 1; i&lt;line.points.length; i++) &#123;\n            line.points[i][0] -= intersectA[0][0] - line.x;\n            line.points[i][1] -= intersectA[0][1] - line.y;\n        &#125;\n        line.x = intersectA[0][0];\n        line.y = intersectA[0][1];\n    &#125;\n&#125;\n\nfunction recalculateEndPointOfLine(line, el) &#123;\n    const aX = el.x + el.width/2;\n    const bX = line.x + line.points[line.points.length-2][0];\n    const aY = el.y + el.height/2;\n    const bY = line.y + line.points[line.points.length-2][1];\n\n    line.endBinding.gap = 8;\n    line.endBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.endBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[line.points.length - 1] = [intersectA[0][0] - line.x, intersectA[0][1] - line.y];\n    &#125;\n&#125;\n\n","slug":"Expand rectangles vertically keep text centered","date":"2023-07-29T10:00:19.243Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"ef1414d6c8c88e321fce206638187e24","title":"Expand rectangles horizontally","content":"&#x2F;*\n\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script expands the width of the selected rectangles until they are all the same width.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\n\nconst elements = ea.getViewSelectedElements();\nconst topGroups = ea.getMaximumGroups(elements);\nconst allIndividualArrows = ea.getMaximumGroups(ea.getViewElements())\n    .reduce((result, group) =&gt; (group.length === 1 &amp;&amp; (group[0].type === &#39;arrow&#39; || group[0].type === &#39;line&#39;)) ? \n            [...result, group[0]] : result, []);\n\nconst groupWidths = topGroups\n  .map((g) =&gt; &#123;\n    if(g.length === 1 &amp;&amp; (g[0].type === &#39;arrow&#39; || g[0].type === &#39;line&#39;)) &#123;\n      // ignore individual lines\n      return &#123; minLeft: 0, maxRight: 0 &#125;;\n    &#125;\n    return g.reduce(\n      (pre, cur, i) =&gt; &#123;\n        if (i === 0) &#123;\n          return &#123;\n            minLeft: cur.x,\n            maxRight: cur.x + cur.width,\n            index: i,\n          &#125;;\n        &#125; else &#123;\n          return &#123;\n            minLeft: cur.x &lt; pre.minLeft ? cur.x : pre.minLeft,\n            maxRight:\n              cur.x + cur.width &gt; pre.maxRight\n                ? cur.x + cur.width\n                : pre.maxRight,\n            index: i,\n          &#125;;\n        &#125;\n      &#125;,\n      &#123; minLeft: 0, maxRight: 0 &#125;\n    );\n  &#125;)\n  .map((r) =&gt; &#123;\n    r.width = r.maxRight - r.minLeft;\n    return r;\n  &#125;);\n\nconst maxGroupWidth = Math.max(...groupWidths.map((g) =&gt; g.width));\n\nfor (var i = 0; i &lt; topGroups.length; i++) &#123;\n  const rects = topGroups[i]\n    .filter((el) =&gt; el.type === &quot;rectangle&quot;)\n    .sort((lha, rha) =&gt; lha.x - rha.x);\n  \n  const groupWith = groupWidths[i].width;\n  if (groupWith &lt; maxGroupWidth) &#123;\n    const distance = maxGroupWidth - groupWith;\n    const perRectDistance = distance / rects.length;\n    for (var j = 0; j &lt; rects.length; j++) &#123;\n      const rect = rects[j];\n      rect.x = rect.x + perRectDistance * j;\n      rect.width += perRectDistance;\n\n      // recalculate the position of the points\n      const startBindingLines = allIndividualArrows.filter(el =&gt; (el.startBinding||&#123;&#125;).elementId === rect.id);\n         for(startBindingLine of startBindingLines) &#123;\n             recalculateStartPointOfLine(startBindingLine, rect);\n         &#125;\n     \n         const endBindingLines = allIndividualArrows.filter(el =&gt; (el.endBinding||&#123;&#125;).elementId === rect.id);\n         for(endBindingLine of endBindingLines) &#123;\n             recalculateEndPointOfLine(endBindingLine, rect);\n         &#125;\n    &#125;\n  &#125;\n&#125;\n\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n\nfunction recalculateStartPointOfLine(line, el) &#123;\n    const aX = el.x + el.width/2;\n    const bX = line.x + line.points[1][0];\n    const aY = el.y + el.height/2;\n    const bY = line.y + line.points[1][1];\n\n    line.startBinding.gap = 8;\n    line.startBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.startBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[0] = [0, 0];\n        for(var i = 1; i&lt;line.points.length; i++) &#123;\n            line.points[i][0] -= intersectA[0][0] - line.x;\n            line.points[i][1] -= intersectA[0][1] - line.y;\n        &#125;\n        line.x = intersectA[0][0];\n        line.y = intersectA[0][1];\n    &#125;\n&#125;\n\nfunction recalculateEndPointOfLine(line, el) &#123;\n    const aX = el.x + el.width/2;\n    const bX = line.x + line.points[line.points.length-2][0];\n    const aY = el.y + el.height/2;\n    const bY = line.y + line.points[line.points.length-2][1];\n\n    line.endBinding.gap = 8;\n    line.endBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.endBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[line.points.length - 1] = [intersectA[0][0] - line.x, intersectA[0][1] - line.y];\n    &#125;\n&#125;\n\n","slug":"Expand rectangles horizontally","date":"2023-07-29T10:00:19.241Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"8a56f73b00ef50469e40d7f3c1e8a217","title":"Expand rectangles horizontally keep text centered","content":"&#x2F;*\n\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script expands the width of the selected rectangles until they are all the same width and keep the text centered.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\n\nconst elements = ea.getViewSelectedElements();\nconst topGroups = ea.getMaximumGroups(elements);\nconst allIndividualArrows = ea.getMaximumGroups(ea.getViewElements())\n    .reduce((result, group) =&gt; (group.length === 1 &amp;&amp; (group[0].type === &#39;arrow&#39;)) ? \n                [...result, group[0]] : result, []);\n\nconst groupWidths = topGroups\n  .map((g) =&gt; &#123;\n    if(g.length === 1 &amp;&amp; (g[0].type === &#39;arrow&#39; || g[0].type === &#39;line&#39;)) &#123;\n      // ignore individual lines\n      return &#123; minLeft: 0, maxRight: 0 &#125;;\n    &#125;\n    return g.reduce(\n      (pre, cur, i) =&gt; &#123;\n        if (i === 0) &#123;\n          return &#123;\n            minLeft: cur.x,\n            maxRight: cur.x + cur.width,\n            index: i,\n          &#125;;\n        &#125; else &#123;\n          return &#123;\n            minLeft: cur.x &lt; pre.minLeft ? cur.x : pre.minLeft,\n            maxRight:\n              cur.x + cur.width &gt; pre.maxRight\n                ? cur.x + cur.width\n                : pre.maxRight,\n            index: i,\n          &#125;;\n        &#125;\n      &#125;,\n      &#123; minLeft: 0, maxRight: 0 &#125;\n    );\n  &#125;)\n  .map((r) =&gt; &#123;\n    r.width = r.maxRight - r.minLeft;\n    return r;\n  &#125;);\n\nconst maxGroupWidth = Math.max(...groupWidths.map((g) =&gt; g.width));\n\nfor (var i = 0; i &lt; topGroups.length; i++) &#123;\n  const rects = topGroups[i]\n    .filter((el) =&gt; el.type === &quot;rectangle&quot;)\n    .sort((lha, rha) =&gt; lha.x - rha.x);\n  const texts = topGroups[i]\n    .filter((el) =&gt; el.type === &quot;text&quot;)\n    .sort((lha, rha) =&gt; lha.x - rha.x);\n  const groupWith = groupWidths[i].width;\n  if (groupWith &lt; maxGroupWidth) &#123;\n    const distance = maxGroupWidth - groupWith;\n    const perRectDistance = distance / rects.length;\n    const textsWithRectIndex = [];\n    for (var j = 0; j &lt; rects.length; j++) &#123;\n      const rect = rects[j];\n      const rectLeft = rect.x;\n      const rectTop = rect.y;\n      const rectRight = rect.x + rect.width;\n      const rectBottom = rect.y + rect.height;\n\n      const textsWithRect = texts.filter(text =&gt; text.x &gt;= rectLeft &amp;&amp; text.x &lt;= rectRight\n        &amp;&amp; text.y &gt;= rectTop &amp;&amp; text.y &lt;= rectBottom);\n\n      textsWithRectIndex[j] = textsWithRect;\n    &#125;\n    for (var j = 0; j &lt; rects.length; j++) &#123;\n      const rect = rects[j];\n      rect.x = rect.x + perRectDistance * j - perRectDistance / 2;\n      rect.width += perRectDistance;\n      \n      const textsWithRect = textsWithRectIndex[j];\n\n      if(textsWithRect) &#123;\n        for(const text of textsWithRect) &#123;\n          text.x = text.x + perRectDistance * j;\n        &#125;\n      &#125;\n\n      // recalculate the position of the points\n      const startBindingLines = allIndividualArrows.filter(el =&gt; (el.startBinding||&#123;&#125;).elementId === rect.id);\n         for(startBindingLine of startBindingLines) &#123;\n             recalculateStartPointOfLine(startBindingLine, rect);\n         &#125;\n     \n         const endBindingLines = allIndividualArrows.filter(el =&gt; (el.endBinding||&#123;&#125;).elementId === rect.id);\n         for(endBindingLine of endBindingLines) &#123;\n             recalculateEndPointOfLine(endBindingLine, rect);\n         &#125;\n    &#125;\n  &#125;\n&#125;\n\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n\nfunction recalculateStartPointOfLine(line, el) &#123;\n    const aX = el.x + el.width/2;\n    const bX = line.x + line.points[1][0];\n    const aY = el.y + el.height/2;\n    const bY = line.y + line.points[1][1];\n\n    line.startBinding.gap = 8;\n    line.startBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.startBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[0] = [0, 0];\n        for(var i = 1; i&lt;line.points.length; i++) &#123;\n            line.points[i][0] -= intersectA[0][0] - line.x;\n            line.points[i][1] -= intersectA[0][1] - line.y;\n        &#125;\n        line.x = intersectA[0][0];\n        line.y = intersectA[0][1];\n    &#125;\n&#125;\n\nfunction recalculateEndPointOfLine(line, el) &#123;\n    const aX = el.x + el.width/2;\n    const bX = line.x + line.points[line.points.length-2][0];\n    const aY = el.y + el.height/2;\n    const bY = line.y + line.points[line.points.length-2][1];\n\n    line.endBinding.gap = 8;\n    line.endBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.endBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[line.points.length - 1] = [intersectA[0][0] - line.x, intersectA[0][1] - line.y];\n    &#125;\n&#125;\n\n","slug":"Expand rectangles horizontally keep text centered","date":"2023-07-29T10:00:19.239Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"c2e4cdaa95668ecfa2fabc06a928a39e","title":"Excalidraw Collaboration Frame","content":"&#x2F;*Creates a new Excalidraw.com collaboration room and places the link to the room on the clipboard.\nconst room = Array.from(window.crypto.getRandomValues(new Uint8Array(10))).map((byte) =&gt; `0$&#123;byte.toString(16)&#125;`.slice(-2)).join(&quot;&quot;);\nconst key = (await window.crypto.subtle.exportKey(&quot;jwk&quot;,await window.crypto.subtle.generateKey(&#123;name:&quot;AES-GCM&quot;,length:128&#125;,true,[&quot;encrypt&quot;, &quot;decrypt&quot;]))).k;\nconst link = `https://excalidraw.com/#room=$&#123;room&#125;,$&#123;key&#125;`;\n\nea.addIFrame(0,0,800,600,link);\nea.addElementsToView(true,true);\n\nwindow.navigator.clipboard.writeText(link);\nnew Notice(&quot;The collaboration room link is available on the clipboard.&quot;,4000);\n\n","slug":"Excalidraw Collaboration Frame","date":"2023-07-29T10:00:19.237Z","categories_index":"","tags_index":"room","author_index":"Devmacy"},{"id":"a181e17af2228b7c5da994f8052e8e2d","title":"Ellipse Selected Elements","content":"&#x2F;*\nThis script will add an encapsulating ellipse around the currently selected elements in Excalidraw.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Default padding&quot;]) &#123;\n    settings = &#123;\n        &quot;Prompt for padding?&quot;: true,\n      &quot;Default padding&quot; : &#123;\n            value: 10,\n          description: &quot;Padding between the bounding box of the selected elements, and the ellipse the script creates&quot;\n        &#125;\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nlet padding = settings[&quot;Default padding&quot;].value;\n\nif(settings[&quot;Prompt for padding?&quot;]) &#123;\n    padding = parseInt (await utils.inputPrompt(&quot;padding?&quot;,&quot;number&quot;,padding.toString()));\n&#125;\n\nif(isNaN(padding)) &#123;\n  new Notice(&quot;The padding value provided is not a number&quot;);\n  return;\n&#125;\nelements = ea.getViewSelectedElements();\nconst box = ea.getBoundingBox(elements);\ncolor = ea\n        .getExcalidrawAPI()\n        .getAppState()\n        .currentItemStrokeColor;\n//uncomment for random color:\n//color = &#39;#&#39;+(Math.random()*0xFFFFFF&lt;&lt;0).toString(16).padStart(6,&quot;0&quot;);\nea.style.strokeColor = color;\n\nconst ellipseWidth = box.width/Math.sqrt(2);\nconst ellipseHeight = box.height/Math.sqrt(2);\n\nconst topX = box.topX - (ellipseWidth - box.width/2);\nconst topY = box.topY - (ellipseHeight - box.height/2);\nid = ea.addEllipse(\n    topX - padding,\n    topY - padding,\n    2*ellipseWidth + 2*padding,\n    2*ellipseHeight + 2*padding\n);\nea.copyViewElementsToEAforEditing(elements);\nea.addToGroup([id].concat(elements.map((el)=&gt;el.id)));\nea.addElementsToView(false,false);\n\n","slug":"Ellipse Selected Elements","date":"2023-07-29T10:00:19.235Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"13ea30ebd17055cb9b81ab0b3e2c7a26","title":"Elbow connectors","content":"&#x2F;*\n\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script converts the selected connectors to elbows.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nconst selectedCenterConnectPoints = await utils.suggester(\n    [&#39;Yes&#39;, &#39;No&#39;],\n    [true, false],\n    &quot;Center connect points?&quot;\n  );\nconst centerConnectPoints = selectedCenterConnectPoints??false;\n\nconst allElements = ea.getViewElements();\nconst elements = ea.getViewSelectedElements();\n\nconst lines = elements.filter((el)=&gt;el.type===&quot;arrow&quot; || el.type===&quot;line&quot;);\n\nfor (const line of lines) &#123;\n  if (line.points.length &gt;= 3) &#123;\n    if(centerConnectPoints) &#123;\n      const startBindingEl = allElements.filter(el =&gt; el.id === (line.startBinding||&#123;&#125;).elementId)[0];\n        const endBindingEl = allElements.filter(el =&gt; el.id === (line.endBinding||&#123;&#125;).elementId)[0];\n\n      if(startBindingEl) &#123;\n        const startPointX = line.x +line.points[0][0];\n        if(startPointX &gt;= startBindingEl.x &amp;&amp; startPointX &lt;= startBindingEl.x + startBindingEl.width) &#123;\n          line.points[0][0] = startBindingEl.x + startBindingEl.width / 2 - line.x;\n        &#125;\n\n        const startPointY = line.y +line.points[0][1];\n        if(startPointY &gt;= startBindingEl.y &amp;&amp; startPointY &lt;= startBindingEl.y + startBindingEl.height) &#123;\n          line.points[0][1] = startBindingEl.y + startBindingEl.height / 2 - line.y;\n        &#125;\n      &#125;\n\n      if(endBindingEl) &#123;\n        const startPointX = line.x +line.points[line.points.length-1][0];\n        if(startPointX &gt;= endBindingEl.x &amp;&amp; startPointX &lt;= endBindingEl.x + endBindingEl.width) &#123;\n          line.points[line.points.length-1][0] = endBindingEl.x + endBindingEl.width / 2 - line.x;\n        &#125;\n\n        const startPointY = line.y +line.points[line.points.length-1][1];\n        if(startPointY &gt;= endBindingEl.y &amp;&amp; startPointY &lt;= endBindingEl.y + endBindingEl.height) &#123;\n          line.points[line.points.length-1][1] = endBindingEl.y + endBindingEl.height / 2 - line.y;\n        &#125;\n      &#125;\n    &#125;\n    \n    for (var i = 0; i &lt; line.points.length - 2; i++) &#123;\n      var p1;\n      var p3;\n      if (line.points[i][0] &lt; line.points[i + 2][0]) &#123;\n        p1 = line.points[i];\n        p3 = line.points[i+2];\n      &#125; else &#123;\n        p1 = line.points[i + 2];\n        p3 = line.points[i];\n      &#125;\n      const p2 = line.points[i + 1];\n\n      if (p1[0] === p3[0]) &#123;\n        continue;\n      &#125;\n\n      const k = (p3[1] - p1[1]) / (p3[0] - p1[0]);\n      const b = p1[1] - k * p1[0];\n\n      y0 = k * p2[0] + b;\n      const up = p2[1] &lt; y0;\n\n      if ((k &gt; 0 &amp;&amp; !up) || (k &lt; 0 &amp;&amp; up)) &#123;\n        p2[0] = p1[0];\n        p2[1] = p3[1];\n      &#125; else &#123;\n        p2[0] = p3[0];\n        p2[1] = p1[1];\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\nea.copyViewElementsToEAforEditing(lines);\nawait ea.addElementsToView(false,false);\n\n","slug":"Elbow connectors","date":"2023-07-29T10:00:19.233Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"bfb83d2abca559002f1f33b5507b19ba","title":"Deconstruct selected elements into new drawing","content":"&#x2F;*\nSelect some elements in the scene. The script will take these elements and move them into a new Excalidraw file, and open that file. The selected elements will also be replaced in your original drawing with the embedded Excalidraw file (the one that was just created). You will be prompted for the file name of the new deconstructed image. The script is useful if you want to break a larger drawing into smaller reusable parts that you want to reference in multiple drawings.\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.7.29&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nconst els = ea.getViewSelectedElements();\nif (els.length === 0) &#123;\n  new Notice(&quot;You must select elements first&quot;)\n  return;\n&#125;\n\nconst bb = ea.getBoundingBox(els);\nea.copyViewElementsToEAforEditing(els);\n\nea.getElements().filter(el=&gt;el.type===&quot;image&quot;).forEach(el=&gt;&#123;\n    const img = ea.targetView.excalidrawData.getFile(el.fileId);\n    const path = (img?.linkParts?.original)??(img?.file?.path);\n    if(img &amp;&amp; path) &#123;\n        ea.imagesDict[el.fileId] = &#123;\n          mimeType: img.mimeType,\n          id: el.fileId,\n          dataURL: img.img,\n          created: img.mtime,\n          file: path,\n          hasSVGwithBitmap: img.isSVGwithBitmap,\n          latex: null,\n        &#125;;\n        return;\n    &#125;\n    const equation = ea.targetView.excalidrawData.getEquation(el.fileId);\n    eqImg = ea.targetView.getScene()?.files[el.fileId]\n    if(equation &amp;&amp; eqImg) &#123;\n          ea.imagesDict[el.fileId] = &#123;\n          mimeType: eqImg.mimeType,\n          id: el.fileId,\n          dataURL: eqImg.dataURL,\n          created: eqImg.created,\n          file: null,\n          hasSVGwithBitmap: null,\n          latex: equation.latex,\n        &#125;;\n        return;\n    &#125;\n&#125;);\n\nlet folder = ea.targetView.file.path;\nfolder = folder.lastIndexOf(&quot;/&quot;)===-1?&quot;&quot;:folder.substring(0,folder.lastIndexOf(&quot;/&quot;))+&quot;/&quot;;\nconst fname = await utils.inputPrompt(&quot;Filename for new file&quot;,&quot;Filename&quot;,&quot;&quot;);\nconst template = app.metadataCache.getFirstLinkpathDest(ea.plugin.settings.templateFilePath,&quot;&quot;);\n\nconst newPath = await ea.create (&#123;\n  filename: fname + &quot;.md&quot;,\n  foldername: folder,\n  templatePath: template?.path,\n  onNewPane: true\n&#125;);\n\nsetTimeout(async ()=&gt;&#123;\n  const file = app.metadataCache.getFirstLinkpathDest(newPath,&quot;&quot;)\n  ea.deleteViewElements(els);\n  ea.clear();\n  await ea.addImage(bb.topX,bb.topY,file,false);\n  await ea.addElementsToView(false, true, true);\n  ea.getExcalidrawAPI().history.clear(); //to avoid undo/redo messing up the decomposition\n&#125;,1000);\n\n","slug":"Deconstruct selected elements into new drawing","date":"2023-07-29T10:00:19.231Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"a15dff4ffc3433ec8c52c4869839aa7a","title":"Darken background color","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script darkens the background color of the selected element by 2% at a time. \nYou can use this script several times until you are satisfied. It is recommended to set a shortcut key for this script so that you can quickly try to DARKEN and LIGHTEN the color effect.\nIn contrast to the Modify background color opacity script, the advantage is that the background color of the element is not affected by the canvas color, and the color value does not appear in a strange rgba() form.\nThe color conversion method was copied from color-convert.\n*/\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.7.19&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nlet settings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Step size&quot;]) &#123;\n  settings = &#123;\n    &quot;Step size&quot; : &#123;\n      value: 2,\n      description: &quot;Step size in percentage for making the color darker&quot;\n    &#125;\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125;\n\nconst step = settings[&quot;Step size&quot;].value;\n\nconst elements = ea\n  .getViewSelectedElements()\n  .filter((el) =&gt;\n    [&quot;rectangle&quot;, &quot;ellipse&quot;, &quot;diamond&quot;, &quot;image&quot;, &quot;line&quot;, &quot;freedraw&quot;].includes(el.type)\n  );\nea.copyViewElementsToEAforEditing(elements);\nfor (const el of ea.getElements()) &#123;\n  const color = ea.colorNameToHex(el.backgroundColor);\n  const cm = ea.getCM(color);\n  if (cm) &#123;\n      const darker = cm.darkerBy(step);\n      if(Math.floor(darker.lightness)&gt;0) el.backgroundColor = darker.stringHSL();\n  &#125;\n&#125;\nawait ea.addElementsToView(false, false);\n\n","slug":"Darken background color","date":"2023-07-29T10:00:19.228Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"d40a96ec4b895f8656f14f2d105895c7","title":"Create new markdown file and embed into active drawing","content":"&#x2F;*\n\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThe script will prompt you for a filename, then create a new markdown document with the file name provided, open the new markdown document in an adjacent pane, and embed the markdown document into the active Excalidraw drawing.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nlet folder = ea.targetView.file.path;\nfolder = folder.lastIndexOf(&quot;/&quot;)===-1?&quot;&quot;:folder.substring(0,folder.lastIndexOf(&quot;/&quot;))+&quot;/&quot;;\nconst fname = await utils.inputPrompt(&quot;Filename for new file&quot;,&quot;Filename&quot;,folder);\nconst file = await app.fileManager.createAndOpenMarkdownFile(fname,true);\nawait ea.addImage(0,0,file);\nea.addElementsToView(true,true);\n\n","slug":"Create new markdown file and embed into active drawing","date":"2023-07-29T10:00:19.226Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"1efdb5a6988c00ebea0c5e042736921d","title":"Create DrawIO file","content":"&#x2F;*Creates a new draw.io diagram file and opens the file in the Diagram plugin in a new tab.\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.9.7&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nconst drawIO = app.plugins.plugins[&quot;drawio-obsidian&quot;];\nif(!drawIO || !drawIO?._loaded) &#123;\n  new Notice(&quot;Can&#39;t find the draw.io diagram plugin&quot;);\n&#125;\n\nfilename = await utils.inputPrompt(&quot;Diagram name?&quot;);\nif(!filename) return;\nfilename = filename.toLowerCase().endsWith(&quot;.svg&quot;) ? filename : filename + &quot;.svg&quot;;\nconst filepath = await ea.getAttachmentFilepath(filename);\nif(!filepath) return;\nconst leaf = app.workspace.getLeaf(&#39;tab&#39;)\nif(!leaf) return;\n\nconst file = await this.app.vault.create(filepath, `&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;!--$&#123;ea.generateElementId()&#125;--&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; version=&quot;1.1&quot; width=&quot;300px&quot; height=&quot;300px&quot; viewBox=&quot;-0.5 -0.5 1 1&quot; content=&quot;&amp;lt;mxGraphModel&amp;gt;&amp;lt;root&amp;gt;&amp;lt;mxCell id=&amp;quot;0&amp;quot;/&amp;gt;&amp;lt;mxCell id=&amp;quot;1&amp;quot; parent=&amp;quot;0&amp;quot;/&amp;gt;&amp;lt;/root&amp;gt;&amp;lt;/mxGraphModel&amp;gt;&quot;&gt;&lt;/svg&gt;`);\n\nawait ea.addImage(0,0,file);\nawait ea.addElementsToView(true,true);\n\nleaf.setViewState(&#123;\n  type: &quot;diagram-edit&quot;,\n  state: &#123;\n    file: filepath\n  &#125;\n&#125;);\n\n","slug":"Create DrawIO file","date":"2023-07-29T10:00:19.224Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"c17305872fedd7fedadb17f00b1756de","title":"Copy Selected Element Styles to Global","content":"&#x2F;*\n\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script will copy styles of any selected element into Excalidraw’s global styles.\nAfter copying the styles of element such as box, text, or arrow using this script, You can then use Excalidraw’s box, arrow, and other tools to create several elements with the same style. This is sometimes more convenient than Copy Styles and Paste Styles, especially when used with the script Box Each Selected Groups.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\n\nconst element = ea.getViewSelectedElement();\nconst appState = ea.getExcalidrawAPI().getAppState();\n\nif(!element) &#123;\n    return;\n&#125;\n\nappState.currentItemStrokeWidth = element.strokeWidth;\nappState.currentItemStrokeStyle = element.strokeStyle;\nappState.currentItemStrokeSharpness = element.strokeSharpness;\nappState.currentItemRoughness = element.roughness;\nappState.currentItemFillStyle = element.fillStyle;\nappState.currentItemBackgroundColor = element.backgroundColor;\nappState.currentItemStrokeColor = element.strokeColor;\n\nif(element.type === &#39;text&#39;) &#123;\n    appState.currentItemFontFamily = element.fontFamily;\n    appState.currentItemFontSize = element.fontSize;\n    appState.currentItemTextAlign = element.textAlign;\n&#125;\n\nif(element.type === &#39;arrow&#39;) &#123;\n    appState.currentItemStartArrowhead = element.startArrowhead;\n    appState.currentItemEndArrowhead = element.endArrowhead;\n&#125;\n\n","slug":"Copy Selected Element Styles to Global","date":"2023-07-29T10:00:19.222Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"bf67f810276e0a8abcc4bdbff6b0a55a","title":"Convert text to link with folder and alias","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\nConverts text elements to links pointing to a file in a selected folder and with the alias set as the original text. The script will prompt the user to select an existing folder from the vault.original text &#x3D;&gt; [[selected folder/original text|original text]]\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nfolders = new Set();\napp.vault.getFiles().forEach((f)=&gt;\n  folders.add(f.path.substring(0,f.path.lastIndexOf(&quot;/&quot;)))\n);\n\nf = Array.from(folders);\nfolder = await utils.suggester(f,f);\nfolder = folder??&quot;&quot;; //if exiting suggester with ESC\nfolder = folder === &quot;&quot; ? folder : folder + &quot;/&quot;;\n\nelements = ea.getViewSelectedElements().filter((el)=&gt;el.type===&quot;text&quot;);\n\nelements.forEach((el)=&gt;&#123;\n  el.rawText = &quot;[[&quot;+folder+el.rawText+&quot;|&quot;+el.rawText+&quot;]]&quot;;\n  el.text = &quot;[[&quot;+folder+el.text+&quot;|&quot;+el.text+&quot;]]&quot;;\n  el.originalText = &quot;[[&quot;+folder+el.originalText+&quot;|&quot;+el.originalText+&quot;]]&quot;;\n&#125;)\nea.copyViewElementsToEAforEditing(elements);\nea.addElementsToView();\n\n","slug":"Convert text to link with folder and alias","date":"2023-07-29T10:00:19.219Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"c2aba0c87b302b6184b94af8b9a48a21","title":"Convert selected text elements to sticky notes","content":"&#x2F;*\nConverts selected plain text elements to sticky notes with transparent background and transparent stroke color. Essentially converts text element into a wrappable format.\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nlet settings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Border color&quot;]) &#123;\n    settings = &#123;\n      &quot;Border color&quot; : &#123;\n            value: &quot;#000000&quot;,\n      description: &quot;Any legal HTML color (#000000, rgb, color-name, etc.). Set to &#39;transparent&#39; for transparent color.&quot;\n        &#125;,\n        &quot;Background color&quot; : &#123;\n            value: &quot;transparent&quot;,\n      description: &quot;Background color of the sticky note. Set to &#39;transparent&#39; for transparent color.&quot;\n        &#125;,\n        &quot;Background fill style&quot; : &#123;\n            value: &quot;solid&quot;,\n      description: &quot;Fill style of the sticky note&quot;,\n          valueset: [&quot;hachure&quot;,&quot;cross-hatch&quot;,&quot;solid&quot;]\n        &#125;\n    &#125;;\n    await ea.setScriptSettings(settings);\n&#125;\n\nif(!settings[&quot;Max sticky note width&quot;]) &#123;\n  settings[&quot;Max sticky note width&quot;] = &#123;\n    value: &quot;600&quot;,\n    description: &quot;Maximum width of new sticky note. If text is longer, it will be wrapped&quot;,\n      valueset: [&quot;400&quot;,&quot;600&quot;,&quot;800&quot;,&quot;1000&quot;,&quot;1200&quot;,&quot;1400&quot;,&quot;2000&quot;]\n  &#125;\n  await ea.setScriptSettings(settings);\n&#125;\nconst maxWidth = parseInt(settings[&quot;Max sticky note width&quot;].value);\nconst strokeColor = settings[&quot;Border color&quot;].value;\nconst backgroundColor = settings[&quot;Background color&quot;].value;\nconst fillStyle = settings[&quot;Background fill style&quot;].value;\n\nconst elements = ea\n  .getViewSelectedElements()\n  .filter((el)=&gt;(el.type===&quot;text&quot;)&amp;&amp;(el.containerId===null));\nif(elements.length===0) &#123;\n  new Notice(&quot;Please select a text element&quot;);\n  return;\n&#125;\nea.style.strokeColor = strokeColor;\nea.style.backgroundColor = backgroundColor;\nea.style.fillStyle = fillStyle;\nconst padding = 6;\nconst boxes = [];\nea.copyViewElementsToEAforEditing(elements);\nea.getElements().forEach((el)=&gt;&#123;\n  const width = el.width+2*padding;\n  const widthOK = width&lt;=maxWidth;\n  const id = ea.addRect(el.x-padding,el.y-padding,widthOK?width:maxWidth,el.height+2*padding);\n  boxes.push(id);\n  ea.getElement(id).boundElements=[&#123;type:&quot;text&quot;,id:el.id&#125;];\n  el.containerId = id;\n&#125;);\nawait ea.addElementsToView(false,true);\nconst containers = ea.getViewElements().filter(el=&gt;boxes.includes(el.id));\nea.getExcalidrawAPI().updateContainerSize(containers);\nea.selectElementsInView(containers);\n\n","slug":"Convert selected text elements to sticky notes","date":"2023-07-29T10:00:19.217Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"43401c5ad187ee18ee7b052dbabdf338","title":"Convert freedraw to line","content":"&#x2F;*\nConvert selected freedraw objects into editable lines. This will allow you to adjust your drawings by dragging line points and will also allow you to select shape fill in case of enclosed lines. You can adjust conversion point density in settings.\n*/\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Point density&quot;]) &#123;\n  settings = &#123;\n    &quot;Point density&quot; : &#123;\n      value: &quot;7:1&quot;,\n      valueset: [&quot;1:1&quot;,&quot;2:1&quot;,&quot;3:1&quot;,&quot;4:1&quot;,&quot;5:1&quot;,&quot;6:1&quot;,&quot;7:1&quot;,&quot;8:1&quot;,&quot;9:1&quot;,&quot;10:1&quot;,&quot;11:1&quot;],\n      description: &quot;A freedraw object has many points. Converting freedraw to a line with too many points will result in an impractical object that is hard to edit. This setting sepcifies how many points from freedraw should be averaged to form a point on the line&quot;\n    &#125;,\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125;\n\nconst scale = settings[&quot;Point density&quot;].value;\nconst setSize = parseInt(scale.substring(0,scale.indexOf(&quot;:&quot;)));\n\nconst elements = ea.getViewSelectedElements().filter(el=&gt;el.type===&quot;freedraw&quot;);\nif(elements.length === 0) &#123;\n    new Notice(&quot;No freedraw object is selected&quot;);\n&#125;\n\n\nea.style.roughness=0;\nea.style.strokeSharpness=&quot;round&quot;;\n\nelements.forEach((el)=&gt;&#123;\n    points = [];\n  points.push(el.points[0]);\n  for(i=1;i&lt;el.points.length;i+=setSize) &#123;\n        point = [0,0];\n    count = 0;\n    for(p of el.points.slice(i,i+setSize)) &#123;\n            point = [ point[0]+p[0] , point[1]+p[1] ];\n            count++;\n        &#125;\n        point = [point[0]/count,point[1]/count];\n      points.push(point);\n    &#125;\n    const lineId = ea.addLine(points);\n  const line = ea.getElement(lineId);\n  line.strokeWidth = el.strokeWidth*3;\n  line.strokeColor = el.strokeColor;\n  line.width = el.width;\n  line.height = el.height;\n  line.x = el.x;\n  line.y = el.y;\n&#125;);\n\nea.deleteViewElements(elements);\nawait ea.addElementsToView(false,false,true);\nea.selectElementsInView(ea.getElements());\n\n","slug":"Convert freedraw to line","date":"2023-07-29T10:00:19.215Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"69efa56c4e6a0d938e2d0b8bdc0d033b","title":"Connect elements","content":"&#x2F;*\nThis script will connect two objects with an arrow. If either of the objects are a set of grouped elements (e.g. a text element grouped with an encapsulating rectangle), the script will identify these groups, and connect the arrow to the largest object in the group (assuming you want to connect the arrow to the box around the text element).\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Starting arrowhead&quot;]) &#123;\n    settings = &#123;\n      &quot;Starting arrowhead&quot; : &#123;\n            value: &quot;none&quot;,\n      valueset: [&quot;none&quot;,&quot;arrow&quot;,&quot;triangle&quot;,&quot;bar&quot;,&quot;dot&quot;]\n        &#125;,\n        &quot;Ending arrowhead&quot; : &#123;\n            value: &quot;triangle&quot;,\n      valueset: [&quot;none&quot;,&quot;arrow&quot;,&quot;triangle&quot;,&quot;bar&quot;,&quot;dot&quot;]\n        &#125;,\n        &quot;Line points&quot; : &#123;\n            value: 1,\n      description: &quot;Number of line points between start and end&quot;\n        &#125;\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nconst arrowStart = settings[&quot;Starting arrowhead&quot;].value === &quot;none&quot; ? null : settings[&quot;Starting arrowhead&quot;].value;\nconst arrowEnd = settings[&quot;Ending arrowhead&quot;].value === &quot;none&quot; ? null : settings[&quot;Ending arrowhead&quot;].value;\nconst linePoints = Math.floor(settings[&quot;Line points&quot;].value);\n\n\n\nconst elements = ea.getViewSelectedElements();\nea.copyViewElementsToEAforEditing(elements);\ngroups = ea.getMaximumGroups(elements);\nif(groups.length !== 2) &#123;\n  //unfortunately getMaxGroups returns duplicated resultset for sticky notes\n  //needs additional filtering\n  cleanGroups=[];\n  idList = [];\n  for (group of groups) &#123;\n    keep = true;\n    for(item of group) if(idList.contains(item.id)) keep = false;\n    if(keep) &#123;\n      cleanGroups.push(group);\n      idList = idList.concat(group.map(el=&gt;el.id))\n    &#125;\n  &#125;\n  if(cleanGroups.length !== 2) return;\n  groups = cleanGroups;\n&#125;\nels = [ \n  ea.getLargestElement(groups[0]),\n  ea.getLargestElement(groups[1])\n];\n\nea.style.strokeColor = els[0].strokeColor;\nea.style.strokeWidth = els[0].strokeWidth;\nea.style.strokeStyle = els[0].strokeStyle;\nea.style.strokeSharpness = els[0].strokeSharpness;\nea.connectObjects(\n  els[0].id,\n  null,\n  els[1].id,\n  null, \n  &#123;\n    endArrowHead: arrowEnd,\n    startArrowHead: arrowStart, \n    numberOfPoints: linePoints\n  &#125;\n);\nea.addElementsToView(false,false,true);\n\n","slug":"Connect elements","date":"2023-07-29T10:00:19.213Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"61dc4c6fa14e45b1f3c1cc463dbd416d","title":"Change shape of selected elements","content":"&#x2F;*\nThe script allows you to change the shape and fill style of selected Rectangles, Diamonds, Ellipses, Lines, Arrows and Freedraw. \n*/\nconst fillStylesDispaly=[&quot;Dots (⚠ VERY SLOW performance on large objects!)&quot;,&quot;Zigzag&quot;,&quot;Zigzag-line&quot;, &quot;Dashed&quot;, &quot;Hachure&quot;, &quot;Cross-hatch&quot;, &quot;Solid&quot;];\nconst fillStyles=[&quot;dots&quot;,&quot;zigzag&quot;,&quot;zigzag-line&quot;, &quot;dashed&quot;, &quot;hachure&quot;, &quot;cross-hatch&quot;, &quot;solid&quot;];\nconst fillShapes=[&quot;ellipse&quot;,&quot;rectangle&quot;,&quot;diamond&quot;, &quot;freedraw&quot;, &quot;line&quot;];\nconst boxShapesDispaly=[&quot;○ ellipse&quot;,&quot;□ rectangle&quot;,&quot;◇ diamond&quot;];\nconst boxShapes=[&quot;ellipse&quot;,&quot;rectangle&quot;,&quot;diamond&quot;];\nconst lineShapesDispaly=[&quot;- line&quot;,&quot;⭢ arrow&quot;];\nconst lineShapes=[&quot;line&quot;,&quot;arrow&quot;];\n\nlet editedElements = [];\n\nlet elements = ea.getViewSelectedElements().filter(el=&gt;boxShapes.contains(el.type));\nif (elements.length&gt;0) &#123;\n  newShape = await utils.suggester(boxShapesDispaly, boxShapes, &quot;Change shape of &#39;box&#39; type elements in selection, press ESC to skip&quot;);\n  if(newShape) &#123;\n    editedElements = elements;\n    elements.forEach(el=&gt;el.type = newShape);\n  &#125;\n&#125;\n\nelements = ea.getViewSelectedElements().filter(el=&gt;fillShapes.contains(el.type));\nif (elements.length&gt;0) &#123;\n  newFillStyle = await utils.suggester(fillStylesDispaly, fillStyles, &quot;Change the fill style of elements in selection, press ESC to skip&quot;);\n  if(newFillStyle) &#123;\n    editedElements = editedElements.concat(elements.filter(e=&gt;!editedElements.some(el=&gt;el.id===e.id)));\n    elements.forEach(el=&gt;el.fillStyle = newFillStyle);\n  &#125;\n&#125;\n\nelements = ea.getViewSelectedElements().filter(el=&gt;lineShapes.contains(el.type));\nif (elements.length&gt;0) &#123;\n  newShape = await utils.suggester(lineShapesDispaly, lineShapes, &quot;Change shape of &#39;line&#39; type elements in selection, press ESC to skip&quot;);\n  if(newShape) &#123;\n    editedElements = editedElements.concat(elements.filter(e=&gt;!editedElements.some(el=&gt;el.id===e.id)));\n    elements.forEach((el)=&gt;&#123;\n      el.type = newShape;\n      if(newShape === &quot;arrow&quot;) &#123;\n        el.endArrowhead = &quot;triangle&quot;;\n      &#125;\n    &#125;);\n  &#125;\n&#125;\n\nea.copyViewElementsToEAforEditing(editedElements);\n\nea.addElementsToView(false,false);\n\n","slug":"Change shape of selected elements","date":"2023-07-29T10:00:19.211Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"cba608aa7fc3ed1d75673bd983bf4402","title":"Box Selected Elements","content":"&#x2F;*\nThis script will add an encapsulating box around the currently selected elements in Excalidraw.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Default padding&quot;]) &#123;\n    settings = &#123;\n        &quot;Prompt for padding?&quot;: true,\n      &quot;Default padding&quot; : &#123;\n            value: 10,\n          description: &quot;Padding between the bounding box of the selected elements, and the box the script creates&quot;\n        &#125;\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nlet padding = settings[&quot;Default padding&quot;].value;\n\nif(settings[&quot;Prompt for padding?&quot;]) &#123;\n    padding = parseInt (await utils.inputPrompt(&quot;padding?&quot;,&quot;number&quot;,padding.toString()));\n&#125;\n\nif(isNaN(padding)) &#123;\n  new Notice(&quot;The padding value provided is not a number&quot;);\n  return;\n&#125;\nelements = ea.getViewSelectedElements();\nconst box = ea.getBoundingBox(elements);\ncolor = ea\n        .getExcalidrawAPI()\n        .getAppState()\n        .currentItemStrokeColor;\n//uncomment for random color:\n//color = &#39;#&#39;+(Math.random()*0xFFFFFF&lt;&lt;0).toString(16).padStart(6,&quot;0&quot;);\nea.style.strokeColor = color;\nid = ea.addRect(\n    box.topX - padding,\n    box.topY - padding,\n    box.width + 2*padding,\n    box.height + 2*padding\n);\nea.copyViewElementsToEAforEditing(elements);\nea.addToGroup([id].concat(elements.map((el)=&gt;el.id)));\nea.addElementsToView(false,false);\n\n","slug":"Box Selected Elements","date":"2023-07-29T10:00:19.209Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"1f6284048f0d626a1ed81fc1a62dfb0d","title":"Box Each Selected Groups","content":"&#x2F;*\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script will add encapsulating boxes around each of the currently selected groups in Excalidraw.\nYou can focus on content creation first, and then batch add consistent style boxes to each group of text.\nTips 1: You can copy the desired style to the global state using script Copy Selected Element Style to Global, then add boxes with the same global style using script Box Each Selected Groups.\nTips 2: Next you can use scripts Expand rectangles horizontally keep text centered and Expand rectangles vertically keep text centered to make the boxes the same size, if you wish.\nTips 3: If you want the left and right margins to be different from the top and bottom margins, input something like 32,16, this will create a box with left and right margins of 32 and top and bottom margins of 16.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Default padding&quot;]) &#123;\n    settings = &#123;\n      &quot;Prompt for padding?&quot;: true,\n      &quot;Default padding&quot; : &#123;\n            value: 10,\n          description: &quot;Padding between the bounding box of the selected elements, and the box the script creates&quot;\n      &#125;,\n      &quot;Remember last padding?&quot;: false\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nlet paddingStr = settings[&quot;Default padding&quot;].value.toString();\nconst rememberLastPadding = settings[&quot;Remember last padding?&quot;];\n\nif(settings[&quot;Prompt for padding?&quot;]) &#123;\n    paddingStr = await utils.inputPrompt(&quot;padding?&quot;,&quot;string&quot;,paddingStr);\n&#125;\nif(!paddingStr) &#123;\n    return;\n&#125;\nif(rememberLastPadding) &#123;\n    settings[&quot;Default padding&quot;].value = paddingStr;\n    ea.setScriptSettings(settings);\n&#125;\nvar paddingLR = 0;\nvar paddingTB = 0;\nif(paddingStr.indexOf(&#39;,&#39;) &gt; 0) &#123;\n    const paddingParts = paddingStr.split(&#39;,&#39;);\n    paddingLR = parseInt(paddingParts[0]);\n    paddingTB = parseInt(paddingParts[1]);\n&#125;\nelse &#123;\n    paddingLR = paddingTB = parseInt(paddingStr);\n&#125;\n\nif(isNaN(paddingLR) || isNaN(paddingTB)) &#123;\n    return;\n&#125;\n\nconst selectedElements = ea.getViewSelectedElements();\nconst groups = ea.getMaximumGroups(selectedElements);\nconst allIndividualArrows = ea.getMaximumGroups(ea.getViewElements())\n    .reduce((result, group) =&gt; (group.length === 1 &amp;&amp; (group[0].type === &#39;arrow&#39; || group[0].type === &#39;line&#39;)) ? \n            [...result, group[0]] : result, []);\nfor(const elements of groups) &#123;\n    if(elements.length === 1 &amp;&amp; elements[0].type ===&quot;arrow&quot; || elements[0].type===&quot;line&quot;) &#123;\n        // individual arrows or lines are not affected\n        continue;\n    &#125;\n    const box = ea.getBoundingBox(elements);\n    color = ea\n            .getExcalidrawAPI()\n            .getAppState()\n            .currentItemStrokeColor;\n    // use current stroke with and style\n    const appState = ea.getExcalidrawAPI().getAppState();\n    const strokeWidth = appState.currentItemStrokeWidth;\n    const strokeStyle = appState.currentItemStrokeStyle;\n    const strokeSharpness = appState.currentItemStrokeSharpness;\n    const roughness = appState.currentItemRoughness;\n    const fillStyle = appState.currentItemFillStyle;\n    const backgroundColor = appState.currentItemBackgroundColor;\n    ea.style.strokeWidth = strokeWidth;\n    ea.style.strokeStyle = strokeStyle;\n    ea.style.strokeSharpness = strokeSharpness;\n    ea.style.roughness = roughness;\n    ea.style.fillStyle = fillStyle;\n    ea.style.backgroundColor = backgroundColor;\t\n    ea.style.strokeColor = color;\n\n    const id = ea.addRect(\n        box.topX - paddingLR,\n        box.topY - paddingTB,\n        box.width + 2*paddingLR,\n        box.height + 2*paddingTB\n    );\n\n    // Change the join point in the group to the new box\n    const elementsWithBounded = elements.filter(el =&gt; (el.boundElements || []).length &gt; 0);\n    const boundedElementsCollection = elementsWithBounded.reduce((result, el) =&gt; [...result, ...el.boundElements], []);\n    for(const el of elementsWithBounded) &#123;\n        el.boundElements = [];\n    &#125;\n\n    const newRect = ea.getElement(id);\n    newRect.boundElements = boundedElementsCollection;\n\n    const elementIds = elements.map(el =&gt; el.id);\n\n    const startBindingLines = allIndividualArrows.filter(el =&gt; elementIds.includes((el.startBinding||&#123;&#125;).elementId));\n    for(startBindingLine of startBindingLines) &#123;\n        startBindingLine.startBinding.elementId = id;\n        recalculateStartPointOfLine(startBindingLine, newRect);\n    &#125;\n\n    const endBindingLines = allIndividualArrows.filter(el =&gt; elementIds.includes((el.endBinding||&#123;&#125;).elementId));\n    for(endBindingLine of endBindingLines) &#123;\n        endBindingLine.endBinding.elementId = id;\n        recalculateEndPointOfLine(endBindingLine, newRect);\n    &#125;\n\n    ea.copyViewElementsToEAforEditing(elements);\n    ea.addToGroup([id].concat(elements.map((el)=&gt;el.id)));\n&#125;\n\nawait ea.addElementsToView(false,false);\n\nfunction recalculateStartPointOfLine(line, el) &#123;\n    const aX = el.x + el.width/2;\n    const bX = line.x + line.points[1][0];\n    const aY = el.y + el.height/2;\n    const bY = line.y + line.points[1][1];\n\n    line.startBinding.gap = 8;\n    line.startBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.startBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[0] = [0, 0];\n        for(var i = 1; i&lt;line.points.length; i++) &#123;\n            line.points[i][0] -= intersectA[0][0] - line.x;\n            line.points[i][1] -= intersectA[0][1] - line.y;\n        &#125;\n        line.x = intersectA[0][0];\n        line.y = intersectA[0][1];\n    &#125;\n&#125;\n\nfunction recalculateEndPointOfLine(line, el) &#123;\n    const aX = el.x + el.width/2;\n    const bX = line.x + line.points[line.points.length-2][0];\n    const aY = el.y + el.height/2;\n    const bY = line.y + line.points[line.points.length-2][1];\n\n    line.endBinding.gap = 8;\n    line.endBinding.focus = 0;\n    const intersectA = ea.intersectElementWithLine(\n                el,\n                [bX, bY],\n                [aX, aY],\n                line.endBinding.gap\n              );\n\n    if(intersectA.length &gt; 0) &#123;\n        line.points[line.points.length - 1] = [intersectA[0][0] - line.x, intersectA[0][1] - line.y];\n    &#125;\n&#125;\n\n","slug":"Box Each Selected Groups","date":"2023-07-29T10:00:19.207Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"93126ca1dba62bd049917d90fc642684","title":"Auto Layout","content":"&#x2F;*\n\nDownload this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.\n\nThis script performs automatic layout for the selected top-level grouping objects. It is powered by elkjs and needs to be connected to the Internet.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\n\nif (\n  !ea.verifyMinimumPluginVersion ||\n  !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)\n) &#123;\n  new Notice(\n    &quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;\n  );\n  return;\n&#125;\n\nsettings = ea.getScriptSettings();\n//set default values on first run\nif (!settings[&quot;Layout Options JSON&quot;]) &#123;\n  settings = &#123;\n    &quot;Layout Options JSON&quot;: &#123;\n      height: &quot;450px&quot;,\n      value: `&#123;\\n      &quot;org.eclipse.elk.layered.crossingMinimization.semiInteractive&quot;: &quot;true&quot;,\\n      &quot;org.eclipse.elk.layered.considerModelOrder.components&quot;: &quot;FORCE_MODEL_ORDER&quot;\\n&#125;`,\n      description: `You can use layout options to configure the layout algorithm. A list of all options and further details of their exact effects is available in &lt;a href=&quot;http://www.eclipse.org/elk/reference.html&quot; rel=&quot;nofollow&quot;&gt;ELK&#39;s documentation&lt;/a&gt;.`,\n    &#125;,\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125; \n\nif (typeof ELK === &quot;undefined&quot;) &#123;\n  loadELK(doAutoLayout);\n&#125; else &#123;\n  doAutoLayout();\n&#125;\n\nasync function doAutoLayout() &#123;\n  const selectedElements = ea.getViewSelectedElements();\n  const groups = ea\n    .getMaximumGroups(selectedElements)\n    .map((g) =&gt; g.filter((el) =&gt; el.containerId == null)) // ignore text in stickynote\n    .filter((els) =&gt; els.length &gt; 0);\n\n  const stickynotesMap = selectedElements\n    .filter((el) =&gt; el.containerId != null)\n    .reduce((result, el) =&gt; &#123;\n      result.set(el.containerId, el);\n      return result;\n    &#125;, new Map());\n\n  const elk = new ELK();\n  const knownLayoutAlgorithms = await elk.knownLayoutAlgorithms();\n  const layoutAlgorithms = knownLayoutAlgorithms\n    .map((knownLayoutAlgorithm) =&gt; (&#123;\n      id: knownLayoutAlgorithm.id,\n      displayText:\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.layered&quot; ||\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.radial&quot; ||\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.mrtree&quot;\n          ? &quot;* &quot; +\n            knownLayoutAlgorithm.name +\n            &quot;: &quot; +\n            knownLayoutAlgorithm.description\n          : knownLayoutAlgorithm.name + &quot;: &quot; + knownLayoutAlgorithm.description,\n    &#125;))\n    .sort((lha, rha) =&gt; lha.displayText.localeCompare(rha.displayText));\n\n  const layoutAlgorithmsSimple = knownLayoutAlgorithms\n    .map((knownLayoutAlgorithm) =&gt; (&#123;\n      id: knownLayoutAlgorithm.id,\n      displayText:\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.layered&quot; ||\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.radial&quot; ||\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.mrtree&quot;\n          ? &quot;* &quot; + knownLayoutAlgorithm.name\n          : knownLayoutAlgorithm.name,\n    &#125;))\n    .sort((lha, rha) =&gt; lha.displayText.localeCompare(rha.displayText));\n\n  // const knownOptions = knownLayoutAlgorithms\n  //   .reduce(\n  //     (result, knownLayoutAlgorithm) =&gt; [\n  //       ...result,\n  //       ...knownLayoutAlgorithm.knownOptions,\n  //     ],\n  //     []\n  //   )\n  //   .filter((value, index, self) =&gt; self.indexOf(value) === index) // remove duplicates\n  //   .sort((lha, rha) =&gt; lha.localeCompare(rha));\n  // console.log(&quot;knownOptions&quot;, knownOptions);\n\n  const selectedAlgorithm = await utils.suggester(\n    layoutAlgorithms.map((algorithmInfo) =&gt; algorithmInfo.displayText),\n    layoutAlgorithms.map((algorithmInfo) =&gt; algorithmInfo.id),\n    &quot;Layout algorithm&quot;\n  );\n\n  const knownNodePlacementStrategy = [\n    &quot;SIMPLE&quot;,\n    &quot;INTERACTIVE&quot;,\n    &quot;LINEAR_SEGMENTS&quot;,\n    &quot;BRANDES_KOEPF&quot;,\n    &quot;NETWORK_SIMPLEX&quot;,\n  ];\n\n  const knownDirections = [\n    &quot;UNDEFINED&quot;,\n    &quot;RIGHT&quot;,\n    &quot;LEFT&quot;,\n    &quot;DOWN&quot;,\n    &quot;UP&quot;\n  ];\n\n  let nodePlacementStrategy = &quot;BRANDES_KOEPF&quot;;\n  let componentComponentSpacing = &quot;10&quot;;\n  let nodeNodeSpacing = &quot;100&quot;;\n  let nodeNodeBetweenLayersSpacing = &quot;100&quot;;\n  let discoComponentLayoutAlgorithm = &quot;org.eclipse.elk.layered&quot;;\n  let direction = &quot;UNDEFINED&quot;;\n\n  if (selectedAlgorithm === &quot;org.eclipse.elk.layered&quot;) &#123;\n    nodePlacementStrategy = await utils.suggester(\n      knownNodePlacementStrategy,\n      knownNodePlacementStrategy,\n      &quot;Node placement strategy&quot;\n    );\n\n    selectedDirection = await utils.suggester(\n      knownDirections,\n      knownDirections,\n      &quot;Direction&quot;\n    );\n    direction = selectedDirection??&quot;UNDEFINED&quot;;\n  &#125; else if (selectedAlgorithm === &quot;org.eclipse.elk.disco&quot;) &#123;\n    const componentLayoutAlgorithms = layoutAlgorithmsSimple.filter(al =&gt; al.id !== &quot;org.eclipse.elk.disco&quot;);\n    const selectedDiscoComponentLayoutAlgorithm = await utils.suggester(\n      componentLayoutAlgorithms.map((algorithmInfo) =&gt; algorithmInfo.displayText),\n      componentLayoutAlgorithms.map((algorithmInfo) =&gt; algorithmInfo.id),\n      &quot;Disco Connected Components Layout Algorithm&quot;\n    );\n    discoComponentLayoutAlgorithm = selectedDiscoComponentLayoutAlgorithm??&quot;org.eclipse.elk.layered&quot;;\n  &#125;\n\n  if (\n    selectedAlgorithm === &quot;org.eclipse.elk.box&quot; ||\n    selectedAlgorithm === &quot;org.eclipse.elk.rectpacking&quot;\n  ) &#123;\n    nodeNodeSpacing = await utils.inputPrompt(&quot;Node Spacing&quot;, &quot;number&quot;, &quot;10&quot;);\n  &#125; else &#123;\n    let userSpacingStr = await utils.inputPrompt(\n      &quot;Components Spacing, Node Spacing, Node Node Between Layers Spacing&quot;,\n      &quot;number, number, number&quot;,\n      &quot;10, 100, 100&quot;\n    );\n    let userSpacingArr = (userSpacingStr??&quot;&quot;).split(&quot;,&quot;);\n    componentComponentSpacing = userSpacingArr[0] ?? &quot;10&quot;;\n    nodeNodeSpacing = userSpacingArr[1] ?? &quot;100&quot;;\n    nodeNodeBetweenLayersSpacing = userSpacingArr[2] ?? &quot;100&quot;;\n  &#125;\n\n  let layoutOptionsJson = &#123;&#125;;\n  try &#123;\n    layoutOptionsJson = JSON.parse(settings[&quot;Layout Options JSON&quot;].value);\n  &#125; catch (e) &#123;\n    new Notice(\n      &quot;Error reading Layout Options JSON, see developer console for more information&quot;,\n      4000\n    );\n    console.log(e);\n  &#125;\n\n  layoutOptionsJson[&quot;elk.algorithm&quot;] = selectedAlgorithm;\n  layoutOptionsJson[&quot;org.eclipse.elk.spacing.componentComponent&quot;] =\n    componentComponentSpacing;\n  layoutOptionsJson[&quot;org.eclipse.elk.spacing.nodeNode&quot;] = nodeNodeSpacing;\n  layoutOptionsJson[&quot;org.eclipse.elk.layered.spacing.nodeNodeBetweenLayers&quot;] =\n    nodeNodeBetweenLayersSpacing;\n  layoutOptionsJson[&quot;org.eclipse.elk.layered.nodePlacement.strategy&quot;] =\n    nodePlacementStrategy;\n  layoutOptionsJson[&quot;org.eclipse.elk.disco.componentCompaction.componentLayoutAlgorithm&quot;] = \n    discoComponentLayoutAlgorithm;\n  layoutOptionsJson[&quot;org.eclipse.elk.direction&quot;] = direction;\n\n  const graph = &#123;\n    id: &quot;root&quot;,\n    layoutOptions: layoutOptionsJson,\n    children: [],\n    edges: [],\n  &#125;;\n\n  let groupMap = new Map();\n  let targetElkMap = new Map();\n  let arrowEls = [];\n\n  for (let i = 0; i &lt; groups.length; i++) &#123;\n    const elements = groups[i];\n    if (\n      elements.length === 1 &amp;&amp;\n      (elements[0].type === &quot;arrow&quot; || elements[0].type === &quot;line&quot;)\n    ) &#123;\n      if (\n        elements[0].type === &quot;arrow&quot; &amp;&amp;\n        elements[0].startBinding &amp;&amp;\n        elements[0].endBinding\n      ) &#123;\n        arrowEls.push(elements[0]);\n      &#125;\n    &#125; else &#123;\n      let elkId = &quot;g&quot; + i;\n      elements.reduce((result, el) =&gt; &#123;\n        result.set(el.id, elkId);\n        return result;\n      &#125;, targetElkMap);\n\n      const box = ea.getBoundingBox(elements);\n      groupMap.set(elkId, &#123;\n        elements: elements,\n        boundingBox: box,\n      &#125;);\n\n      graph.children.push(&#123;\n        id: elkId,\n        width: box.width,\n        height: box.height,\n        x: box.topX,\n        y: box.topY,\n      &#125;);\n    &#125;\n  &#125;\n\n  for (let i = 0; i &lt; arrowEls.length; i++) &#123;\n    const arrowEl = arrowEls[i];\n    const startElkId = targetElkMap.get(arrowEl.startBinding.elementId);\n    const endElkId = targetElkMap.get(arrowEl.endBinding.elementId);\n\n    graph.edges.push(&#123;\n      id: &quot;e&quot; + i,\n      sources: [startElkId],\n      targets: [endElkId],\n    &#125;);\n  &#125;\n\n  const initTopX =\n    Math.min(...Array.from(groupMap.values()).map((v) =&gt; v.boundingBox.topX)) -\n    12;\n  const initTopY =\n    Math.min(...Array.from(groupMap.values()).map((v) =&gt; v.boundingBox.topY)) -\n    12;\n\n  elk\n    .layout(graph)\n    .then((resultGraph) =&gt; &#123;\n      for (const elkEl of resultGraph.children) &#123;\n        const group = groupMap.get(elkEl.id);\n        for (const groupEl of group.elements) &#123;\n          const originalDistancX = groupEl.x - group.boundingBox.topX;\n          const originalDistancY = groupEl.y - group.boundingBox.topY;\n          const groupElDistanceX =\n            elkEl.x + initTopX + originalDistancX - groupEl.x;\n          const groupElDistanceY =\n            elkEl.y + initTopY + originalDistancY - groupEl.y;\n\n          groupEl.x = groupEl.x + groupElDistanceX;\n          groupEl.y = groupEl.y + groupElDistanceY;\n\n          if (stickynotesMap.has(groupEl.id)) &#123;\n            const stickynote = stickynotesMap.get(groupEl.id);\n            stickynote.x = stickynote.x + groupElDistanceX;\n            stickynote.y = stickynote.y + groupElDistanceY;\n          &#125;\n        &#125;\n      &#125;\n\n      ea.copyViewElementsToEAforEditing(selectedElements);\n      ea.addElementsToView(false, false);\n\n      normalizeSelectedArrows();\n    &#125;)\n    .catch(console.error);\n&#125;\n\nfunction loadELK(doAfterLoaded) &#123;\n  let script = document.createElement(&quot;script&quot;);\n  script.onload = function () &#123;\n    if (typeof ELK !== &quot;undefined&quot;) &#123;\n      doAfterLoaded();\n    &#125;\n  &#125;;\n  script.src =\n    &quot;https://cdn.jsdelivr.net/npm/elkjs@0.8.2/lib/elk.bundled.min.js&quot;;\n  document.head.appendChild(script);\n&#125;\n\n/*\n * Normalize Selected Arrows\n */\n\nfunction normalizeSelectedArrows() &#123;\n  let gapValue = 2;\n\n  const selectedIndividualArrows = ea.getMaximumGroups(ea.getViewSelectedElements())\n    .reduce((result, g) =&gt; [...result, ...g.filter(el =&gt; el.type === &#39;arrow&#39;)], []);\n\n  const allElements = ea.getViewElements();\n  for (const arrow of selectedIndividualArrows) &#123;\n    const startBindingEl = allElements.filter(\n      (el) =&gt; el.id === (arrow.startBinding || &#123;&#125;).elementId\n    )[0];\n    const endBindingEl = allElements.filter(\n      (el) =&gt; el.id === (arrow.endBinding || &#123;&#125;).elementId\n    )[0];\n\n    if (startBindingEl) &#123;\n      recalculateStartPointOfLine(\n        arrow,\n        startBindingEl,\n        endBindingEl,\n        gapValue\n      );\n    &#125;\n    if (endBindingEl) &#123;\n      recalculateEndPointOfLine(arrow, endBindingEl, startBindingEl, gapValue);\n    &#125;\n  &#125;\n\n  ea.copyViewElementsToEAforEditing(selectedIndividualArrows);\n  ea.addElementsToView(false, false);\n&#125;\n\nfunction recalculateStartPointOfLine(line, el, elB, gapValue) &#123;\n  const aX = el.x + el.width / 2;\n  const bX =\n    line.points.length &lt;= 2 &amp;&amp; elB\n      ? elB.x + elB.width / 2\n      : line.x + line.points[1][0];\n  const aY = el.y + el.height / 2;\n  const bY =\n    line.points.length &lt;= 2 &amp;&amp; elB\n      ? elB.y + elB.height / 2\n      : line.y + line.points[1][1];\n\n  line.startBinding.gap = gapValue;\n  line.startBinding.focus = 0;\n  const intersectA = ea.intersectElementWithLine(\n    el,\n    [bX, bY],\n    [aX, aY],\n    line.startBinding.gap\n  );\n\n  if (intersectA.length &gt; 0) &#123;\n    line.points[0] = [0, 0];\n    for (let i = 1; i &lt; line.points.length; i++) &#123;\n      line.points[i][0] -= intersectA[0][0] - line.x;\n      line.points[i][1] -= intersectA[0][1] - line.y;\n    &#125;\n    line.x = intersectA[0][0];\n    line.y = intersectA[0][1];\n  &#125;\n&#125;\n\nfunction recalculateEndPointOfLine(line, el, elB, gapValue) &#123;\n  const aX = el.x + el.width / 2;\n  const bX =\n    line.points.length &lt;= 2 &amp;&amp; elB\n      ? elB.x + elB.width / 2\n      : line.x + line.points[line.points.length - 2][0];\n  const aY = el.y + el.height / 2;\n  const bY =\n    line.points.length &lt;= 2 &amp;&amp; elB\n      ? elB.y + elB.height / 2\n      : line.y + line.points[line.points.length - 2][1];\n\n  line.endBinding.gap = gapValue;\n  line.endBinding.focus = 0;\n  const intersectA = ea.intersectElementWithLine(\n    el,\n    [bX, bY],\n    [aX, aY],\n    line.endBinding.gap\n  );\n\n  if (intersectA.length &gt; 0) &#123;\n    line.points[line.points.length - 1] = [\n      intersectA[0][0] - line.x,\n      intersectA[0][1] - line.y,\n    ];\n  &#125;\n&#125;\n\n","slug":"Auto Layout","date":"2023-07-29T10:00:19.205Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"e4d1ac459887c21249603be66b9f7f5b","title":"Auto Draw for Pen","content":"&#x2F;*Automatically switches between the select and draw tools, based on whether a pen is being used.\n\nChoose the select tool\nHover&#x2F;use the pen to draw, move it away to return to select modeThis is based on pen hover status, so will only work if your pen supports hover!If you click draw with the mouse or press select with the pen, switching will be disabled until the opposite input method is used.\n\nNote: This script will stay active until the Obsidian window is closed.\nCompatible with my Hardware Eraser Support script\n*/\n(function() &#123;\n    &#39;use strict&#39;;\n    \n    let promise\n    let timeout\n    let disable\n\n    function handlePointer(e) &#123;\n        ea.setView(&quot;active&quot;);\n        var activeTool = ea.getExcalidrawAPI().getAppState().activeTool;\n        function setActiveTool(t) &#123;\n            ea.getExcalidrawAPI().setActiveTool(t)\n        &#125;\n\n        if (e.pointerType === &#39;pen&#39;) &#123;\n            if (disable) return\n            if (!promise &amp;&amp; activeTool.type===&#39;selection&#39;) &#123;\n                setActiveTool(&#123;type:&quot;freedraw&quot;&#125;)\n            &#125;\n\n            if (timeout) clearTimeout(timeout)\n\n            function setTimeoutX(a,b) &#123;\n                timeout = setTimeout(a,b)\n                return timeout\n            &#125;\n    \n            function revert() &#123;\n                activeTool = ea.getExcalidrawAPI().getAppState().activeTool;\n                disable = false\n                if (activeTool.type===&#39;freedraw&#39;) &#123;\n                    setActiveTool(&#123;type:&quot;selection&quot;&#125;)\n                &#125; else if (activeTool.type===&#39;selection&#39;) &#123;\n                    disable = true\n                &#125;\n                promise = false\n            &#125;\n\n            promise = new Promise(resolve =&gt; setTimeoutX(resolve, 500))\n            promise.then(() =&gt; revert())\n        &#125;\n    &#125;\n    function handleClick(e) &#123;\n        ea.setView(&quot;active&quot;);\n        if (e.pointerType !== &#39;pen&#39;) &#123;\n            disable = false\n        &#125;\n    &#125;\n\n    window.addEventListener(&#39;pointermove&#39;, handlePointer, &#123; capture: true &#125;)\n    window.addEventListener(&#39;pointerdown&#39;, handleClick, &#123; capture: true &#125;)\n\n&#125;)();\n\n","slug":"Auto Draw for Pen","date":"2023-07-29T10:00:19.203Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"596ec896ae628dddf8ba2d8237bc03cd","title":"Add Next Step in Process","content":"&#x2F;*\nThis script will prompt you for the title of the process step, then will create a stick note with the text. If an element is selected then the script will connect this new step with an arrow to the previous step (the selected element). If no element is selected, then the script assumes this is the first step in the process and will only output the sticky note with the text that was entered.\n*/\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.24&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nsettings = ea.getScriptSettings();\n//set default values on first run\nif(!settings[&quot;Starting arrowhead&quot;]) &#123;\n    settings = &#123;\n      &quot;Starting arrowhead&quot; : &#123;\n            value: &quot;none&quot;,\n      valueset: [&quot;none&quot;,&quot;arrow&quot;,&quot;triangle&quot;,&quot;bar&quot;,&quot;dot&quot;]\n        &#125;,\n        &quot;Ending arrowhead&quot; : &#123;\n            value: &quot;triangle&quot;,\n      valueset: [&quot;none&quot;,&quot;arrow&quot;,&quot;triangle&quot;,&quot;bar&quot;,&quot;dot&quot;]\n        &#125;,\n        &quot;Line points&quot; : &#123;\n            value: 0,\n      description: &quot;Number of line points between start and end&quot;\n        &#125;,\n        &quot;Gap between elements&quot;: &#123;\n            value: 100\n        &#125;,\n        &quot;Wrap text at (number of characters)&quot;: &#123;\n            value: 25,\n        &#125;,\n        &quot;Fix width&quot;: &#123;\n            value: true,\n            description: &quot;The object around the text should have fix width to fit the wrapped text&quot;\n        &#125;\n    &#125;;\n    ea.setScriptSettings(settings);\n&#125;\n\nconst arrowStart = settings[&quot;Starting arrowhead&quot;].value === &quot;none&quot; ? null : settings[&quot;Starting arrowhead&quot;].value;\nconst arrowEnd = settings[&quot;Ending arrowhead&quot;].value === &quot;none&quot; ? null : settings[&quot;Ending arrowhead&quot;].value;\n\n// workaround until https://github.com/zsviczian/obsidian-excalidraw-plugin/issues/388 is fixed\nif (!arrowEnd) ea.style.endArrowHead = null;\nif (!arrowStart) ea.style.startArrowHead = null;\n\nconst linePoints = Math.floor(settings[&quot;Line points&quot;].value);\nconst gapBetweenElements = Math.floor(settings[&quot;Gap between elements&quot;].value);\nconst wrapLineLen = Math.floor(settings[&quot;Wrap text at (number of characters)&quot;].value);\nconst fixWidth = settings[&quot;Fix width&quot;];\n\nconst textPadding = 10;\nconst text = await utils.inputPrompt(&quot;Text?&quot;);\nconst elements = ea.getViewSelectedElements();\nconst isFirst = (!elements || elements.length === 0);\n\nconst width = ea.measureText(&quot;w&quot;.repeat(wrapLineLen)).width;\n\nlet id = &quot;&quot;;\n\nif(!isFirst) &#123;\n  const fromElement = ea.getLargestElement(elements);\n  ea.copyViewElementsToEAforEditing([fromElement]);\n\n  const previousTextElements = elements.filter((el)=&gt;el.type===&quot;text&quot;);\n  const previousRectElements = elements.filter((el)=&gt; [&#39;ellipse&#39;, &#39;rectangle&#39;, &#39;diamond&#39;].includes(el.type));\n  if(previousTextElements.length&gt;0) &#123;\n    const el = previousTextElements[0];\n    ea.style.strokeColor = el.strokeColor;\n    ea.style.fontSize    = el.fontSize;\n    ea.style.fontFamily  = el.fontFamily;\n  &#125;\n\n    textWidth = ea.measureText(text).width;\n\n  id = ea.addText(\n    fixWidth\n    ? fromElement.x+fromElement.width/2-width/2\n    : fromElement.x+fromElement.width/2-textWidth/2-textPadding,\n    fromElement.y+fromElement.height+gapBetweenElements,\n    text,\n    &#123;\n      wrapAt: wrapLineLen,\n      textAlign: &quot;center&quot;,\n      textVerticalAlign: &quot;middle&quot;,\n      box: previousRectElements.length &gt; 0 ? previousRectElements[0].type : false,\n      ...fixWidth\n      ? &#123;width: width, boxPadding:0&#125;\n      : &#123;boxPadding: textPadding&#125;\n    &#125;\n  );\n\n  ea.connectObjects(\n    fromElement.id,\n    null,\n    id,\n    null,\n    &#123;\n      endArrowHead: arrowEnd,\n      startArrowHead: arrowStart,\n      numberOfPoints: linePoints\n    &#125;\n  );\n\n  if (previousRectElements.length&gt;0) &#123;\n    const rect = ea.getElement(id);\n    rect.strokeColor = fromElement.strokeColor;\n    rect.strokeWidth = fromElement.strokeWidth;\n    rect.strokeStyle = fromElement.strokeStyle;\n    rect.roughness = fromElement.roughness;\n    rect.roundness = fromElement.roundness;\n    rect.strokeSharpness = fromElement.strokeSharpness;\n    rect.backgroundColor = fromElement.backgroundColor;\n    rect.fillStyle = fromElement.fillStyle;\n    rect.width = fromElement.width;\n    rect.height = fromElement.height;\n  &#125;\n\n  await ea.addElementsToView(false,false);\n&#125; else &#123;\n  id = ea.addText(\n    0,\n    0,\n    text,\n    &#123;\n      wrapAt: wrapLineLen,\n      textAlign: &quot;center&quot;,\n      textVerticalAlign: &quot;middle&quot;,\n      box: &quot;rectangle&quot;,\n      boxPadding: textPadding,\n          ...fixWidth?&#123;width: width&#125;:null\n    &#125;\n  );\n  await ea.addElementsToView(true,false);\n&#125;\n\nea.selectElementsInView([ea.getElement(id)]);\n\n","slug":"Add Next Step in Process","date":"2023-07-29T10:00:19.201Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"001fd04c919b8fa23e01b328b79ea28a","title":"Add Link to New Page and Open","content":"&#x2F;*\nPrompts for filename. Offers option to create and open a new Markdown or Excalidraw document. Adds link pointing to the new file, to the selected objects in the drawing. You can control in settings to open the file in the current active pane or an adjacent pane.\n*/\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.6.1&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nsettings = ea.getScriptSettings();\n\nif(!settings[&quot;Open link in active pane&quot;]) &#123;\n  settings = &#123;\n    &quot;Open link in active pane&quot;: &#123;\n      value: false,\n      description: &quot;Open the link in the current active pane (on) or a new pane (off).&quot;\n    &#125;,\n    ...settings\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125;\n\nconst openInCurrentPane = settings[&quot;Open link in active pane&quot;].value;\n\nelements = ea.getViewSelectedElements();\nif(elements.length === 0) &#123;\n  new Notice(&quot;No selected elements&quot;);\n  return;\n&#125;\n\nconst activeFile = ea.targetView.file;\nconst prefix = activeFile.basename;\nconst timestamp = moment(Date.now()).format(ea.plugin.settings.drawingFilenameDateTime);\n\nlet fileType = &quot;&quot;;\nconst filename = await utils.inputPrompt (\n  &quot;Filename for new document&quot;,\n  &quot;&quot;,\n  `$&#123;prefix&#125; - $&#123;timestamp&#125;`,\n  [\n    &#123;\n      caption: &quot;Markdown&quot;,\n      action: ()=&gt;&#123;fileType=&quot;md&quot;;return;&#125;\n        &#125;,\n    &#123;\n      caption: &quot;Excalidraw&quot;,\n      action: ()=&gt;&#123;fileType=&quot;ex&quot;;return;&#125;\n    &#125;\n  ]\n);\n\nif(!filename || filename === &quot;&quot;) return;\nconst filepath = activeFile.path.replace(activeFile.name,`$&#123;filename&#125;.md`);\n\nconst file = await app.fileManager.createNewMarkdownFileFromLinktext(filepath);\nif(file &amp;&amp; fileType===&quot;ex&quot;) &#123;\n  const blank = await app.plugins.plugins[&quot;obsidian-excalidraw-plugin&quot;].getBlankDrawing();\n  await app.vault.modify(file,blank);\n  await new Promise(r =&gt; setTimeout(r, 100)); //wait for metadata cache to update, so file opens as excalidraw\n&#125;\n\nconst link = `[[$&#123;app.metadataCache.fileToLinktext(file,ea.targetView.file.path,true)&#125;]]`;\n\nea.style.backgroundColor = &quot;transparent&quot;;\nea.style.strokeColor = &quot;rgba(70,130,180,0.05)&quot;\nea.style.strokeWidth = 2;\nea.style.roughness = 0;\n\nif(elements.length===1 &amp;&amp; elements[0].type !== &quot;text&quot;) &#123;\n  ea.copyViewElementsToEAforEditing(elements);\n    ea.getElements()[0].link = link;\n&#125; else &#123;\n  const b = ea.getBoundingBox(elements);\n  const id = ea.addEllipse(b.topX+b.width-5, b.topY, 5, 5);\n  ea.getElement(id).link = link;\n  ea.copyViewElementsToEAforEditing(elements);\n  ea.addToGroup(elements.map((e)=&gt;e.id).concat([id]));\n&#125;\nawait ea.addElementsToView(false,true,true);\nea.selectElementsInView(ea.getElements());\n\nif(openInCurrentPane) &#123;\n    app.workspace.openLinkText(file.path,ea.targetView.file.path,false);\n  return;\n&#125;\nea.openFileInNewOrAdjacentLeaf(file);\n\n","slug":"Add Link to New Page and Open","date":"2023-07-29T10:00:19.199Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"6c8693e3bb97385ad768b100b787be72","title":"Add Link to Existing File and Open","content":"&#x2F;*\nPrompts for a file from the vault. Adds a link to the selected element pointing to the selected file. You can control in settings to open the file in the current active pane or an adjacent pane.\n*/\n\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nsettings = ea.getScriptSettings();\n\nif(!settings[&quot;Open link in active pane&quot;]) &#123;\n  settings = &#123;\n    &quot;Open link in active pane&quot;: &#123;\n      value: false,\n      description: &quot;Open the link in the current active pane (on) or a new pane (off).&quot;\n    &#125;,\n    ...settings\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125;\n\nconst openInCurrentPane = settings[&quot;Open link in active pane&quot;].value;\n\nelements = ea.getViewSelectedElements();\nif(elements.length === 0) &#123;\n  new Notice(&quot;No selected elements&quot;);\n  return;\n&#125;\n\nconst files = app.vault.getFiles()\nconst filePaths = files.map((f)=&gt;f.path);\nfile = await utils.suggester(filePaths,files,&quot;Select a file&quot;);\n\nif(!file) return;\n\nconst link = `[[$&#123;app.metadataCache.fileToLinktext(file,ea.targetView.file.path,true)&#125;]]`;\n\nea.style.backgroundColor = &quot;transparent&quot;;\nea.style.strokeColor = &quot;rgba(70,130,180,0.05)&quot;\nea.style.strokeWidth = 2;\nea.style.roughness = 0;\n\nif(elements.length===1 &amp;&amp; elements[0].type !== &quot;text&quot;) &#123;\n  ea.copyViewElementsToEAforEditing(elements);\n    ea.getElements()[0].link = link;\n&#125; else &#123;\n  const b = ea.getBoundingBox(elements);\n  const id = ea.addEllipse(b.topX+b.width-5, b.topY, 5, 5);\n  ea.getElement(id).link = link;\n  ea.copyViewElementsToEAforEditing(elements);\n  ea.addToGroup(elements.map((e)=&gt;e.id).concat([id]));\n&#125;\nawait ea.addElementsToView(false,true,true);\nea.selectElementsInView(ea.getElements());\n\nif(openInCurrentPane) &#123;\n    app.workspace.openLinkText(file.path,ea.targetView.file.path,false);\n  return;\n&#125;\nea.openFileInNewOrAdjacentLeaf(file);\n\n","slug":"Add Link to Existing File and Open","date":"2023-07-29T10:00:19.197Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"c8e3fb38b6d2af41db47c72f8a1e7c96","title":"Add Connector Point","content":"&#x2F;*\nThis script will add a small circle to the top left of each text element in the selection and add the text and the “bullet point” into a group.\nSee documentation for more details:https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\n*/\nelements = ea.getViewSelectedElements().filter((el)=&gt;el.type===&quot;text&quot;);\nea.copyViewElementsToEAforEditing(elements);\nconst padding = 10;\nelements.forEach((el)=&gt;&#123;\n  ea.style.strokeColor = el.strokeColor;\n  const size = el.fontSize/2;\n  const ellipseId = ea.addEllipse(\n    el.x-padding-size,\n    el.y+size/2,\n    size,\n    size\n  );\n  ea.addToGroup([el.id,ellipseId]);\n&#125;);\nea.addElementsToView(false,false);\n\n","slug":"Add Connector Point","date":"2023-07-29T10:00:19.194Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"03a3fa960e2b0d59ac84b58f99a0db0d","title":"背景图片固定在页面","content":"#CSS #HTML\nbody &#123; \n\tbackground-image: url('your-background-image.jpg'); \n\tbackground-attachment: fixed; \n&#125;\n\n将文字固定到页面中，不随文字滚动而移动。背景图像不会影响文档流，适用于在背景中显示图片或图案，而不影响页面其他元素的滚动行为。\n注意事项固定背景图像可能在某些移动设备上表现不佳，因为某些移动设备可能不支持固定背景图像或支持有限。最好在移动设备上测试效果，确保页面正常显示。\n当页面内容超过背景图像的尺寸时，可能会出现重复的情况。你可以使用 background-repeat 属性来控制是否重复背景图像，或者使用 background-size 属性来调整背景图像的大小。\n","slug":"背景图片固定在页面","date":"2023-07-29T10:00:19.170Z","categories_index":"","tags_index":"CSS,HTML","author_index":"Devmacy"},{"id":"f5e5bbca00637a6a93950ae37f470129","title":"全屏布局","content":"#HTML实现一个全屏布局\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n  &lt;title>全屏布局示例&lt;/title>\n  &lt;style>\n    /* 设置html和body元素的高度和边距为0，确保内容铺满整个屏幕 */\n    html, body &#123;\n      height: 100%;\n      margin: 0;\n    &#125;\n\n    /* 创建一个全屏容器，并设置其高度为100% */\n    .fullscreen-container &#123;\n      height: 100%;\n      background-color: #fff0f0; /* 设置背景颜色，用于示例 */\n      /* 添加其他样式，以实现所需的布局效果 */\n    &#125;\n  &lt;/style>\n&lt;/head>\n&lt;body>\n  &lt;div class=\"fullscreen-container\">\n    &lt;!-- 在这里添加页面的其他内容 -->\n    123\n  &lt;/div>\n&lt;/body>\n&lt;/html>\n","slug":"全屏布局","date":"2023-07-29T10:00:19.123Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"afe50561fe4a5c77cfc0770647e83e31","title":"Vue3 异步加载组件","content":"#Vue  \n使用 dynamic import（动态导入）来异步加载组件\n用法// 导入\nimport &#123; defineAsyncComponent &#125; from 'vue';\n\n// 定义组件\nconst componentA = defineAsyncComponent(()=> import('./path/componentA'))\n\n// 在模板或其他地方使用异步组件\n&lt;template>\n  &lt;div>\n    &lt;AsyncComponent />\n  &lt;/div>\n&lt;/template>\n\n在其他地方使用组件的时候，vue 自动下载和加载组件\n异步加载对 SEO 的影响搜索引擎爬虫需要能够访问到完整的页面内容。由于异步加载组件在初始渲染时可能不会包含完整的组件代码，这可能导致搜索引擎无法正确解析和索引你的网页。\nVue3 处理异步组件对 SEO 的影响\n预渲染（Prerendering）: 在构建过程中，使用工具如 @vue/cli 或 prerender-spa-plugin 将应用程序预先生成为静态 HTML 文件。这样可以确保所有内容都被渲染并可供搜索引擎爬虫访问。当用户访问该页面时，浏览器将下载并执行与动态部分交互所需的 JavaScript 代码。\n服务端渲染（Server-side Rendering, SSR）: 如果你正在使用 Vue 3 进行服务器端渲染 (SSR)，则不必担心异步加载对 SEO 的影响。在 SSR 环境中，所有组件都会在服务器上进行完全渲染，并且最终返回给客户端一个已经包含了所有内容的 HTML 文档。\n\n","slug":"Vue3 异步加载组件","date":"2023-07-29T10:00:19.108Z","categories_index":"","tags_index":"Vue","author_index":"Devmacy"},{"id":"36411759ccbfccce1a6816dc4b2c5374","title":"Tailwind CSS","content":"#CSS\n\n\n\n\n\n\n\n\n\nTailwind CSS 的工作原理是扫描所有 HTML 文件、JavaScript 组件以及任何 模板中的 CSS 类（class）名，然后生成相应的样式代码并写入 到一个静态 CSS 文件中。\n介绍Tailwind CSS 通过使用类名来快速创建样式，不需要再为各种类命名犯难。直接在 HTML 标签上添加 class 使用 Tailwind CSS 内置样式，不再需要编写 CSS。\n形式同内联样式，但是有自己的约束和规则，每一个数字都用自己的意义。\n官网：[Tailwind CSS](&lt;https://www.tailwindcss.cn)\n特点\n原子化\n响应式\n自定义\n\n使用// 白色背景，文字居中\n&lt;div class=\"bg-white text-center\">\n&lt;/div>\n","slug":"Tailwind CSS","date":"2023-07-29T10:00:19.081Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"7e610dd6e9dad7ead9ac0f2ade9ff0ed","title":"CSS 单位","content":"#CSS\n常见单位px%rem（相对单位）是相对于根元素（html）字体大小，根元素一般是 font-size:16px\nem（相对单位）相对于父元素字体大小的单位\nvw（视窗）vw 表示视口宽度的百分比\nvh（视窗）vh 表示视口高度的百分比\nvmin（视窗）vmin 表示 vw 和 vh 中较 小 的一个\nvmax（视窗）vmax 表示 vw 和 vh 中较 大 的一个\ns（秒）ms（毫秒）不常见单位pt（点）打印样式表中使用的点阵单位\ncm（厘米）在某些特定情况下可能使用\nch（字符）表示字符 “0” 的宽度，用于基于字体宽度的布局\npc（十六分之一英寸）打印样式表中使用的单位，等于 12 点\ngr（格）打印样式表中的计量单位\n","slug":"CSS 单位","date":"2023-07-29T10:00:18.997Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"3a8c68d86937feef9dc62abaee2ea7e5","title":"CSS sprites","content":"#CSS\nCSS sprites 是一种优化网页加载速度的技术，通过将多个小图标或图片合并成一个大图，然后利用 CSS 的 background-position 属性来显示需要的部分。这样可以减少页面的 HTTP 请求次数，从而提高网页加载性能。又称为 _雪碧图&#x2F;精灵图_。\n如果有很多小图标，但是文件都很小，每次请求都得请求很多次，增加加载时间，将时间都浪费在请求上，使用 CSS sprites，只需要请求一次，使用 background-position 属性更改位置即可\n优点\n减少 HTTP 请求次数和时间\n优化了性能\n增加了用户体验\n\n\n\n缺点\n需要小心设置合适的 position 确保正确显示。\n高分辨率屏幕（如 [[Retina]] 屏幕），可能需要提供不同尺寸的 CSS sprites 来适应不同的设备\n如果小图标变化频繁，更新 CSS sprites 可能会比较麻烦。\n\n在线 CSS sprites 网站CSS sprites\n","slug":"CSS sprites","date":"2023-07-29T10:00:18.995Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"a5f3e5a33c203fe5567fa7f5e9e879b1","title":"createElement、cloneElement","content":"#React\ncreateElement创建新元素的方法\nconst element = \n\t  React.createElement(\n\t  'div', &#123; className: 'container' &#125;, 'Hello, World!');\n\ncloneElement克隆元素的方法，并可以修改其属性或添加&#x2F;删除子节点。\nconst originalElement = \n\t  &lt;div className=\"container\">Hello, World!&lt;/div>; \n\t  \nconst modifiedElement = \n\t  React.cloneElement(\n\t  originalElement, &#123; className: 'new-container' &#125;);\n","slug":"createElement、cloneElement","date":"2023-07-29T10:00:18.994Z","categories_index":"","tags_index":"React","author_index":"Devmacy"},{"id":"af41065be6ea110fa9fea565afd0ee99","title":"鼠标事件","content":"#JavaScript\n类别\n\n\n项目\nValue\n\n\n\nclick\n当定点设备的按钮（通常是鼠标的主键）在一个 [[元素]] 上被按下和放开时，事件就会被触发\n\n\ndbclick\n在单个元素上单击两次鼠标的指针设备按钮 (通常是小鼠的主按钮) 时，将触发事件。\n\n\nmousedown\n定点设备（如鼠标或触摸板）按钮在元素内按下时触发\n\n\nmouseout\n定点设备（通常是鼠标）移动至元素或其子元素之外时，在该元素上触发\n\n\nmouseover\n当一个定点设备（通常指鼠标）在一个元素本身或者其子元素上移动时，在该元素上触发\n\n\nmouseup\n定点设备（如鼠标或触摸板）按钮在元素内释放时，在该元素上触发。\n\n\nmousemove\n定点设备（通常指鼠标）的光标在元素内移动时，会在该元素上触发\n\n\nmouseenter\n定点设备（通常指鼠标）首次移动到元素的激活区域上，在该元素\n\n\n","slug":"鼠标事件","date":"2023-07-07T17:47:16.199Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"c7c6c82bd7a132708f95cb19d243af4d","title":"限制爬虫","content":"#HTML\nrobots 协议对于一些搜索引擎的爬虫，例如百度、谷歌，只需要在网站根目录放置一个 ASCII 编码的文件，告诉搜索引擎哪些页面不能爬取。\nuser-agent","slug":"限制爬虫","date":"2023-07-07T17:47:16.197Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"928ea0d23680bec53604e41625da0e79","title":"键盘事件","content":"#JavaScript\n类别keydown触发于键盘按下时，所有按键均会触发 keydown 事件，无论是否输出字符不同于 keypress\nkeypress 已废弃 当按下产生字符或符号值的键时，将触发 keypress 事件\nkeyup按键松开时触发\n","slug":"键盘事件","date":"2023-07-07T17:47:16.195Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"851fe8daff38ce52dc3afa53dfe51a8f","title":"钩子函数","content":"生命周期钩子函数[[路由]] 导航&#x2F;[[路由]] 守卫钩子函数自定义指令 Directive 钩子函数广义上的钩子函数\nwatch\n响应数据的变化\n变量的监听\n\n\ncomputed\n\n","slug":"钩子函数","date":"2023-07-07T17:47:16.193Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"2e484347b2b13cd043a9bbab6461bacd","title":"酸梅汤","content":"原材料\n山楂 63g\n甘草 3g\n薄荷 1g\n陈皮 15g\n枸杞 5g\n洛神花 13g\n桑葚 13g\n干桂花 1g\n水 10 斤\n冰糖 380g\n\n步骤\n原材料冲洗干净，纱布包裹\n凉水下锅，浸泡半小时\n开火熬制，大火烧开，微小火慢熬 40 分钟（禁用铁锅）\n料包捞出，加入冰糖搅拌\n容器中，桂花垫底，加入煮好的水\n放凉后冷藏 3 小时\n\n","slug":"酸梅汤","date":"2023-07-07T17:47:16.191Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"f954487fe515798e7a6e0ffb467c686f","title":"路由","content":"跳转方式\nroute-link\nthis.$router.push()\nthis.$router.replace()\n\n路由守卫全局路由守卫\nbeforeEach 全局前置守卫\nbeforeResolve 全局解析守卫\nafterEach 全局后置守卫\n\n单个路由守卫\nbeforeEnter\n\n组件路由守卫\nbeforeRouterEnter\nbeforeRouterUpdate\nbeforeRouterLeave\n\n嵌套路由\n使用 children\n\n懒加载\n配置路由实现\n\n重定向&#123;path:\"/\",redirect:\"home\"&#125;\n","slug":"路由","date":"2023-07-07T17:47:16.189Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"d4e24b03121e4cbb80dd991a8a866873","title":"赛博朋克灵牌","content":"材料墨水屏\n2.9 寸\n无驱动板\n分类\n威峰\nhink\n\n\n\nBOM\n贴片电阻\n驱动板\nesp32c3\n淘宝购买\n经典款\n\n\n底座\nNDK&#x2F;TAT 野口总线插座 PCB 金手指插座\n淘宝购买\n\n\n\n程序Arduino烧录程序\nesptool\n无需修改版\n\n\n\n","slug":"赛博朋克灵牌","date":"2023-07-07T17:47:16.187Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"174af5369df658c708e4ac6b59c60cb4","title":"贝赛尔曲线","content":"定义\n\n\n\n\n\n\n\n\nBézier curve(贝塞尔曲线) 是应用于二维图形应用程序的数学曲线\n伯恩斯坦多项式\n\n\n\n\n\n\n\n\n可以用来证明，在 [a, b] 区间上所有的连续函数都可以用多项式来逼近，并且收敛性很强，也就是一致收敛\n拟合原理-AD/AB = BE/BC = DF/DE\n","slug":"贝赛尔曲线","date":"2023-07-07T17:47:16.185Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"c87aeab67940360853b19fd40dd01a68","title":"设计文档","content":"待办\n 创建项目\n 创建别名\n\n功能\n功能聚合网站\n新奇创意\n\n技术栈\n构建工具：vite\n前端框架：vue3\n编程语言：typescript\n[[路由]] 工具：vuerouter\n状态管理：Pinia\nUI 框架：ElementUI Plus\nHTTP 工具：Axios\nCSS 预编译：**[[Sass]]**\n自动部署：Github Actions\n编码规范：standard-with-typescript\n代码测试：vitest\n代码检查：eslint\n\n命名规范文件夹命名多个单词小驼峰\n单个单词小驼峰\n文件命名组件大驼峰\n其他 小驼峰\n颜色组页面布局项目目录\nrouter 路由文件夹\ncomponents 公共组件文件夹\nlayout 页面布局文件夹\n\n\nviews 页面文件夹\ncomponents 页面组件文件夹\n\n\nstore 状态管理文件夹\nconfig 项目公共配置文件夹\nutils 工具文件夹\ntest 测试文件夹\nstyles 公共样式文件夹\napi 接口文件夹\nassets 资源文件夹\n@types 类型文件夹\n\n","slug":"设计文档","date":"2023-07-07T17:47:16.182Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"a8c55f11a67107e06781ca4751b6c9dc","title":"记录用户操作轨迹","content":"记录用户操作轨迹涉及用户隐私问题，您应该在收集和存储用户数据时遵循适当的隐私政策，并确保对数据进行安全保护。此外，在实施此功能之前，建议与法律和隐私专家进行咨询，以确保您的实施符合适用的法律要求\n记录前端监控添加监控脚本，捕获用户交互行为，例如点击，滚动，输入，并将信息发送到服务端进行存储\n后端存储在服务器端创建一个数据库或日志文件来存储用户操作轨迹数据。使用数据库管理系统（例如 MySQL、MongoDB）或文件系统（例如日志文件）来存储用户操作的详细信息，例如时间戳、页面 URL、操作类型等。\n还原按照存储的时间顺序进行还原，使用 JavaScript 等 API 模拟户的点击或输入等操作。\n","slug":"记录用户操作轨迹","date":"2023-07-07T17:47:16.180Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"cd55e9d94b94ab2ca447027ce4beeca6","title":"观察者模式","content":"#DesignPattern\n定义当事件发生时，通过可观察对象通知订阅者\n可观察对象将某些对象（观察者模式）订阅到另一个对象\n三个要素","slug":"观察者模式","date":"2023-07-07T17:47:16.178Z","categories_index":"","tags_index":"DesignPattern","author_index":"Devmacy"},{"id":"12dd0582b81172220ef6d0da436b7faa","title":"网址","content":"\nemoij大全\n\n","slug":"网址","date":"2023-07-07T17:47:16.176Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"9aae254f3b5900ef3a6f68a26f87a6de","title":"继承属性","content":"#CSS\n无继承性属性\ndisplay\n\n文本属性\nvertical-align：垂直文本对齐\ntext-decoration：规定添加到文本的装饰\ntext-shadow：文本阴影效果\nwhite-space：空白符的处理\nunicode-bidi：设置文本的方向\n\n盒子模型属性   width、height、margin、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left\n背景属性   background、background-color、background-image、background-repeat、background-position、background-attachment\n定位属性   float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index\n生成内容属性   content、counter-reset、counter-increment\n轮廓样式属性   outline-style、outline-width、outline-color、outline\n页面样式属性  size、page-break-before、page-break-after\n声明样式属性  pause-before、pause-after、pause、cue-before、cue-after、cue、play-during\n有继承性属性字体系列属性\nfont：组合字体\nfont-family：规定元素的字体系列\nfont-weight：设置字体的粗细\nfont-size：设置字体的尺寸\nfont-style：定义字体的风格\nfont-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。\nfont-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。\nfont-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。\n\n文本系列属性\ntext-indent：文本缩进\ntext-align：文本水平对齐\nline-height：行高\nword-spacing：增加或减少单词间的空白（即字间隔）\nletter-spacing：增加或减少字符间的空白（字符间距）\ntext-transform：控制文本大小写\ndirection：规定文本的书写方向\ncolor：文本颜色\n\n元素可见属性\nvisibility\n\n表格布局属性\ncaption-side\nborder-collapse\nborder-spacing\nempty-cells\ntable-layout\n\n列表内容属性\nlist-style-type\nlist-style-image\nlist-style-position\nlist-style\n\n生成内容属性\nquotes\n\n光标属性\ncursor\n\n页面样式属性\npage\npage-break-inside\nwindows\norphans\n\n声音样式属性\nspeak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation\n\n所有元素可以继承的属性元素可见性\nvisibility\n\n光标属性\ncursor\n\n内联元素可以继承的属性字体系列属性\n除 text-indent、text-align 之外的文本系列属性\n\n块级元素可以继承的属性\ntext-indent\ntext-align\n\n","slug":"继承属性","date":"2023-07-07T17:47:16.174Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"d25cc4c1d3f32527fe0f2d663779b94f","title":"绝对定位","content":"#CSS\n\n\n\n\n\n\n\n\n\n设置为绝对定位的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。\n","slug":"绝对定位","date":"2023-07-07T17:47:16.172Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"5fde7d8dfbaede438153d7eedc66411c","title":"组件通信","content":"#Vue\nprops 传值\n子父\n子父父\n子父父父\n\n消息订阅与发布vuex全局事件总线","slug":"组件通信","date":"2023-07-07T17:47:16.170Z","categories_index":"","tags_index":"Vue","author_index":"Devmacy"},{"id":"08f7c8394351bf7006086263a2e6d01f","title":"类选择器","content":"#CSS\n","slug":"类选择器","date":"2023-07-07T17:47:16.168Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"4c2098f134f57bee773a0f79b7ecd25b","title":"相对定位","content":"#CSS\n\n\n\n\n\n\n\n\n\n设置为相对定位的元素框会偏移某个距离。元素仍然保持其未定位前的形状，它原本所占的空间仍保留。\n","slug":"相对定位","date":"2023-07-07T17:47:16.166Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"be856977b62f87772a3dfd91fa74eb3d","title":"浏览器刷新","content":"#HTML\n右键刷新Normal Reload（Ctrl+R）: 正常刷新，使用缓存数据\nF5Normal Reload（Ctrl+R）: 正常刷新，使用缓存数据\nCtrl+F5Hard Reload（Ctrl +shift +R）: 硬刷新，不会使用缓存，重新下载内容\n地址栏回车Hard Reload（Ctrl +shift +R）: 硬刷新，不会使用缓存，重新下载内容\n","slug":"浏览器刷新","date":"2023-07-07T17:47:16.164Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"143abe150ddd04d10f6af0f5c7143f57","title":"浅比较","content":"源码class App extends PureComponent &#123;  \n    constructor(props) &#123;  \n        super(props);  \n        this.state &#x3D; &#123;  \n            data: &#123;  \n                number: 0  \n            &#125;  \n        &#125;  \n    &#125;  \n  \n    render() &#123;  \n        const &#123;data&#125; &#x3D; this.state  \n  \n        return (  \n            &lt;div className&#x3D;&quot;App&quot;&gt;  \n                &lt;div&gt;数字 &#123;data.number&#125;&lt;&#x2F;div&gt;  \n                &lt;Button type&#x3D;&#123;&quot;primary&quot;&#125; onClick&#x3D;&#123;() &#x3D;&gt; &#123;  \n                    const &#123;data&#125; &#x3D; this.state  \n                    ++data.number\n                    &#x2F;&#x2F;关键代码\n                    this.setState(&#123;data: &#123;...data&#125;&#125;)  \n                    &#x2F;&#x2F; this.seState(&#123;data&#125;)\n                    &#x2F;&#x2F; 这样写不能触发更新\n                &#125;&#125;&gt;点击加1&lt;&#x2F;Button&gt;  \n            &lt;&#x2F;div&gt;  \n        )  \n    &#125;  \n&#125;  \n  \nexport default App\n","slug":"浅比较","date":"2023-07-07T17:47:16.161Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"bf71748b5d2437830cd4335ba6636a53","title":"标签选择器","content":"#CSS\n","slug":"标签选择器","date":"2023-07-07T17:47:16.159Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"934c3e7f2ec87b47bc5149b454ee51cf","title":"文档预解析","content":"#HTML\n传统浏览器html 解析器（运行于主线程），遇到 script 标签后，js 下载完成后才继续执行\n预解析从主线程分离出来，渲染引擎接受字节流的之后，开启一个预解析线程，读取到 js 和 css 文件，会提前下载这些文件\n","slug":"文档预解析","date":"2023-07-07T17:47:16.158Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"93784a2946001c51b36ef4686c7986dd","title":"提供者模式","content":"#DesignPattern\n","slug":"提供者模式","date":"2023-07-07T17:47:16.155Z","categories_index":"","tags_index":"DesignPattern","author_index":"Devmacy"},{"id":"2b626aa264ea039f2851016a87f0e616","title":"扫雷","content":"\n设计样式\n设计逻辑\n设计配置项\n\n","slug":"扫雷","date":"2023-07-07T17:47:16.153Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"9ba583b7ea3992ae2bb474a82ee925b9","title":"布局时对浏览器兼容性的感受和总结","content":"#HTML #CSS在写布局时，考虑到浏览器兼容性是一个非常重要的因素。不同浏览器对于 CSS 和 HTML 的解析和渲染方式可能会有细微的差异，这可能导致在不同浏览器上呈现的效果不同。这对于前端开发者来说是一个挑战，需要确保网站在主流浏览器上都能够正常显示和良好呈现。\n总结以下几点\n了解不同浏览器的差异：首先，了解主流浏览器（如 Chrome、Firefox、Safari 和 Edge）的最新版本对于 CSS 和 HTML 的支持情况非常重要。这可以通过查阅各浏览器的官方文档或者一些兼容性查询工具来获取。了解这些差异可以帮助我们知道在哪些方面需要特别注意和处理兼容性问题。\n使用标准化的技术：尽量使用符合 W3C 标准的 HTML 和 CSS 代码。这样可以增加网页在各种浏览器上一致性的可能性。遵循最佳实践和规范的编码方式可以降低出现兼容性问题的风险。\n逐步增强和渐进优化：当编写布局时，考虑使用渐进增强和优雅降级的原则。这意味着首先构建基本的功能和布局，确保其在所有浏览器上正常运行，然后再逐步添加更高级的特性和样式，以增强用户体验。这种方法可以确保即使在不支持某些特性的旧浏览器上，网站仍然能够正常运行。\n测试和调试：在布局完成后，对网站在不同浏览器和设备上进行全面的测试是至关重要的。这可以帮助我们发现并解决潜在的兼容性问题。在调试过程中，可以使用浏览器的开发者工具来检查元素和样式的渲染情况，并模拟不同浏览器环境。\n使用兼容性库和工具：有一些工具和库可以帮助我们处理浏览器兼容性问题，例如 Normalize.css 和 Autoprefixer。Normalize.css 可以帮助我们在不同浏览器上消除默认样式的差异，而 Autoprefixer 可以自动为 CSS 添加浏览器前缀，以确保样式在各个浏览器上生效。\n\n","slug":"布局时对浏览器兼容性的感受和总结","date":"2023-07-07T17:47:16.150Z","categories_index":"","tags_index":"CSS,HTML","author_index":"Devmacy"},{"id":"e2c8eebdf8a765a71511efc218994836","title":"容器-展示模式","content":"#DesignPattern\n概念关注点分离将 视图 和 逻辑 分离来实现关注点分离\n\nReact 实现关注点分离示例创建一个应用获取 6 张狗狗的图片\n展示组件 Presentational Components: 关注 如何 向用户渲染图像\n容器组件 Container Components: 关注向用户渲染 哪些 图像\n\n","slug":"容器-展示模式","date":"2023-07-07T17:47:16.148Z","categories_index":"","tags_index":"DesignPattern","author_index":"Devmacy"},{"id":"1647ed76880dab1338d8b2b4b71b1acb","title":"大数据","content":"\n\n\n\n\n\n\n\n\n大数据 (big data)，或称巨量资料，指的是所涉及的资料量规模巨大到无法透过主流软件工具，在合理时间内达到撷取、管理、处理、并整理成为帮助企业经营决策更积极目的的资讯\n定义\n\n\n\n\n\n\n\n\n大数据 “ 是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力来适应海量、高增长率和多样化的信息资产。\n单位bit、Byte、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB\n进制1024\n","slug":"大数据","date":"2023-07-07T17:47:16.146Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"8dba26aa221228080b3f43d1b95e7f2f","title":"垃圾回收","content":"#JavaScript\n标记清理\n标记\n存在于上下文\n离开上下文\n\n\n\n引用计数\n引用数为 0\n不在使用\n\n\n赋值➕1\n覆盖 -1\n\n","slug":"垃圾回收","date":"2023-07-07T17:47:16.144Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"c0e85f25e9d060f86e4456101c7a0cf3","title":"固定定位","content":"#CSS\n\n\n\n\n\n\n\n\n\n固定定位相对于浏览器窗口，脱离文档流，使用 fixed 的元素不会随窗口的滚动而滚动\n","slug":"固定定位","date":"2023-07-07T17:47:16.142Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"65a35123ebd4ea14b0c8cc20264340b4","title":"回调函数","content":" #JavaScript\n A(传入形参1, 传入形参2, 函数B() &#123;\n这里是函数B的实现方法体\n&#125;)\n","slug":"回调函数","date":"2023-07-07T17:47:16.139Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"6bab6449311bdfee58fe8f69412569fc","title":"变换","content":"#CSS\nrotateY定义沿 Y 轴的 3D 效果，可以实现翻书效果\ntranslateY沿着 Y 轴移动元素\nscaleY沿着 Y 轴矢量缩放\nperspective（n）透视\n","slug":"变换","date":"2023-07-07T17:47:16.137Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"988fd4666f6975e6592358be873f834a","title":"原型模式","content":"#DesignPattern\n概念\n许多同类型对象间共享属性的方式\nJavaScript 原生对象（原型链）\n\n创建多个同类对象  class Dog &#123;\nconstructor(name) &#123;\nthis.name = name;\n&#125;\n\nbark() &#123;\nreturn `Woof!`;\n&#125;\n&#125;\n\nconst dog1 = new Dog(\"Daisy\");\nconst dog2 = new Dog(\"Max\");\nconst dog3 = new Dog(\"Spot\");\n\n访问原型\n通过访问类的 prototype 属性\n对象实例的 __proto__ 属性\n\n用法 console.log(Dog.prototype);\n// constructor: ƒ Dog(name, breed) bark: ƒ bark()\n\nconsole.log(dog1.__proto__);\n// constructor: ƒ Dog(name, breed) bark: ƒ bark()\n\n在原型上添加属性（可以在创建实例后）示例  class Dog &#123;\n constructor(name) &#123;\n  this.name = name;\n &#125;\n\n bark() &#123;\n  return `Woof!`;\n &#125;\n&#125;\n\nconst dog1 = new Dog(\"Daisy\");\nconst dog2 = new Dog(\"Max\");\nconst dog3 = new Dog(\"Spot\");\n\nDog.prototype.play = () => console.log(\"Playing now!\");\n\ndog1.play();\n\n继承创建一个超级狗class SuperDog extends Dog &#123;\n\tconstructor (name) &#123;\n\t\tsuper(name)\n\t&#125;\n\n\tfly () &#123;\n\t\treturn \"Flying!\"\n\t&#125;\n&#125;\n\nconst dog1 = new SuperDog(\"Daisy\");\ndog1.bark();\ndog1.fly();\n\n\nObject.create()Object.create() 创建一个对象，允许我们显式地将其原型的值传递给它\n示例const dog = &#123;\n  bark() &#123;\n    return `Woof!`;\n  &#125;\n&#125;;\n\nconst pet1 = Object.create(dog);\n\npet1.bark(); // Woof!\n\nconsole.log(\"Direct properties on pet1: \", Object.keys(pet1));\n\nconsole.log(\"Properties on pet1's prototype: \", Object.keys(pet1.__proto__));\n\n优点因为可以通过原型链访问对象没有直接定义的属性，避免了重复的方法和属性，所以可以减少内存的使用\n","slug":"原型模式","date":"2023-07-07T17:47:16.135Z","categories_index":"","tags_index":"DesignPattern","author_index":"Devmacy"},{"id":"5e422a9b2c69bd7294ec71b84cbbb53b","title":"单例模式","content":"#DesignPattern\n","slug":"单例模式","date":"2023-07-07T17:47:16.133Z","categories_index":"","tags_index":"DesignPattern","author_index":"Devmacy"},{"id":"2ee8fc20419cb74b4156b1e1e9a7c1f0","title":"元素","content":"#JavaScript\n定义\n\n\n\n\n\n\n\n\nElement 是一个通用性非常强的基类，所有 Document 对象下的对象都继承自它。这个接口描述了所有相同种类的元素所普遍具有的方法和属性。一些接口继承自 Element 并且增加了一些额外功能的接口描述了具体的行为。例如，HTMLElement 接口是所有 HTML 元素的基本接口，而 SVGElement 接口是所有 SVG 元素的基础。大多数功能是在这个类的更深层级（hierarchy）的接口中被进一步制定的。\n","slug":"元素","date":"2023-07-07T17:47:16.131Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"0b0554f0ada234aae0a05a47949d2926","title":"位移运算符","content":"#JavaScript\n&gt;&gt;\n\n\n\n\n\n\n\n\n将一个操作数的二进制表示形式向右移动指定位数，该操作数可以是数值或者 BigInt 类型。\n示例const a = 5;          //  00000000000000000000000000000101\nconst b = 2;          //  00000000000000000000000000000010\nconst c = -5;         //  11111111111111111111111111111011\n\nconsole.log(a >> b);  //  00000000000000000000000000000001\n// Expected output: 1\n\nconsole.log(c >> b);  //  11111111111111111111111111111110\n// Expected output: -2\n\n\n&lt;&lt;\n\n\n\n\n\n\n\n\n将第一个操作数向左移动指定位数，左边超出的位数将会被清除，右边将会补零\n示例const a = 5;         // 00000000000000000000000000000101\nconst b = 2;         // 00000000000000000000000000000010\n\nconsole.log(a &lt;&lt; b); // 00000000000000000000000000010100\n// Expected output: 20\n","slug":"位移运算符","date":"2023-07-07T17:47:16.129Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"26123e1d994cbb50c4dd79f18da5d42a","title":"伪元素","content":"特点\n虚拟容器\n不能通过 [[DOM]] 获取\n不存在 [[DOM]] 文档中\n\n\n只能使用一个伪元素\n\n类别","slug":"伪元素","date":"2023-07-07T17:47:16.127Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"424f199f6c88af138e76cfdf85fb4fa5","title":"代理模式","content":"#DesignPattern\n","slug":"代理模式","date":"2023-07-07T17:47:16.125Z","categories_index":"","tags_index":"DesignPattern","author_index":"Devmacy"},{"id":"99a8a5602a8138c01c896baa1cf371db","title":"websocket","content":"#HTML\n定义\n\n\n\n\n\n\n\n\nWebSockets is a protocol for bi-directional, real-time communication between a client and a server over the World Wide Web. It was designed to work over the same ports (80 and 443) as HTTP and HTTPS, which makes it easier to traverse firewalls and proxy servers. The WebSockets protocol was standardized by the Internet Engineering Task Force (IETF) as part of HTML5 and is supported by modern browsers, including Google Chrome, Mozilla Firefox, Microsoft Edge, and Apple Safari.\n特点\n允许客户端和服务端全双工通信\n服务端可以主动向客户端发送信息\nhttp 协议只能由客户端向服务端发送信息\n\n\n建立在 TCP 协议上\n与 HTTP 协议有很好的兼容性，默认端口 80 和 443\n数据格式轻量\n可以发送文本和二进制数据\n没有同源限制\n协议标识符是 ws\n\nHttp 与 Websocket 区别API构造函数const ws = new WebSocket('ws://localhost:8080');\n\nwebSocket.readyState\n\n\n\n\n\n\n\n\nCONNECTING：值为 0，表示正在连接。OPEN：值为 1，表示连接成功，可以通信了。CLOSING：值为 2，表示连接正在关闭。CLOSED：值为 3，表示连接已经关闭，或者打开连接失败。\nwebSocket.onopen连接成功后的回调函数\nws.onopen = function () &#123;\n  ws.send('Hello Server!');\n&#125;\n\nwebSocket.onclose连接关闭后的回调函数\nws.onclose = function(event) &#123;\n  const code = event.code;\n  const reason = event.reason;\n  const wasClean = event.wasClean;\n  // handle close event\n&#125;;\n\nwebSocket.onmessage接收到服务器信息后的回调函数\nws.onmessage = function(event) &#123;\n  const data = event.data;\n  // data:arraybuffer | string\n  // 处理数据\n&#125;;\n\nwebSocket.binaryType指定接收的二进制数据类型\n// 收到的是 blob 数据\nws.binaryType = \"blob\";\nws.onmessage = function(e) &#123;\n  console.log(e.data.size);\n&#125;;\n\n// 收到的是 ArrayBuffer 数据\nws.binaryType = \"arraybuffer\";\nws.onmessage = function(e) &#123;\n  console.log(e.data.byteLength);\n&#125;;\n\nwebSocket.send()实例发送信息函数\nws.send('your message');\n\nws.send(file:file)\n\nws.send(buffer:arraybuffer)\n\nwebSocket.bufferedAmount实例对象还剩多少二进制数据没有发送\nconst data = new ArrayBuffer(10000000);\nsocket.send(data);\n\nif (socket.bufferedAmount === 0) &#123;\n  // 发送完毕\n&#125; else &#123;\n  // 发送还没结束\n&#125;\n\nwebSocket.onerror指定报错时的回调函数\nsocket.onerror = function(event) &#123;\n  // handle error event\n&#125;;\n\nsocket.addEventListener(\"error\", function(event) &#123;\n  // handle error event\n&#125;);\n","slug":"websocket","date":"2023-07-07T17:47:16.123Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"6b30ca1d6f90b3c88a0e57ca647706ec","title":"watch","content":"#Vue\n","slug":"watch","date":"2023-07-07T17:47:16.121Z","categories_index":"","tags_index":"Vue","author_index":"Devmacy"},{"id":"d060cb49e0aae03d6be79c16ade1b4d8","title":"vue-cli常见加载器","content":"#Vue\n1. CSS Loader处理 css 文件，解析@import 和 url() 语句，运行 JavaScript 中引入 css 文件\n2. Babel Loader将常见的 ES6 转换为浏览器常用的 ES5 语法\n3. Vue Loader加载和解析 vue 文件，转换为 JavaScript 模块\n4. Sass Loadersass&#x2F;scss 预处理器，转换为 CSS\n5. Less Loaderless 预处理器，转换为 CSS\n6. PostCSS Loader允许对 css 文件进行处理，如自动添加浏览器前缀\n7. File Loader处理文件资源，复制到输出目录，并返回路径\n8. URL Loader小于指定大小的文件将会转换为 Base64 编码，以减少 Http 请求\n","slug":"vue-cli常见加载器","date":"2023-07-07T17:47:16.119Z","categories_index":"","tags_index":"Vue","author_index":"Devmacy"},{"id":"aa00fa048ffbfbd0057cd5b16da9e258","title":"video","content":"#HTML\n定义\n\n\n\n\n\n\n\n\nHTML &lt;video&gt;  元素 用于在 HTML 或者 XHTML 文档中嵌入媒体播放器，用于支持文档内的视频播放\n示例&lt;video controls width=\"250\">\n    &lt;source src=\"/media/cc0videos/flower.webm\" type=\"video/webm\">\n&lt;/video>\n\n属性preloadnone不应该预加载\nmetadata优先获取视频的元数据，例如长度\nauto下载整个文件，无论用户是否需要\n","slug":"video","date":"2023-07-07T17:47:16.117Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"5b2670c5f5c997faf561bd54972c13be","title":"UTC","content":"\n\n\n\n\n\n\n\n\n协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。协调世界时是以 原子时秒长为基础\n定义\n\n\n\n\n\n\n\n\n国际原子时的准确度为每日数纳秒，而世界时的准确度为每日数毫秒。许多应用部门要求时间系统接近世界时 UT，对于这种情况，一种称为协调世界时的折中时标于 1972 年面世。为确保协调世界时与世界时相差不会超过 0.9 秒，在有需要的情况下会在协调世界时内加上正或负闰秒。因此协调世界时与国际原子时之间会出现若干整数秒的差别，两者之差逐年积累，便采用跳秒（闰秒）的方法使协调时与世界时的时刻相接近，其差不超过 1s。它既保持时间尺度的均匀性，又能近似地反映地球自转的变化。按国际无线电咨询委员会（CCIR）通过的关于 UTC 的修正案，从 1972 年 1 月 1 日起 UTC 与 UT1（在 UT 中加入极移改正得到）之间的差值最大可以达到±0.9s。位于巴黎的国际地球自转事务中央局负责决定何时加入闰秒。一般会在每年的 6 月 30 日、12 月 31 日的最后一秒进行调整。\n","slug":"UTC","date":"2023-07-07T17:47:16.115Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"6ce48bf08a6702c21eabf4f22bcbbe7d","title":"TypeScript装饰器","content":"#TypeScript\n\n\n\n\n\n\n\n\n\nTypeScript 装饰器是一种特殊类型的声明，它可以附加到类、方法、属性或参数上，以修改或增强它们的行为。装饰器提供了一种在不修改源代码的情况下对现有代码进行扩展的机制。\n分类类装饰器\"compilerOptions\": &#123;\n    \"experimentalDecorators\": true\n&#125;\n\nfunction Log(target:any)&#123;\nconsole.log(\"this is Log\")\n&#125;\n\n@log\nclass MyClcass&#123;\n&#125;\n\n方法装饰器 function logMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;\n    console.log(&quot;Method Decorator&quot;);\n&#125;\n\nClass MyClass &#123;@logMethod myMethod() &#123;\n&#125;\n\n属性装饰器 function logProperty(target: any, propertyKey: string) &#123;\n    console.log(\"Property Decorator\");\n&#125;\nClass MyClass &#123;\n\t@log\n\tProperty name: string\n&#125;\n\n参数装饰器 function logParameter(target: any, propertyKey: string) &#123;\n    console.log(&quot;Parameter Decorator&quot;);\n&#125;\n\nclass MyClass &#123;\n    myMethod(@logParameter param: string) &#123;\n        &#x2F;&#x2F; 方法的定义\n    &#125;\n&#125;\n\n应用场景无需修改原有程序便可扩展功能\n逻辑层避免频繁的 try catch\n\nfunction logMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) return &#123;\n    value: async function(...args) &#123;\n        try &#123;\n            await value.value.apply(this,args)\n        &#125; catch(e) &#123;\n            console.log(e)\n        &#125;\n    &#125;\n&#125;\n\nclass A &#123;\n\t@logMethod sayHello() &#123;\n        return a + 3\n    &#125;\n&#125;\n\n\n逻辑层避免频繁的 try catch\nfunction validate(target: any, propertyKey: string, descriptor: PropertyDescriptor)&#123;\n return function()&#123;\n  let set = descriptor.set;\n  descriptor.set = function(value)&#123;\n\t  let type = Reflect.getMetadata\n\t  let type = Reflect.getMetadata(\"design:type\", target, name); \n\t  console.log(type.name) \n\t  if (!(new Object(value) instanceof type)) &#123; \n\t  throw new TypeError(`Invalid type, got $&#123;typeof value&#125; not $&#123;type.name&#125;.`); \n\t  &#125; \n\t  set?.call(this, value);\n  &#125;\n &#125;\n&#125;\n\n","slug":"TypeScript装饰器","date":"2023-07-07T17:47:16.113Z","categories_index":"","tags_index":"TypeScript","author_index":"Devmacy"},{"id":"722f32e5a716e48bf546864e109834ee","title":"TypeScript 类型推断","content":"#TypeScript  \n声明变量时指定类型let name: string &#x3D; &quot;John&quot;; \nlet age: number &#x3D; 25; \nlet isActive: boolean &#x3D; true;\n\n类型推断自动根据上下文进行类型推断\nlet name &#x3D; &quot;John&quot;; &#x2F;&#x2F; 推断为string类型 \nlet age &#x3D; 25; &#x2F;&#x2F; 推断为number类型 \nlet isActive &#x3D; true; &#x2F;&#x2F; 推断为boolean类型\n\n函数参数和函数返回值function add(x: number, y: number): number &#123; return x + y; &#125;\n\n类型断言let messageLength: number &#x3D; (message as string).length;\n\nInstanceofClass Person &#123;\n\tname:string;\n\tconstructor(name: string) &#123; this.name &#x3D; name; &#125;\n&#125;\n\nlet person &#x3D; new Person(&quot;bb&quot;)\nconsole.log(person instanceof Person)&#x2F;&#x2F;true\n","slug":"TypeScript 类型推断","date":"2023-07-07T17:47:16.110Z","categories_index":"","tags_index":"TypeScript","author_index":"Devmacy"},{"id":"a47409eec97e52b23350d2deb27473f3","title":"TypeScript 内置类型","content":"#TypeScript\nNumberlet num:number = 1;\n\nBooleanlet isDone: boolean = false;\n\nObject\n\n\n\n\n\n\n\n\nobject 表示非原始类型\ndeclare function create(o: object | null): void; \ncreate(&#123; prop: 0 &#125;); // OK \ncreate(null); // OK\n\nArraylet arr:number[] = [1,2,3]\n\n// 使用泛型\nlet arr:Array&lt;number> = [1,2,3]\n\nStringlet name: string = \"bob\";\n\n// 或者使用模板字符串\nlet sentence: string = `Hello, my name is $&#123; name &#125;.\n\nTuple\n\n\n\n\n\n\n\n\n元组类型允许表示一个 已知 元素 数量 和 类型 的数组，各元素的类型不必相同\n// 描述元组 类型\nlet xType:[string,string,number]\n\nxType = [\"1\",\"1\",1]\n\nVoid\n\n\n\n\n\n\n\n\n某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void\n赋值只能赋值 undefined&#x2F;null\nlet value:void = undefined\nlet value:void = null\n\nNever\n\n\n\n\n\n\n\n\nnever 类型表示的是那些 永不存在 的值的类型。例如， never 类型是那些总是会 抛出异常 或根本就 不会有返回值 的函数表达式或箭头函数表达式的返回值类型；变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。\n// 返回never的函数必须存在无法达到的终点 \nfunction error(message: string): never &#123; throw new Error(message); &#125; // 推断的返回值类型为never \nfunction fail() &#123; return error(\"Something failed\"); &#125; \n// 返回never的函数必须存在无法达到的终点 \nfunction infiniteLoop(): never &#123; while (true) &#123; &#125; &#125;\n\n特点\n永不存在\n可能有异常\n不会有返回值\n\nUndefinedlet u: undefined = undefined;\n\nNulllet n: null = null;\n\nAny\n\n\n\n\n\n\n\n\n编程阶段还不清楚类型的变量指定一个类型\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\"; \nnotSure = false; // okay, definitely a boolean\n\nEnum\n\n\n\n\n\n\n\n\n使用枚举类型可以为一组数值赋予友好的名字\nenum Color &#123;Red, Green, Blue&#125;\nconsole.log(Color[2])//Blue\nconsole.log(Color.Green)//1\n","slug":"TypeScript 内置类型","date":"2023-07-07T17:47:16.108Z","categories_index":"","tags_index":"TypeScript","author_index":"Devmacy"},{"id":"52c7abe43b46bab510491f8688329c6b","title":"TypeScript mixin","content":"#TypeScript\nMixin\n\n\n\n\n\n\n\n\nmixin 是一个抽象子类；即一个子类定义，可以应用于不同的超 (父) 类以创建相关的修改类族群。 —Gilad Bracha 和 William Cook，基于 Mixin 的继承\ntypescript 中没有多重继承的概念\n// Disposable \nMixin class Disposable &#123; \n\tisDisposed: boolean; \n\tdispose() &#123; this.isDisposed = true; &#125; \n&#125;\n\n// Activatable \nMixin class Activatable &#123; \n\tisActive: boolean; \n\tactivate() &#123; this.isActive = true; &#125; \n\tdeactivate() &#123; this.isActive = false; &#125;\n&#125; \n\nclass SmartObject implements Disposable, Activatable &#123; \n\tconstructor() &#123; \n\t\tsetInterval(() => \n\t\t\tconsole.log(\n\t\t\tthis.isActive + \" : \" + this.isDisposed), 500); \n\t&#125; \n\tinteract() &#123;this.activate();&#125; \n\t// Disposable \n\tisDisposed: boolean = false; \n\tdispose: () => void; \n\t// Activatable \n\tisActive: boolean = false; \n\tactivate: () => void; \n\tdeactivate: () => void; \n&#125; \n\napplyMixins(SmartObject, [Disposable, Activatable]); \nlet smartObj = new SmartObject(); \nsetTimeout(() => smartObj.interact(), 1000); \n\n//////////////////////////////////////// \n// In your runtime library somewhere \n/////////////////////////////////////// \nfunction applyMixins(derivedCtor: any, baseCtors: any[]) &#123;\n\tbaseCtors.forEach(baseCtor => &#123; \n\tObject.getOwnPropertyNames(baseCtor.prototype).forEach(\n\tname => &#123; \n\t\tderivedCtor.prototype[name] = baseCtor.prototype[name]; \n\t\t&#125;); \n\t&#125;); \n&#125;\n","slug":"TypeScript mixin","date":"2023-07-07T17:47:16.106Z","categories_index":"","tags_index":"TypeScript","author_index":"Devmacy"},{"id":"651c515b0e13fa2dba352e67fcd43790","title":"TypeScript class","content":"#TypeScript\n定义\n\n\n\n\n\n\n\n\nTypeScript 完全支持 ES2015 引入的 class 关键字。和其他 JavaScript 语言特性一样，TypeScript 提供了类型注解和其他语法，允许你表达类与其他类型之间的关系。\n","slug":"TypeScript class","date":"2023-07-07T17:47:16.104Z","categories_index":"","tags_index":"TypeScript","author_index":"Devmacy"},{"id":"de995f2c1bc5e7da2cf3c1596e98c591","title":"TypeScript any和unkonwn","content":"#TypeScript\n区别\n\n\n\nany\nunknown\n\n\n\n定义\n任何类型\n任何类型\n\n\n安全\n\n类型检查\n\n\n赋值\n\n只能赋值给 any 和 unkonwn\n\n\n交叉\nany ∩ T &#x3D; any\nunknown ∩ T &#x3D; T\n\n\n访问\n属性访问、元素访问\n类型收窄时可用\n\n\n","slug":"TypeScript any和unkonwn","date":"2023-07-07T17:47:16.102Z","categories_index":"","tags_index":"TypeScript","author_index":"Devmacy"},{"id":"fd6954209260b0999c4a92d8fad9422d","title":"text","content":"#CSS\n属性text-decoration对文字添加修饰的属性  \nunderline添加下划线  \ncapitalize首字母大写  \nuppercase文本大写\nlowercase文本小写\n","slug":"text","date":"2023-07-07T17:47:16.100Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"df7a944420c622b46842c86cdd313f27","title":"shouldComponentUpdate","content":"","slug":"shouldComponentUpdate","date":"2023-07-07T17:47:16.098Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"7aee2a9e36929c61e8acfa41e36e3c28","title":"sessionStorage","content":"#HTML\n概念\n\n\n\n\n\n\n\n\n sessionStorage 是 HTML5 新增的一个会话存储对象，用于临时保存同一窗口 (或标签页) 的数据（key&#x2F;value），在关闭窗口或标签页之后将会删除这些数据。是 window 下的对象。\n特点\n网页存储 api，允许存储 key–value 形式的数据\nvalue 值为字符串类型\n\n\n当用户结束会话时，sessionstorage 的数据也会清除\n重新加载仍然会保持\n\n\n同源 same origin 数据可以访问，用于存储暂时数据，例如购物车，表单数据\n打开相同 url 的 tab 页面，创建各自的 sessionStorage\n\nApi存储数据sessionStorage.setItem(&#39;key&#39;, &#39;value&#39;);\n删除数据sessionStorage.removeItem(&#39;key&#39;);\n读取数据sessionStorage.getItem(&#39;key&#39;);\n清除所有sessionStorage.clear();\n","slug":"sessionStorage","date":"2023-07-07T17:47:16.096Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"cc3ac02cfd326faf350e70135259c2b4","title":"scope","content":"#CSS\n\n\n\n\n\n\n\n\n\n是一个 CSS 规则，用于指定样式规则的作用范围。它被用于定义样式规则的命名空间，使其仅适用于指定的作用范围内的元素\n","slug":"scope","date":"2023-07-07T17:47:16.094Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"883d8fc4b0b2c186df3a69be746acff8","title":"SASS","content":"","slug":"SASS","date":"2023-07-07T17:47:16.091Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"8a8b098c941ffd6e202ff639d1155787","title":"Retina","content":"概述\n\n\n\n\n\n\n\n\nRetina 既不是指分辨率，也不是单独指 PPI，而是指视觉效果。我们一般称 [[devicePixelRatio]] 大于或等于 2 的屏幕为 Retina 屏幕 (r 屏)，否则为 非 r 屏。\nRetina 的原理受 windows 操作系统的影响，多数人心中会产生这样的逻辑：分辨率越高，字会显得越小。这是因为整个屏幕的面积主要由像素面积构成，即在相同面积下，分辨率越高，像素数量也越多，单个像素的面积也一定越小。于是高分辨率就对应着小像素，而像素小，则由像素构成的文字就小。所以就有了『分辨率越高，字会显得越小』的印象。\n这是因为操作系统的 HiDPI 渲染方式，它决定了一个文字或图标最终以多少个像素来表达。2 倍 r 屏它在表达屏幕上每个元素时，都使用了 4 倍于非 r 屏的像素个数。这样算下来，像素尺寸为 1&#x2F;4，像素数目为 4 倍，于是最终渲染出来的文字和图标的大小与非 r 屏的相当。\n","slug":"Retina","date":"2023-07-07T17:47:16.089Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"b841f4f3a72a5498eb1f16cd609efb8e","title":"React.js","content":"#React\n特点\njavascript 上运行，构建用户界面\n其抽象性使得能够运行在任何平台上\n\nReact DOM 库ReactDom.render\nReact Native一组 React 组件库\n","slug":"React.js","date":"2023-07-07T17:47:16.087Z","categories_index":"","tags_index":"React","author_index":"Devmacy"},{"id":"b528c985add08d848756c4e04c487bab","title":"PureComponent","content":"特性\n会对 props 和 state 进行 [[浅比较]]，跳过不必要的更新，提高组件性能\n\n生命周期 [[shouldComponentUpdate]]\n改变 PureComponent 的原因\n对新旧 Props，state 进行 shallowEqual 比较\n\n\n深层数据不一致\n返回 false\n\n\n\n","slug":"PureComponent","date":"2023-07-07T17:47:16.084Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"b468f3c3ac71ea2b71e5a5059fe38476","title":"Promise","content":"#JavaScript\n特点\n对象状态不受外界影响\n一旦状态发生改变就不会再变\n\n状态pendingfulfilledrejected","slug":"Promise","date":"2023-07-07T17:47:16.082Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"bb2ae4109163cafdb819e945c7b475ed","title":"postmessage","content":"#HTML\n概念\n\n\n\n\n\n\n\n\nwindow.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 https），端口号（443 为 https 的默认值），以及主机 (两个页面的模数 Document.domain 设置为相同的值) 时，这两个脚本才能相互通信。\n\n两个窗口通信\n\n// In the parent window\nvar iframe = document.getElementById('my-iframe');\niframe.contentWindow.postMessage('Hello from the parent window!', '*');\n\n// In the iframe\nwindow.addEventListener('message', function (event) &#123;\n  console.log('Message received from parent window: ', event.data);\n&#125;);\n","slug":"postmessage","date":"2023-07-07T17:47:16.080Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"60867891b6cc6a4495d66ab49e2ce728","title":"overflow","content":"#CSS\n属性\nvisible\n不修剪\n\n\nauto\n子元素超出父元素裁剪并出现滚动条\n\n\nhidden\n修剪并隐藏\n\n\nscroll\n裁剪内容可滚动\n不管是否需要都会提供滚动机制\n\n\ninherit\n\n","slug":"overflow","date":"2023-07-07T17:47:16.079Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"4a5d2ffa2e6dc88197e9c2b620bc49da","title":"outerHTML","content":"#HTML\n\n\n\n\n\n\n\n\n\nouterHTML 属性获取描述元素（包括其后代）的序列化 HTML 片段。它也可以设置为用从给定字符串解析的节点替换元素。\n示例&lt;div id=\"d\"> \n\t&lt;p>Content&lt;/p> \n\t&lt;p>Further Elaborated&lt;/p> \n&lt;/div>\n\nconsole.log(document.getElementById(\"d\").outerHTML);\n// &lt;div id=\"d\">&lt;p>Content&lt;/p>&lt;p>Further Elaborated&lt;/p>&lt;/div>\n","slug":"outerHTML","date":"2023-07-07T17:47:16.077Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"506af269f13c75940f82dd6b0ee208bd","title":"npm","content":"命令更新脚手架 npm install -g @vue/cli\n\nnpm install等同于 npm i\n参数-S安装在 dependencies开发生产都用\n-D安装在 devDependencies只有开发环境用\n–save-dev安装在 devDependencies只有开发环境用\n-g全局安装不会注入到 devDependencies 和 dependencies\n–save-exact没有~或者^确保版本唯一\n","slug":"npm","date":"2023-07-07T17:47:16.075Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"f7cd73850062e5beae0d458b739ec82c","title":"menu","content":"#HTML  \n\n\n\n\n\n\n\n\n\n所有主流浏览器均不支持 menu 元素。\n\n\n\n\n\n\n\n\n\n&lt;menu&gt;  元素呈现了一组用户可执行或激活的命令。这既包含了可能出现在屏幕顶端的列表菜单，也包含了那些隐藏在按钮之下、当点击按钮后显示出来的文本菜单\n","slug":"menu","date":"2023-07-07T17:47:16.073Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"ac032c8bcfc3820b45312d60fdc6027b","title":"memo","content":"#React\n结合\n[[PureComponent]]\n[[shouldComponentUpdate]] 生命周期\n\n解释\n根据传入进来的 props 进行一次对比\n根据第二个函数返回值进一步判断哪些 props 需要更新\n\n参数\n第一个参数\n组件本身\n\n\n第二个参数\n(pre,next)&#x3D;&gt; boolean\npre 之前的数据\nnext 现在的数据\n\n\nBoolean\ntrue 更新\nfalse 不更新\n\n\n\n\n\n代码    \n","slug":"memo","date":"2023-07-07T17:47:16.070Z","categories_index":"","tags_index":"React","author_index":"Devmacy"},{"id":"8577172d587822c13c6c2f341014a5ff","title":"Markdown语法","content":"\ntitle: Markdown语法标题# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n##### 这是五级标题\n###### 这是六级标题\n\n效果这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体**这是加粗的文字**\n*这是倾斜的文字*`\n***这是斜体加粗的文字***\n~~这是加删除线的文字~~\n\n效果这是加粗的文字这是倾斜的文字&#96;这是斜体加粗的文字这是加删除线的文字\n引用>这是引用的内容\n>>这是引用的内容\n>>>这是引用的内容\n\n效果\n\n\n\n\n\n\n\n\n这是引用的内容\n\n这是引用的内容\n\n这是引用的内容\n\n\n分割线---\n----\n***\n*****\n\n效果\n\n\n\n图片![图片alt](图片地址)\n\n图片alt就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。\n\n效果\n超链接[超链接名](超链接地址)\n\n效果掘金百度\n列表无序列表- 列表内容\n+ 列表内容\n* 列表内容\n\n注意：- + * 跟内容之间都要有一个空格\n\n效果\n列表内容\n列表内容\n列表内容\n\n有序列表1. 列表内容\n2. 列表内容\n3. 列表内容\n\n注意：序号跟内容之间要有空格\n\n效果\n列表内容\n列表内容\n列表内容\n\n列表嵌套效果\n有序列表\n有序列表二级\n有序列表三级\n有序列表四级\n\n\n\n\n\n\n\n\n无\n无二级\n无三级\n无四级\n。。。\n\n\n\n\n\n\n\n\n无序列表\na\nb\nc\nd\n\n\n\n\n有序列表\na\nb\nc\nd\n\n\n\n表格表头|表头|表头\n---|:--:|---:\n内容|内容|内容\n内容|内容|内容\n\n第二行分割表头和内容。\n- 有一个就行，为了对齐，多加了几个\n:--- 文字默认居左\n:--: 表示文字居中\n---: 表示文字居右\n\n注：原生的语法两边都要用 | 包起来。此处省略\n\n\n效果\n\n\n序号\n设备名称\n设备类型\n\n\n\n1\n变压器\n变压器\n\n\n2\n开关\n开关\n\n\n代码`代码内容`\n\n效果function(param)&#123;\n return \"\"\n&#125;\n\n待办- [ ] 待办1\n\n效果\n 代办 1\n\n戚宴冰牛逼厉害了他真的我哭死","slug":"Markdown语法","date":"2023-07-07T17:47:16.068Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"3e3976292a3f582a48e0ad2083410fee","title":"map","content":"#JavaScript\n返回值新数组，不改变原数组\n示例 let res = arr.map(i => i * i);\n","slug":"map","date":"2023-07-07T17:47:16.066Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"cebfbaa792d4a1cf5b0271c770bb2684","title":"link和@import","content":"#HTML #CSS\nlink\n\n\n\n\n\n\n\n\n规定了当前文档与外部资源的关系,该元素最常用于链接样式表\n特点\n与页面同时加载\n\n@import\n\n\n\n\n\n\n\n\n用于从其他样式表导入样式规则\n语法@import url;\n@import url list-of-media-queries;\n\n示例@import url(\"fineprint.css\") print;\n@import url(\"bluish.css\") projection, tv;\n@import 'custom.css';\n@import url(\"chrome://communicator/skin/\");\n@import \"common.css\" screen, projection;\n@import url('landscape.css') screen and (orientation:landscape);\n\n权重link &gt; @import\n","slug":"link和@import","date":"2023-07-07T17:47:16.064Z","categories_index":"","tags_index":"CSS,HTML","author_index":"Devmacy"},{"id":"36d55ea9e4fb9a9a07fa5da592ea2623","title":"Less","content":"#CSS\n定义\n\n\n\n\n\n\n\n\nLess（Leaner Style Sheets 的缩写）是一门向后兼容的 CSS 扩展语言\n运算支持算数运算符 + - * /\n示例// 所有操作数被转换成相同的单位\n@conversion-1: 5cm + 10mm; // 结果是 6cm\n@conversion-2: 2 - 3cm - 5mm; // 结果是 -1.5cm\n\n// conversion is impossible\n@incompatible-units: 2 + 5px - 3cm; // 结果是 4px\n\n// example with variables\n@base: 5%;\n@filler: @base * 2; // 结果是 10%\n@other: @base + @filler; // 结果是 15%\n\n颜色运算@color: (#224488 / 2); // 结果是 #112244\nbackground-color: #112244 + #111; // 结果是 #223355\n","slug":"Less","date":"2023-07-07T17:47:16.062Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"f5e8bebaa6bd820f435171b595e4d09f","title":"JSON.stringify()","content":"#JavaScript\n定义\n\n\n\n\n\n\n\n\nJSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。\n语法JSON.stringify(value[, replacer [, space]])\n\n示例console.log(JSON.stringify(&#123; x: 5, y: 6 &#125;));\n// Expected output: \"&#123;\"x\":5,\"y\":6&#125;\"\n\nconsole.log(JSON.stringify([new Number(3), new String('false'), new Boolean(false)]));\n// Expected output: \"[3,\"false\",false]\"\n\nconsole.log(JSON.stringify(&#123; x: [10, undefined, function()&#123;&#125;, Symbol('')] &#125;));\n// Expected output: \"&#123;\"x\":[10,null,null,null]&#125;\"\n\nconsole.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));\n// Expected output: \"\"2006-01-02T15:04:05.000Z\"\"\n","slug":"JSON.stringify()","date":"2023-07-07T17:47:16.060Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"4298c5ed1a6225affd0345cd32f3a2e9","title":"input","content":"#HTML\n类型rangeemailfiledatex-webkit-speech只有 webkit 内核浏览器才支持\n示例&lt;input speech x-webkit-speech >&lt;／input>\n","slug":"input","date":"2023-07-07T17:47:16.059Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"67ddab0a526603333107b7889bf05413","title":"innerHTML","content":"#HTML\n\n\n\n\n\n\n\n\n\nElement.innerHTML 属性设置或获取 HTML 语法表示的元素的后代。\n示例&lt;div id=\"d\"> \n\tFurther\n&lt;/div>\n\nconsole.log(document.getElementById(\"d\").innerHTML);\n//Further\n","slug":"innerHTML","date":"2023-07-07T17:47:16.056Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"82c1ead60e57fa829ce31cc7935c0ea3","title":"IEEE754-2019浮点算数标准","content":"概述\n\n\n\n\n\n\n\n\n此标准规定了计算机系统中浮点运算的格式和操作，定义了异常条件，并指定了这些条件的处理方法。\n此标准包括\n二进制和十进制浮点数据的格式，用于计算和数据交换  \n加法、减法、乘法、除法、乘加、平方根、比较以及其他操作  \n整数和浮点格式的转换  \n不同浮点格式之间的转换  \n浮点格式和字符序列的外部表示的转换  \n浮点异常及其处理，包括非数（NaNs）\n\n","slug":"IEEE754-2019浮点算数标准","date":"2023-07-07T17:47:16.054Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"f76988d4dda4deec619ed4b217573b7d","title":"ID选择器","content":"#CSS\n","slug":"ID选择器","date":"2023-07-07T17:47:16.052Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"487bb8c52f021ca2e32bfe9f4dd40655","title":"GMT","content":"定义\n\n\n\n\n\n\n\n\n太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间为中午 12 点\n又称 格林威治时间\n","slug":"GMT","date":"2023-07-07T17:47:16.050Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"54778e99cd6cb44df1fef7090db4323f","title":"Git Clean","content":"#Git\n定义删除所有未被 tracked 的文件，目录（慎用）\n参数\n\n\n\n\n\n\n\n\nn：显示将要被删除的文件d：删除未被添加到 git 路径中的文件（将.gitignore 文件标记的文件全部删除）f：强制运行x：删除没有被 track 的文件\n\n显示要被删除的文件，但不真正删除\n\ngit clean -n\n\n\n删除未被跟踪的文件\n\ngit clean -f\n\n\n删除指定目录下的文件\n\ngit clean -f &lt;path>\n\n\n删除未被 track 的文件和文件夹\n\ngit clean -dr\n\n\n删除未被 track 的文件，即使已经添加到.gitignore\n\ngit clean -xf\n\n\n获得一个干净的 commit\n\ngit reset --hard\ngit clean -df\n","slug":"Git Clean","date":"2023-07-07T17:47:16.046Z","categories_index":"","tags_index":"Git","author_index":"Devmacy"},{"id":"612f193707cdf7697e6d4740c011e533","title":"for","content":"#JavaScript\n遍历对象示例for(let x=0,keys = Object.keys(obj1);x&lt;keys.length;x++)\n&#123;console.log(keys[x],':',x)&#125;\n\n遍历数组遍历字符串遍历 DOM 节点示例var nodeList = document.querySelectorAll('div');\nfor(let x =0; x &lt; nodeList.length; x++)&#123;\nconsole.log(nodeList[x].classList)\n&#125;\n","slug":"for","date":"2023-07-07T17:47:16.044Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"778fa1f4f26fa0b80ea098aa51864249","title":"for of","content":"#JavaScript\n调用 for (let [key, value] of iterable) &#123;\nconsole.log(key)\nconsole.log(value);&#125;\n\n遍历对象\nArray\nMap\nSet\nString\nTypedArray\narguments 对象等\n\n","slug":"for of","date":"2023-07-07T17:47:16.042Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"987d2d63db22e30fe992346965b3af9b","title":"for in","content":"#JavaScript\n\n调用\n   for(let i in profile)&#123;\nlet item = profile[i];\nconsole.log(item) // 对象的键值\nconsole.log(i)&#125; // 对象的键对应的值\n\n遍历\n\n数组\n对象\n字符串\n\n\n\n","slug":"for in","date":"2023-07-07T17:47:16.040Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"bc33011046b0768d4fc22084122efa31","title":"for each","content":"#JavaScript\n调用 let arr= [1,2,3,4,5];\narr.forEach((element)=>&#123;\nconsole.log(element);\n&#125;)\n","slug":"for each","date":"2023-07-07T17:47:16.037Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"a761f0a531808b1ee42be29067e4d5e1","title":"font","content":"#CSS\nfont-weight\n\n\n\n\n\n\n\n\n指定了字体的粗细程度。一些字体只提供 normal 和 bold 两种值\n值bold加粗。与 700 等值\nnormal正常粗细。与 400 等值。\nbolder比从父元素继承来的值更粗 (处在字体可行的粗细值范围内)。\nlighter比从父元素继承来的值更细 (处在字体可行的粗细值范围内\nnumber1-1000 的 number 类型值，更大的数值代表字体重量粗于更小的数值\n","slug":"font","date":"2023-07-07T17:47:16.035Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"a7e3077744d7a57e00d2f0295a12777a","title":"flex","content":"#CSS\n","slug":"flex","date":"2023-07-07T17:47:16.034Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"6c5b63e0a250a8b5b34684947b03be23","title":"DOM","content":"方法\nquerySelectorAll()\n   elementList = document.querySelectorAll(selectors);\n\n- selectors\n\n 'p'\n'div > text'\n\n- nodelist\n   - 节点数组\n\n\n返回值\nNodeList 对象\n\n\n返回所有 CSS 选择器匹配的对象\n\n\n\nNodeList\n文档所有节点对象\nclassList\n指示有多少个类名\n\n\n\n虚拟 DOM\n定义\n节点描述对象\n如何创建真实的 dom 节点\n\n\n优势\n渲染引擎操作 dom 慢所以放在 js 操作\n数据大量更新能够合理更新视图\n\n\njs 为基础运行\n\n","slug":"DOM","date":"2023-07-07T17:47:16.032Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"f7781a311adfe6b89739c305ab02cd69","title":"display","content":"#CSS\n","slug":"display","date":"2023-07-07T17:47:16.030Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"5173d8993970310ffc7f92fe7bccdac0","title":"Diff算法","content":"#Vue\n真实 dom  &lt;div>\n&lt;p>123&lt;/p>\n&lt;/div>\n\n虚拟 dom  var Vnode = &#123;\n tag: 'div',\n children: [\n  &#123; tag: 'p', text: '123' &#125;\n ]\n&#125;;\n\nvnode 分类EmptyVNode没有内容的注释节点\nTextVNode文本节点\nElementVNode普通元素节点\nComponentVNode组件节点\nCloneVNode克隆节点，可以是以上任意类型的节点，唯一的区别在于 isCloned 属性为 true\n流程\n真实 dom 生成一个虚拟 dom\n虚拟 dom 节点数据变化之后生成一个新的 vnode\nvnode 和 oldNode 比较，发现有不一样的地方直接修改在真实 dom 上\n将 oldnode 修改为 vnode\n\n比较方式\n\n\n  // 旧dom\n&lt;div>\n&lt;p>123&lt;/p>\n&lt;/div>\n\n// 新dom\n&lt;div>\n&lt;span>456&lt;/span>\n&lt;/div>\n\n\n边比较边更新\n生成一个新的 vdom 树\n如果认为两个 vnode 节点\n值得比较\n\n继续比较其子节点\n\n\n不值得比较\n\n删除旧节点\n插入新节点\n\nfunction patch (oldVnode, vnode) &#123;\nif (sameVnode(oldVnode, vnode)) &#123;\npatchVnode(oldVnode, vnode)\n&#125; else &#123;\nconst oEl = oldVnode.el\nlet parentEle = api.parentNode(oEl)\ncreateEle(vnode)\nif (parentEle !== null) &#123;\napi.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))\napi.removeChild(parentEle, oldVnode.el)\noldVnode = null\n&#125;\n&#125;\nreturn vnode\n&#125;\n\n\nfunction sameVnode(oldVnode, vnode)&#123;\n// 两节点key值相同，并且sel属性值相同，即认为两节点属同一类型，可进行下一步比较\nreturn vnode.key === oldVnode.key &amp;&amp; vnode.sel === oldVnode.sel\n&#125;\n\n\n\n","slug":"Diff算法","date":"2023-07-07T17:47:16.028Z","categories_index":"","tags_index":"Vue","author_index":"Devmacy"},{"id":"6b187a3dcaca4b22050a31027cd39624","title":"devicePixelRatio","content":"#HTML\n概述 devicePixelRatio 返回当前显示设备的 物理像素分辨率与 CSS 像素分辨率之比。 此值也可以解释为像素大小的比率：一个 CSS 像素的大小与一个物理像素的大小。简单来说，它告诉浏览器应使用多少屏幕实际像素来绘制单个 CSS 像素。\n语法value = window.devicePixelRatio;\n\n值\n\n\n\n\n\n\n\n\n一个双精度浮点值，指示显示器的物理像素分辨率与 CSS 像素分辨率之比。值 1 表示经典 _96 DPI_（在某些平台上为 76 DPI）显示，而对于 HiDPI &#x2F; Retina 显示屏则期望值为 2。在异常低分辨率的显示器中，或更常见的是，当屏幕的像素深度比简单地将 96 或 76 DPI 的标准分辨率提高一倍时，可能还会返回其他值。\n","slug":"devicePixelRatio","date":"2023-07-07T17:47:16.026Z","categories_index":"","tags_index":"HTML","author_index":"Devmacy"},{"id":"e0aa8218b2d142d2d3e84aa2275a2437","title":"Date","content":"#JavaScript\n定义JavaScript 内置对象\n构造函数new Date() // 代表当前的时间\nnew Date(value)\nnew Date(dateString)\nnew Date(dateObject)\n\nnew Date(year, monthIndex)\nnew Date(year, monthIndex, day)\nnew Date(year, monthIndex, day, hours)\nnew Date(year, monthIndex, day, hours, minutes)\nnew Date(year, monthIndex, day, hours, minutes, seconds)\nnew Date(year, monthIndex, day, hours, minutes, seconds, milliseconds)\n\nDate()\n\n无参新创建的 Date 对象代表当前的日期和时间\nvalue一个整数，代表自 UTC 1970 年 1 月 1 日 00:00:00（ECMAScript 纪元，与 UNIX 纪元相同）以来的毫秒数，忽略闰秒。\ndateString一个代表日期的字符串值，其格式由 Date.parse() 识别\ndateObject一个现有的 Date 对象。这实际上是在现有的 Date 对象上复制了一个相同的日期和时间。\nAPIDate.now()\n\n\n\n\n\n\n\n\nDate.now() 方法返回自 1970 年 1 月 1 日 00:00:00 (UTC) 到当前时间的毫秒数。\nconsole.log(Date.now());//1687705330209\n\nDate.parse()\n\n\n\n\n\n\n\n\nDate.parse() 方法解析一个表示某个日期的字符串，并返回从 1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的 UTC 时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为 NaN。\nconsole.log(Date.parse('01 Jan 1970 00:00:00 GMT'));//0\n\nDate.getTime()\n\n\n\n\n\n\n\n\ngetTime() 方法返回一个时间的格林威治时间（[[GMT]]）数值。\nDate.prototype.getMilliseconds()\n\n\n\n\n\n\n\n\ngetMilliseconds() 方法根据本地时间，返回一个指定的日期对象的毫秒数。\n范围0-999\n示例console.log(new Date().getMilliseconds())// 383/342/664.....\n","slug":"Date","date":"2023-07-07T17:47:16.024Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"d216fbcd09927344150d1cf28ee5dc69","title":"CSS权重","content":"#CSS\n通配符选择器和继承0\n标签选择器0001\n类选择器0010\nId 选择器0100\n行内样式1000\n!important∞\n","slug":"CSS权重","date":"2023-07-07T17:47:16.022Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"97cc90137d83af6fe23aaf1d18c02197","title":"CSS伪类","content":"#CSS\n特点\n可以同时使用多个伪类\n存在 DOM 文档中\n无标签\n特定条件触发出现\n\n分类:dir\n\n\n\n\n\n\n\n\n匹配特定文本书写方向的元素  \n实验性功能，仅 FireFox 浏览器支持\n示例:dir(ltr) &#123;\n  color: #f0ab5c;\n&#125;\n:dir(rtl) &#123;\n  color: #000;\n&#125;\n......\n&lt;div class='dir'>默认情况&lt;/div>\n  &lt;div class='dir' dir='ltr'>\n  书写方向从左到右\n&lt;/div>\n&lt;div class='dir' dir='rtl'>\n  书写方向从右到左\n&lt;/div>\n\n:only-child匹配没有兄弟元素的元素\nlink:hover:nth-child(n):first-of-type:disabled","slug":"CSS伪类","date":"2023-07-07T17:47:16.020Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"e56310feabc170a4457d9018108553b5","title":"continue","content":"#JavaScript\n","slug":"continue","date":"2023-07-07T17:47:16.018Z","categories_index":"","tags_index":"JavaScript","author_index":"Devmacy"},{"id":"f11a7d7c1236b692ff68bcb975717fae","title":"Component","content":"#React\n源码function Component (props,context,updater) &#123;\n\tthis.props = props;\n\tthis.context = context;\n\tthis.refs = emptyObject;\n\tthis.updater = updater || ReactNoopUpdateQueue;\n&#125;\nComponent.propotype.isReactComponent = &#123;&#125;;\n","slug":"Component","date":"2023-07-07T17:47:16.016Z","categories_index":"","tags_index":"React","author_index":"Devmacy"},{"id":"50b3f0ed48747cf7b45b7dad3caed089","title":"BFC","content":"块格式化上下文\nWeb 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域\n独立的渲染区域\n在该区域内，常规流的盒块布局，创建的 BFC 元素\n隔绝它内部和外部的联系，内部渲染不会影响到外部\n\n作用\n创建 BFC 的元素\n自动高度需要计算浮动高度\n边框盒不会与浮动元素重合\n不会和它子元素进行外边距合并\n\n\n\nBFC 创建以下方式会创建 BFC\n根元素标签\nfloat 属性不为 none\noverflow 不为 visible\ndisplay 属性为\ninline-block\ntable-cell\ntable-caption\nflex\ninline-flex\n\n\nposition 属性为\nabsolute\nfixed\n\n\ncontain 为\nlayout\ncontent\npaint\n\n\n\n高度塌陷父元素高度计算时不会加上浮动元素高度\n","slug":"BFC","date":"2023-07-07T17:47:16.014Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"f6616b3cc4c100288c21bf891019d9b7","title":"BEM","content":"起源","slug":"BEM","date":"2023-07-07T17:47:16.012Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"7a057c4175a4a327a328ed9c348d1a32","title":"background","content":"#CSS\n","slug":"background","date":"2023-07-07T17:47:16.010Z","categories_index":"","tags_index":"CSS","author_index":"Devmacy"},{"id":"da9c41005bfc8112eadae9ed5b3dcf28","title":"backdrop-filter","content":"#CSS\n概念\n\n\n\n\n\n\n\n\n可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明\n用法/* 指向 SVG 滤镜的 URL */\nbackdrop-filter:url(commonfilters.svg#filter);\n\n/* &lt;filter-function> 滤镜函数值 */\nbackdrop-filter: blur(2px);\nbackdrop-filter: brightness(60%);\nbackdrop-filter: contrast(40%);\nbackdrop-filter: drop-shadow(4px 4px 10px blue);\nbackdrop-filter: grayscale(30%);\nbackdrop-filter: hue-rotate(120deg);\nbackdrop-filter: invert(70%);\nbackdrop-filter: opacity(20%);\nbackdrop-filter: sepia(90%);\nbackdrop-filter: saturate(80%);\n\n/* 多重滤镜 */\nbackdrop-filter: url(filters.svg#filter) blur(4px) saturate(150%);\n\n形式化语法backdrop-filter = none | &lt;filter-value-list>  \n\n&lt;filter-value-list> = \n[&lt;filter-function>|&lt;url>]+\n\n&lt;filter-function> = \n  &lt;blur()>         |\n  &lt;brightness()>   |\n  &lt;contrast()>     |\n  &lt;drop-shadow()>  |\n  &lt;grayscale()>    |\n  &lt;hue-rotate()>   |\n  &lt;invert()>       |\n  &lt;opacity()>      |\n  &lt;sepia()>        |\n  &lt;saturate()>     \n\n&lt;url> = \n  url( &lt;string> &lt;url-modifier>* )  |\n  src( &lt;string> &lt;url-modifier>* )  \n\n&lt;blur()> = \n  blur( &lt;length>? )  \n\n&lt;brightness()> = \n  brightness( [ &lt;number> | &lt;percentage> ]? )  \n\n&lt;contrast()> = \n  contrast( [ &lt;number> | &lt;percentage> ]? )  \n\n&lt;drop-shadow()> = \n  drop-shadow( [ &lt;color>? &amp;&amp; &lt;length>&#123;2,3&#125; ] )  \n\n&lt;grayscale()> = \n  grayscale( [ &lt;number> | &lt;percentage> ]? )  \n\n&lt;hue-rotate()> = \n  hue-rotate( [ &lt;angle> | &lt;zero> ]? )  \n\n&lt;invert()> = \n  invert( [ &lt;number> | &lt;percentage> ]? )  \n\n&lt;opacity()> = \n  opacity( [ &lt;number> | &lt;percentage> ]? )  \n\n&lt;sepia()> = \n  sepia( [ &lt;number> | &lt;percentage> ]? )  \n\n&lt;saturate()> = \n  saturate( [ &lt;number> | &lt;percentage> ]? )  \n\n适用元素所有元素，包括 svg\n","slug":"backdrop-filter","date":"2023-07-07T17:47:16.008Z","categories_index":"","tags_index":"CSS,filter","author_index":"Devmacy"},{"id":"b91bd63e525a0b7cb98f5218c7d46d20","title":"2000元电脑配件","content":"配件显示器\n小米\n449\n\n\n1080p\n\nCPU\nr5 1400\n299\n\n\n淘宝\n\n板子\nb350m\n145\n\n\n微星\n\n内存根据主板选购，支持 pcie 的使用 pcie\n散热\n超频 3 红海 mini\n29.9\n\n\n\n电源金牌电源\n显卡1060（6g）拆机，可拼多多购买\n机箱咸鱼采购百元以下\n硬盘淘宝购买\n","slug":"2000元电脑配件","date":"2023-07-07T17:47:16.005Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"b39be5ba7c84b4a7318f74fdf4ddd937","title":"000-Kanban","content":"\nkanban-plugin: basic\n\n🆘📗%% kanban:settings\n&#123;&quot;kanban-plugin&quot;:&quot;basic&quot;&#125;\n%%\n","slug":"000-Kanban","date":"2023-07-07T17:47:16.003Z","categories_index":"","tags_index":"","author_index":"Devmacy"},{"id":"bad70521edf1008384f195d0394a9096","title":"$nextTick","content":"#Vue\n特点\n更新 [[DOM]] 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更\n数据更新完成后再次更新 DOM\n$nextTick 数据发生更新就更新 DOM\n\n","slug":"$nextTick","date":"2023-07-07T17:47:16.001Z","categories_index":"","tags_index":"Vue","author_index":"Devmacy"},{"id":"e66ce9b382dec316af8d079c22ca24ea","title":"Git代理","content":"#Git\n查看所有配置git config --list\n\n查看全局代理配置git config --global --list\n\n编辑全局配置操作同 vi\ngit config --global --edit\n\n设置全局 http&#x2F;https 代理git config --global http.proxy http://127.0.0.1:7890\n\ngit config --global https.proxy http://127.0.0.1:7890\n\n取消代理git config --global --unset http.proxy \ngit config --global --unset https.proxy\n","slug":"Git代理","date":"2023-07-07T17:45:56.566Z","categories_index":"","tags_index":"Git","author_index":"Devmacy"}]