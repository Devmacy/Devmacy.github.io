{"title":"Slideshow","uid":"ce8d4e25ac25aaa27d96a2f188be8be7","slug":"Slideshow","date":"2023-07-29T10:00:19.313Z","updated":"2023-07-29T10:00:19.422Z","comments":true,"path":"api/articles/Slideshow.json","keywords":"Digital Garden","cover":[],"content":"<p>&#x2F;*</p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/JwgtCrIVeEU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n<p><img src=\"https://raw.githubusercontent.com/zsviczian/obsidian-excalidraw-plugin/master/images/scripts-slideshow-2.jpg\"><br>The script will convert your drawing into a slideshow presentation.<br>If you select an arrow or line element, the script will use that as the presentation path.<br>If you select nothing, but the file has a hidden presentation path, the script will use that for determining the slide sequence.<br>If there are frames, the script will use the frames for the presentation. Frames are played in alphabetical order of their titles.</p>\n<pre><code class=\"javascript\">*/\nif(!ea.verifyMinimumPluginVersion || !ea.verifyMinimumPluginVersion(&quot;1.8.17&quot;)) &#123;\n  new Notice(&quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;);\n  return;\n&#125;\n\nconst statusBarElement = document.querySelector(&quot;div.status-bar&quot;);\nconst ctrlKey = ea.targetView.modifierKeyDown.ctrlKey || ea.targetView.modifierKeyDown.metaKey;\nconst altKey = ea.targetView.modifierKeyDown.altKey || ctrlKey;\n\n//-------------------------------\n//constants\n//-------------------------------\nconst TRANSITION_STEP_COUNT = 100;\nconst TRANSITION_DELAY = 1000; //maximum time for transition between slides in milliseconds\nconst FRAME_SLEEP = 1; //milliseconds\nconst EDIT_ZOOMOUT = 0.7; //70% of original slide zoom, set to a value between 1 and 0\nconst FADE_LEVEL = 0.15; //opacity of the slideshow controls after fade delay (value between 0 and 1)\n//using outerHTML because the SVG object returned by Obsidin is in the main workspace window\n//but excalidraw might be open in a popout window which has a different document object\nconst SVG_COG = ea.obsidian.getIcon(&quot;lucide-settings&quot;).outerHTML;\nconst SVG_FINISH = ea.obsidian.getIcon(&quot;lucide-x&quot;).outerHTML;\nconst SVG_RIGHT_ARROW = ea.obsidian.getIcon(&quot;lucide-arrow-right&quot;).outerHTML;\nconst SVG_LEFT_ARROW = ea.obsidian.getIcon(&quot;lucide-arrow-left&quot;).outerHTML;\nconst SVG_EDIT = ea.obsidian.getIcon(&quot;lucide-pencil&quot;).outerHTML;\nconst SVG_MAXIMIZE = ea.obsidian.getIcon(&quot;lucide-maximize&quot;).outerHTML;\nconst SVG_MINIMIZE = ea.obsidian.getIcon(&quot;lucide-minimize&quot;).outerHTML;\n\n//-------------------------------\n//utility &amp; convenience functions\n//-------------------------------\nlet slide = 0;\nlet isFullscreen = false;\nconst ownerDocument = ea.targetView.ownerDocument;\nconst startFullscreen = !altKey;\n//The plugin and Obsidian App run in the window object\n//When Excalidraw is open in a popout window, the Excalidraw component will run in the ownerWindow\n//and in this case ownerWindow !== window\n//For this reason event handlers are distributed between window and owner window depending on their role\nconst ownerWindow = ea.targetView.ownerWindow;\nconst excalidrawAPI = ea.getExcalidrawAPI();\nconst contentEl = ea.targetView.contentEl;\nconst sleep = async (ms) =&gt; new Promise((resolve) =&gt; ownerWindow.setTimeout(resolve, ms));\n\n//-------------------------------\n//clean up potential clutter from previous run\n//-------------------------------\nwindow.removePresentationEventHandlers?.();\n\n//1. check if line or arrow is selected, if not check if frames are available, if not inform the user and terminate presentation\nlet presentationPathLineEl = ea.getViewElements()\n  .filter(el=&gt;[&quot;line&quot;,&quot;arrow&quot;].contains(el.type) &amp;&amp; el.customData?.slideshow)[0];\nlet frames = ea.getViewElements()\n  .filter(el=&gt;el.type===&quot;frame&quot;)\n  .map((f,i)=&gt;[f,i]) //because frame.name is null until set\n  .sort((el1,el2)=&gt;((el1[0].name??`Frame $&#123;el1[1]&#125;`)&gt;(el2[0].name??`Frame $&#123;el2[1]&#125;`))?1:-1)\n  .map(el=&gt;el[0]); \nlet presentationPathType = &quot;line&quot;; // &quot;frame&quot;\nconst selectedEl = ea.getViewSelectedElement();\nlet shouldHideArrowAfterPresentation = true; //this controls if the hide arrow button is available in settings\nif(presentationPathLineEl &amp;&amp; selectedEl &amp;&amp; [&quot;line&quot;,&quot;arrow&quot;].contains(selectedEl.type)) &#123;\n  excalidrawAPI.setToast(&#123;\n    message:&quot;Using selected line instead of hidden line. Note that there is a hidden presentation path for this drawing. Run the slideshow script without selecting any elements to access the hidden presentation path&quot;,\n    duration: 5000,\n    closable: true\n  &#125;)\n  shouldHideArrowAfterPresentation = false;\n  presentationPathLineEl = selectedEl;\n&#125;\nif(!presentationPathLineEl) presentationPathLineEl = selectedEl;\nif(!presentationPathLineEl || ![&quot;line&quot;,&quot;arrow&quot;].contains(presentationPathLineEl.type)) &#123;\n    if(frames.length &gt; 0) &#123;\n      presentationPathType = &quot;frame&quot;;\n    &#125; else &#123;\n      excalidrawAPI.setToast(&#123;\n        message:&quot;Please select the line or arrow for the presentation path or add frames.&quot;,\n        duration: 3000,\n        closable: true\n      &#125;)\n      return;\n    &#125;\n&#125;\n\n//---------------------------------------------\n// generate slides[] array\n//---------------------------------------------\nlet slides = [];\n\nif(presentationPathType === &quot;line&quot;) &#123;\n    const getLineSlideRect = (&#123;pointA, pointB&#125;) =&gt; &#123;\n      const x1 = presentationPathLineEl.x+pointA[0];\n      const y1 = presentationPathLineEl.y+pointA[1];\n      const x2 = presentationPathLineEl.x+pointB[0];\n      const y2 = presentationPathLineEl.y+pointB[1];\n      return &#123; x1, y1, x2, y2&#125;;\n    &#125;\n    \n    const slideCount = Math.floor(presentationPathLineEl.points.length/2)-1;\n    for(i=0;i&lt;=slideCount;i++) &#123;\n      slides.push(getLineSlideRect(&#123;\n        pointA:presentationPathLineEl.points[i*2],\n        pointB:presentationPathLineEl.points[i*2+1]\n      &#125;))\n    &#125;\n&#125;\n\nif(presentationPathType === &quot;frame&quot;) &#123;\n    for(frame of frames) &#123;\n        slides.push(&#123;\n          x1: frame.x,\n          y1: frame.y,\n          x2: frame.x + frame.width,\n          y2: frame.y + frame.height\n        &#125;);\n    &#125;\n    excalidrawAPI.updateScene(&#123;appState:&#123;shouldRenderFrames:false&#125;&#125;);\n&#125;\n\n//---------------------------------------\n// Toggle fullscreen\n//---------------------------------------\nlet toggleFullscreenButton;\nlet controlPanelEl;\nlet selectSlideDropdown;\n\nconst resetControlPanelElPosition = () =&gt; &#123;\n  if(!controlPanelEl) return;\n  const top = contentEl.innerHeight; \n  const left = contentEl.innerWidth/2; \n  controlPanelEl.style.top = `calc($&#123;top&#125;px - var(--default-button-size)*2)`;\n  controlPanelEl.style.left = `calc($&#123;left&#125;px - var(--default-button-size)*5)`;\n  slide--;\n  navigate(&quot;fwd&quot;);\n&#125;\n\nconst waitForExcalidrawResize = async () =&gt; &#123;\n  await sleep(100);\n    const deltaWidth = () =&gt; Math.abs(contentEl.clientWidth-excalidrawAPI.getAppState().width);\n    const deltaHeight = () =&gt; Math.abs(contentEl.clientHeight-excalidrawAPI.getAppState().height);\n    let watchdog = 0;\n    while ((deltaWidth()&gt;50 || deltaHeight()&gt;50) &amp;&amp; watchdog++&lt;20) await sleep(50); //wait for Excalidraw to resize to fullscreen\n&#125;\n\nlet preventFullscreenExit = true;\nconst gotoFullscreen = async () =&gt; &#123;\n  if(isFullscreen) return;\n  preventFullscreenExit = true;\n    if(app.isMobile) &#123;\n      ea.viewToggleFullScreen();\n    &#125; else &#123;\n        await contentEl.webkitRequestFullscreen();\n    &#125;\n    await waitForExcalidrawResize();\n    const layerUIWrapper = contentEl.querySelector(&quot;.layer-ui__wrapper&quot;);\n    if(!layerUIWrapper.hasClass(&quot;excalidraw-hidden&quot;)) layerUIWrapper.addClass(&quot;excalidraw-hidden&quot;);\n    if(toggleFullscreenButton) toggleFullscreenButton.innerHTML = SVG_MINIMIZE;\n    resetControlPanelElPosition();\n    isFullscreen = true;\n&#125;\n\nconst exitFullscreen = async () =&gt; &#123;\n  if(!isFullscreen) return;\n  preventFullscreenExit = true;\n  if(!app.isMobile &amp;&amp; ownerDocument?.fullscreenElement) await ownerDocument.exitFullscreen();\n  if(app.isMobile) ea.viewToggleFullScreen();\n  if(toggleFullscreenButton) toggleFullscreenButton.innerHTML = SVG_MAXIMIZE;\n  await waitForExcalidrawResize();\n  resetControlPanelElPosition();\n  isFullscreen = false;\n&#125;\n\nconst toggleFullscreen = async () =&gt; &#123;\n if (isFullscreen) &#123;\n   await exitFullscreen();\n &#125; else &#123;\n     await gotoFullscreen();\n &#125;\n&#125;\n\n//-----------------------------------------------------\n// hide the arrow for the duration of the presentation\n// and save the arrow color before doing so\n//-----------------------------------------------------\nlet isHidden;\nlet originalProps;\nconst toggleArrowVisibility = async (setToHidden) =&gt; &#123;\n    ea.clear();\n    ea.copyViewElementsToEAforEditing(ea.getViewElements().filter(el=&gt;el.id === presentationPathLineEl.id));\n    const el = ea.getElement(presentationPathLineEl.id);\n    el.strokeColor = &quot;transparent&quot;;\n    el.backgroundColor = &quot;transparent&quot;;\n    const customData = el.customData;\n    if(setToHidden &amp;&amp; shouldHideArrowAfterPresentation) &#123;\n        el.locked = true;\n        el.customData = &#123;\n            ...customData,\n            slideshow: &#123;\n                originalProps,\n                hidden: true\n            &#125;\n        &#125;\n        isHidden = true;\n    &#125; else &#123;\n        if(customData) delete el.customData.slideshow;\n        isHidden = false;\n    &#125;\n    await ea.addElementsToView();\n&#125;\n\nif(presentationPathType===&quot;line&quot;) &#123;\n    originalProps = presentationPathLineEl.customData?.slideshow?.hidden\n      ? presentationPathLineEl.customData.slideshow.originalProps\n      : &#123;\n          strokeColor: presentationPathLineEl.strokeColor,\n          backgroundColor: presentationPathLineEl.backgroundColor,\n          locked: presentationPathLineEl.locked,\n      &#125;;\n    isHidden = presentationPathLineEl.customData?.slideshow?.hidden ?? false;\n&#125;\n\n//-----------------------------\n// scroll-to-location functions\n//-----------------------------\nconst getNavigationRect = (&#123; x1, y1, x2, y2 &#125;) =&gt; &#123;\n  const &#123; width, height &#125; = excalidrawAPI.getAppState();\n  const ratioX = width / Math.abs(x1 - x2);\n  const ratioY = height / Math.abs(y1 - y2);\n  let ratio = Math.min(Math.max(ratioX, ratioY), 10);\n\n  const scaledWidth = Math.abs(x1 - x2) * ratio;\n  const scaledHeight = Math.abs(y1 - y2) * ratio;\n\n  if (scaledWidth &gt; width || scaledHeight &gt; height) &#123;\n    ratio = Math.min(width / Math.abs(x1 - x2), height / Math.abs(y1 - y2));\n  &#125;\n\n  const deltaX = (width / ratio - Math.abs(x1 - x2)) / 2;\n  const deltaY = (height / ratio - Math.abs(y1 - y2)) / 2;\n\n  return &#123;\n    left: (x1 &lt; x2 ? x1 : x2) - deltaX,\n    top: (y1 &lt; y2 ? y1 : y2) - deltaY,\n    right: (x1 &lt; x2 ? x2 : x1) + deltaX,\n    bottom: (y1 &lt; y2 ? y2 : y1) + deltaY,\n    nextZoom: ratio,\n  &#125;;\n&#125;;\n\nconst getNextSlideRect = (forward) =&gt; &#123;\n  slide = forward\n    ? slide &lt; slides.length-1 ? slide + 1     : 0\n    : slide &lt;= 0            ? slides.length-1 : slide - 1;\n    return getNavigationRect(slides[slide]);\n&#125;\n\nlet busy = false;\nconst scrollToNextRect = async (&#123;left,top,right,bottom,nextZoom&#125;,steps = TRANSITION_STEP_COUNT) =&gt; &#123;\n  const startTimer = Date.now();\n  let watchdog = 0;\n  while(busy &amp;&amp; watchdog++&lt;15) await(100);\n  if(busy &amp;&amp; watchdog &gt;= 15) return;\n  busy = true;\n  excalidrawAPI.updateScene(&#123;appState:&#123;shouldCacheIgnoreZoom:true&#125;&#125;);\n  const &#123;scrollX, scrollY, zoom&#125; = excalidrawAPI.getAppState();\n  const zoomStep = (zoom.value-nextZoom)/steps;\n  const xStep = (left+scrollX)/steps;\n  const yStep = (top+scrollY)/steps;\n  let i=1;\n  while(i&lt;=steps) &#123;\n    excalidrawAPI.updateScene(&#123;\n      appState: &#123;\n        scrollX:scrollX-(xStep*i),\n        scrollY:scrollY-(yStep*i),\n        zoom:&#123;value:zoom.value-zoomStep*i&#125;,\n      &#125;\n    &#125;);\n    const ellapsed = Date.now()-startTimer;\n    if(ellapsed &gt; TRANSITION_DELAY) &#123;\n      i = i&lt;steps ? steps : steps+1;\n    &#125; else &#123;\n      const timeProgress = ellapsed / TRANSITION_DELAY;\n      i=Math.min(Math.round(steps*timeProgress),steps)\n      await sleep(FRAME_SLEEP);\n    &#125;\n  &#125;\n  excalidrawAPI.updateScene(&#123;appState:&#123;shouldCacheIgnoreZoom:false&#125;&#125;);\n  busy = false;\n&#125;\n\nconst navigate = async (dir) =&gt; &#123;\n  const forward = dir === &quot;fwd&quot;;\n  const prevSlide = slide;\n  const nextRect = getNextSlideRect(forward);\n  \n  //exit if user navigates from last slide forward or first slide backward\n  const shouldExit = forward\n    ? slide&lt;=prevSlide\n    : slide&gt;=prevSlide;\n  if(shouldExit) &#123;\n    exitPresentation();\n    return;\n  &#125;\n  if(selectSlideDropdown) selectSlideDropdown.value = slide+1;\n  await scrollToNextRect(nextRect);\n&#125;\n\nconst navigateToSlide = (slideNumber) =&gt; &#123;\n  if(slideNumber &gt; slides.length) slideNumber = slides.length;\n  if(slideNumber &lt; 1) slideNumber = 1;\n  slide = slideNumber - 2;\n  navigate(&quot;fwd&quot;);\n&#125;\n\n//--------------------------------------\n// Slideshow control panel\n//--------------------------------------\nlet controlPanelFadeTimout = 0;\nconst setFadeTimeout = (delay) =&gt; &#123;\n  delay = delay ?? TRANSITION_DELAY;\n  controlPanelFadeTimeout = ownerWindow.setTimeout(()=&gt;&#123;\n    controlPanelFadeTimout = 0;\n    if(ownerDocument.activeElement === selectSlideDropdown) &#123;\n      setFadeTimeout(delay);\n      return;\n    &#125;\n      controlPanelEl.style.opacity = FADE_LEVEL;\n  &#125;,delay);\n&#125;\nconst clearFadeTimeout = () =&gt; &#123;\n  if(controlPanelFadeTimeout) &#123;\n      ownerWindow.clearTimeout(controlPanelFadeTimeout);\n      controlPanelFadeTimeout = 0;\n  &#125;\n  controlPanelEl.style.opacity = 1;\n&#125;\n\nconst createPresentationNavigationPanel = () =&gt; &#123;\n  //create slideshow controlpanel container\n  const top = contentEl.innerHeight; \n  const left = contentEl.innerWidth/2; \n  controlPanelEl = contentEl.querySelector(&quot;.excalidraw&quot;).createDiv(&#123;\n    cls: [&quot;excalidraw-presentation-panel&quot;],\n    attr: &#123;\n      style: `\n        width: fit-content;\n        z-index:5;\n        position: absolute;\n        top:calc($&#123;top&#125;px - var(--default-button-size)*2);\n        left:calc($&#123;left&#125;px - var(--default-button-size)*5);`\n    &#125;\n  &#125;);\n  setFadeTimeout(TRANSITION_DELAY*3);\n  \n  const panelColumn = controlPanelEl.createDiv(&#123;\n    cls: &quot;panelColumn&quot;,\n  &#125;);\n  \n    panelColumn.createDiv(&#123;\n      cls: [&quot;Island&quot;, &quot;buttonList&quot;],\n      attr: &#123;\n        style: `\n          max-width: unset;\n          justify-content: space-between;\n          height: calc(var(--default-button-size)*1.5);\n          width: 100%;\n          background: var(--island-bg-color);\n          display: flex;\n          align-items: center;`,\n      &#125;\n    &#125;, el=&gt;&#123;\n      el.createEl(&quot;style&quot;, \n        &#123; text: ` select:focus &#123; box-shadow: var(--input-shadow);&#125; `&#125;);\n      el.createEl(&quot;button&quot;,&#123;\n        attr: &#123;\n          style: `\n            margin-left: calc(var(--default-button-size)*0.25);`,\n          &quot;aria-label&quot;: &quot;Previous slide&quot;,\n          title: &quot;Previous slide&quot;\n        &#125;\n      &#125;, button =&gt; &#123;\n        button.innerHTML = SVG_LEFT_ARROW;\n        button.onclick = () =&gt; navigate(&quot;bkwd&quot;)\n      &#125;);\n    selectSlideDropdown = el.createEl(&quot;select&quot;, &#123;\n      attr: &#123;\n        style: `\n          font-size: inherit;\n          background-color: var(--island-bg-color);\n          border: none;\n          color: var(--color-gray-100);\n          cursor: pointer;\n        &#125;`,\n        title: &quot;Navigate to slide&quot;\n      &#125;\n    &#125;, selectEl =&gt; &#123;\n        for (let i = 0; i &lt; slides.length; i++) &#123;\n          const option = document.createElement(&quot;option&quot;);\n          option.text = `Slide $&#123;i + 1&#125;/$&#123;slides.length&#125;`;\n          option.value = i + 1;\n          selectEl.add(option);\n        &#125;\n        selectEl.addEventListener(&quot;change&quot;, () =&gt; &#123;\n          const selectedSlideNumber = parseInt(selectEl.value);\n          selectEl.blur();\n          navigateToSlide(selectedSlideNumber);\n        &#125;);\n      &#125;);\n      el.createEl(&quot;button&quot;,&#123;\n        attr: &#123;\n          title: &quot;Next slide&quot;\n        &#125;,\n      &#125;, button =&gt; &#123;\n        button.innerHTML = SVG_RIGHT_ARROW;\n        button.onclick = () =&gt; navigate(&quot;fwd&quot;);\n      &#125;);\n      el.createDiv(&#123;\n          attr: &#123;\n          style: `\n            width: 1px;\n            height: var(--default-button-size);\n            background-color: var(--default-border-color);\n            margin: 0px auto;`\n          &#125;\n        &#125;);\n       el.createEl(&quot;button&quot;,&#123;\n        attr: &#123;\n          title: &quot;Toggle fullscreen. If you hold ALT/OPT when starting the presentation it will not go fullscreen.&quot;\n        &#125;,\n      &#125;, button =&gt; &#123;\n        toggleFullscreenButton = button;\n        button.innerHTML = isFullscreen ? SVG_MINIMIZE : SVG_MAXIMIZE;\n        button.onclick = () =&gt; toggleFullscreen();\n      &#125;);\n      if(presentationPathType === &quot;line&quot;) &#123;\n        if(shouldHideArrowAfterPresentation) &#123;\n            new ea.obsidian.ToggleComponent(el)\n              .setValue(isHidden)\n              .onChange(value =&gt; &#123;\n                if(value) &#123;\n                  excalidrawAPI.setToast(&#123;\n                            message:&quot;The presentation path remain hidden after the presentation. No need to select the line again. Just click the slideshow button to start the next presentation.&quot;,\n                            duration: 5000,\n                            closable: true\n                          &#125;)\n                &#125;\n                toggleArrowVisibility(value);\n              &#125;)\n              .toggleEl.setAttribute(&quot;title&quot;,&quot;Arrow visibility. ON: hidden after presentation, OFF: visible after presentation&quot;);\n          &#125;\n          el.createEl(&quot;button&quot;,&#123;\n            attr: &#123;\n              title: &quot;Edit slide&quot;\n            &#125;,\n          &#125;, button =&gt; &#123;\n            button.innerHTML = SVG_EDIT;\n            button.onclick = () =&gt; &#123;\n              if(shouldHideArrowAfterPresentation) toggleArrowVisibility(false);\n              exitPresentation(true);\n            &#125;\n          &#125;);\n        &#125;\n      el.createEl(&quot;button&quot;,&#123;\n        attr: &#123;\n          style: `\n            margin-right: calc(var(--default-button-size)*0.25);`,\n          title: &quot;End presentation&quot;\n        &#125;\n      &#125;, button =&gt; &#123;\n        button.innerHTML = SVG_FINISH;\n        button.onclick = () =&gt; exitPresentation()\n      &#125;);\n    &#125;);\n&#125;\n\n//--------------------\n// keyboard navigation\n//--------------------\nconst keydownListener = (e) =&gt; &#123;\n  if(ea.targetView.leaf !== app.workspace.activeLeaf) return;\n  e.preventDefault();\n  switch(e.key) &#123;\n    case &quot;Escape&quot;:\n      exitPresentation();\n      break;\n    case &quot;ArrowRight&quot;:\n    case &quot;ArrowDown&quot;: \n      navigate(&quot;fwd&quot;);\n      break;\n    case &quot;ArrowLeft&quot;:\n    case &quot;ArrowUp&quot;:\n      navigate(&quot;bkwd&quot;);\n      break;\n    case &quot;End&quot;:\n      slide = slides.length - 2;\n      navigate(&quot;fwd&quot;);\n      break;\n    case &quot;Home&quot;:\n      slide = -1;\n      navigate(&quot;fwd&quot;);\n      break;\n    case &quot;e&quot;: \n      if(presentationPathType !== &quot;line&quot;) return;\n      (async ()=&gt;&#123;\n        await toggleArrowVisibility(false);\n        exitPresentation(true);\n      &#125;)()\n      break;\n  &#125;\n&#125;\n\n//---------------------\n// slideshow panel drag\n//---------------------\nlet posX1 = posY1 = posX2 = posY2 = 0;\n\nconst updatePosition = (deltaY = 0, deltaX = 0) =&gt; &#123;\n  const &#123;\n    offsetTop,\n    offsetLeft,\n    clientWidth: width,\n    clientHeight: height,\n   &#125; = controlPanelEl;\n  controlPanelEl.style.top = (offsetTop - deltaY) + &#39;px&#39;;\n  controlPanelEl.style.left = (offsetLeft - deltaX) + &#39;px&#39;;\n&#125;\n   \nconst onPointerUp = () =&gt; &#123;\n  ownerWindow.removeEventListener(&#39;pointermove&#39;, onDrag, true);\n&#125;\n\nconst onPointerDown = (e) =&gt; &#123;\n    clearFadeTimeout();\n    setFadeTimeout();\n  const now = Date.now();\n  posX2 = e.clientX;\n  posY2 = e.clientY;\n  ownerWindow.addEventListener(&#39;pointermove&#39;, onDrag, true);\n&#125;\n\nconst onDrag = (e) =&gt; &#123;\n  e.preventDefault();\n  posX1 = posX2 - e.clientX;\n  posY1 = posY2 - e.clientY;\n  posX2 = e.clientX;\n  posY2 = e.clientY;\n  updatePosition(posY1, posX1);\n&#125;\n\nconst onMouseEnter = () =&gt; &#123;\n    clearFadeTimeout();\n&#125;\n\nconst onMouseLeave = () =&gt; &#123;\n    setFadeTimeout();\n&#125;\n\nconst fullscreenListener = (e) =&gt; &#123;\n  if(preventFullscreenExit) &#123;\n      preventFullscreenExit = false;\n    return;\n  &#125;\n  e.preventDefault();\n  exitPresentation();\n&#125;\n\nconst initializeEventListners = () =&gt; &#123;\n    ownerWindow.addEventListener(&#39;keydown&#39;,keydownListener);\n  controlPanelEl.addEventListener(&#39;pointerdown&#39;, onPointerDown, false);\n  controlPanelEl.addEventListener(&#39;mouseenter&#39;, onMouseEnter, false);\n  controlPanelEl.addEventListener(&#39;mouseleave&#39;, onMouseLeave, false);\n  ownerWindow.addEventListener(&#39;pointerup&#39;, onPointerUp, false);\n\n    //event listners for terminating the presentation\n    window.removePresentationEventHandlers = () =&gt; &#123;\n      ea.onLinkClickHook = null;\n      controlPanelEl.removeEventListener(&#39;pointerdown&#39;, onPointerDown, false);\n      controlPanelEl.removeEventListener(&#39;mouseenter&#39;, onMouseEnter, false);\n      controlPanelEl.removeEventListener(&#39;mouseleave&#39;, onMouseLeave, false);\n      controlPanelEl.parentElement?.removeChild(controlPanelEl);\n      if(!app.isMobile) &#123;\n        contentEl.removeEventListener(&#39;webkitfullscreenchange&#39;, fullscreenListener);\n        contentEl.removeEventListener(&#39;fullscreenchange&#39;, fullscreenListener);\n      &#125;\n      ownerWindow.removeEventListener(&#39;keydown&#39;,keydownListener);\n      ownerWindow.removeEventListener(&#39;pointerup&#39;,onPointerUp);\n      contentEl.querySelector(&quot;.layer-ui__wrapper&quot;)?.removeClass(&quot;excalidraw-hidden&quot;);\n      delete window.removePresentationEventHandlers;\n    &#125;\n\n    ea.onLinkClickHook = () =&gt; &#123;\n    exitPresentation();\n    return true;\n  &#125;;\n  \n  if(!app.isMobile) &#123;\n    contentEl.addEventListener(&#39;webkitfullscreenchange&#39;, fullscreenListener);\n    contentEl.addEventListener(&#39;fullscreenchange&#39;, fullscreenListener);\n  &#125;\n&#125;\n\n//----------------------------\n// Exit presentation\n//----------------------------\nconst exitPresentation = async (openForEdit = false) =&gt; &#123;\n  statusBarElement.style.display = &quot;inherit&quot;;\n  if(openForEdit) ea.targetView.preventAutozoom();\n  await exitFullscreen();\n  await waitForExcalidrawResize();\n  ea.setViewModeEnabled(false);\n  if(presentationPathType === &quot;line&quot;) &#123;\n      ea.clear();\n      ea.copyViewElementsToEAforEditing(ea.getViewElements().filter(el=&gt;el.id === presentationPathLineEl.id));\n      const el = ea.getElement(presentationPathLineEl.id);\n      if(!isHidden) &#123;\n        el.strokeColor = originalProps.strokeColor;\n        el.backgroundProps = originalProps.backgroundColor;\n        el.locked = openForEdit ? false : originalProps.locked;\n      &#125;\n      await ea.addElementsToView();\n      if(!isHidden) ea.selectElementsInView([el]);\n      if(openForEdit) &#123;\n        let nextRect = getNextSlideRect(--slide);\n        const offsetW = (nextRect.right-nextRect.left)*(1-EDIT_ZOOMOUT)/2;\n        const offsetH = (nextRect.bottom-nextRect.top)*(1-EDIT_ZOOMOUT)/2\n        nextRect = &#123;\n          left: nextRect.left-offsetW,\n          right: nextRect.right+offsetW,\n          top: nextRect.top-offsetH,\n          bottom: nextRect.bottom+offsetH,\n          nextZoom: nextRect.nextZoom*EDIT_ZOOMOUT &gt; 0.1 ? nextRect.nextZoom*EDIT_ZOOMOUT : 0.1 //0.1 is the minimu zoom value\n        &#125;;\n        await scrollToNextRect(nextRect,1);\n        excalidrawAPI.startLineEditor(\n          ea.getViewSelectedElement(),\n          [slide*2,slide*2+1]\n        );\n      &#125;\n    &#125; else &#123;\n      excalidrawAPI.updateScene(&#123;appState:&#123;shouldRenderFrames:true&#125;&#125;);\n    &#125;\n  window.removePresentationEventHandlers?.();\n  ownerWindow.setTimeout(()=&gt;&#123;\n    //Resets pointer offsets. Ugly solution. \n    //During testing offsets were wrong after presentation, but don&#39;t know why.\n    //This should solve it even if they are wrong.\n    ea.targetView.refresh(); \n  &#125;)\n&#125;\n\n//--------------------------\n// Start presentation or open presentation settings on double click\n//--------------------------\nconst start = async () =&gt; &#123;\n  statusBarElement.style.display = &quot;none&quot;;\n  ea.setViewModeEnabled(true);\n  createPresentationNavigationPanel();\n  initializeEventListners();\n  if(startFullscreen) &#123;\n    await gotoFullscreen();\n  &#125; else &#123;\n    resetControlPanelElPosition();\n  &#125;\n  if(presentationPathType === &quot;line&quot;) await toggleArrowVisibility(isHidden);\n&#125;\n\nconst timestamp = Date.now();\nif(window.ExcalidrawSlideshow &amp;&amp; (window.ExcalidrawSlideshow.script === utils.scriptFile.path) &amp;&amp; (timestamp - window.ExcalidrawSlideshow.timestamp &lt;400) ) &#123;\n  if(window.ExcalidrawSlideshowStartTimer) &#123;\n    window.clearTimeout(window.ExcalidrawSlideshowStartTimer);\n    delete window.ExcalidrawSlideshowStartTimer;\n  &#125;\n  await start();\n&#125; else &#123;\n  if(window.ExcalidrawSlideshowStartTimer) &#123;\n    window.clearTimeout(window.ExcalidrawSlideshowStartTimer);\n    delete window.ExcalidrawSlideshowStartTimer;\n  &#125;\n  window.ExcalidrawSlideshow = &#123;\n    script: utils.scriptFile.path,\n    timestamp\n  &#125;;\n  window.ExcalidrawSlideshowStartTimer = window.setTimeout(start,500);\n&#125;\n</code></pre>\n","text":"&#x2F;* The script will convert your drawing into a slideshow presentation.If you select an arrow or line element, the script will use that ...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"Devmacy","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/01/24/pSYhwB4.jpg","link":"/","description":"数字花园","socials":{"github":"https://github.com/Devmacy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Split text by lines","uid":"c45800b27edeeb531f5f9c3216180b5e","slug":"Split text by lines","date":"2023-07-29T10:00:19.315Z","updated":"2023-07-29T10:00:19.422Z","comments":true,"path":"api/articles/Split text by lines.json","keywords":"Digital Garden","cover":[],"text":"&#x2F;* requires Excalidraw 1.5.1 or higher Download this file and save to your Obsidian Vault including the first line, or open it in “Raw”...","link":"","photos":[],"count_time":{"symbolsCount":848,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Devmacy","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/01/24/pSYhwB4.jpg","link":"/","description":"数字花园","socials":{"github":"https://github.com/Devmacy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Set Text Alignment","uid":"d37cd5b7639fe7782428852b11a0610c","slug":"Set Text Alignment","date":"2023-07-29T10:00:19.310Z","updated":"2023-07-29T10:00:19.418Z","comments":true,"path":"api/articles/Set Text Alignment.json","keywords":"Digital Garden","cover":[],"text":"&#x2F;* Sets text alignment of text block (cetner, right, left). Useful if you want to set a keyboard shortcut for selecting text alignment....","link":"","photos":[],"count_time":{"symbolsCount":623,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Devmacy","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/01/24/pSYhwB4.jpg","link":"/","description":"数字花园","socials":{"github":"https://github.com/Devmacy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}