{"title":"Mindmap format","uid":"a270c09cac3c70483286bc10905557fc","slug":"Mindmap format","date":"2023-07-29T10:00:19.273Z","updated":"2023-07-29T10:00:19.392Z","comments":true,"path":"api/articles/Mindmap format.json","keywords":"Digital Garden","cover":[],"content":"<p>&#x2F;*</p>\n<p>format <strong>the left to right</strong> mind map</p>\n<p><img src=\"https://raw.githubusercontent.com/zsviczian/obsidian-excalidraw-plugin/master/images/scripts-mindmap-format-1.png\"></p>\n<h1 id=\"tree\"><a href=\"#tree\" class=\"headerlink\" title=\"tree\"></a>tree</h1><p>Mind map is actually a tree, so you must have a <strong>root node</strong>. The script will determine <strong>the leftmost element</strong> of the selected element as the root element (node is excalidraw element, e.g. rectangle, diamond, ellipse, text, image, but it can’t be arrow, line, freedraw, <strong>group</strong>)</p>\n<p>The element connecting node and node must be an <strong>arrow</strong> and  have the correct direction, e.g. <strong>parent node -&gt; children node</strong></p>\n<h1 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h1><p>The order of nodes in the Y axis or vertical direction is determined by <strong>the creation time</strong> of the arrow connecting it</p>\n<p><img src=\"https://raw.githubusercontent.com/zsviczian/obsidian-excalidraw-plugin/master/images/scripts-mindmap-format-2.png\"></p>\n<p>So if you want to readjust the order, you can <strong>delete arrows and reconnect them</strong></p>\n<h1 id=\"setting\"><a href=\"#setting\" class=\"headerlink\" title=\"setting\"></a>setting</h1><p>Script provides options to adjust the style of mind map, The option is at the bottom of the option of the exalidraw plugin(e.g. Settings -&gt; Community plugins -&gt; Excalidraw -&gt; drag to bottom)</p>\n<h1 id=\"problem\"><a href=\"#problem\" class=\"headerlink\" title=\"problem\"></a>problem</h1><ol>\n<li>since the start bingding and end bingding of the arrow are easily disconnected from the node, so if there are unformatted parts, please <strong>check the connection</strong> and use the script to <strong>reformat</strong></li>\n</ol>\n<pre><code class=\"javascript\">*/\n\nlet settings = ea.getScriptSettings();\n//set default values on first run\nif (!settings[&quot;MindMap Format&quot;]) &#123;\n  settings = &#123;\n    &quot;MindMap Format&quot;: &#123;\n      value: &quot;Excalidraw/MindMap Format&quot;,\n      description:\n        &quot;This is prepared for the namespace of MindMap Format and does not need to be modified&quot;,\n    &#125;,\n    &quot;default gap&quot;: &#123;\n      value: 10,\n      description: &quot;Interval size of element&quot;,\n    &#125;,\n    &quot;curve length&quot;: &#123;\n      value: 40,\n      description: &quot;The length of the curve part in the mind map line&quot;,\n    &#125;,\n    &quot;length between element and line&quot;: &#123;\n      value: 50,\n      description:\n        &quot;The distance between the tail of the connection and the connecting elements of the mind map&quot;,\n    &#125;,\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125;\n\nconst sceneElements = ea.getExcalidrawAPI().getSceneElements();\n\n// default X coordinate of the middle point of the arc\nconst defaultDotX = Number(settings[&quot;curve length&quot;].value);\n// The default length from the middle point of the arc on the X axis\nconst defaultLengthWithCenterDot = Number(\n  settings[&quot;length between element and line&quot;].value\n);\n// Initial trimming distance of the end point on the Y axis\nconst initAdjLength = 4;\n// default gap\nconst defaultGap = Number(settings[&quot;default gap&quot;].value);\n\nconst setCenter = (parent, line) =&gt; &#123;\n  // Focus and gap need the api calculation of excalidraw\n  // e.g. determineFocusDistance, but they are not available now\n  // so they are uniformly set to 0/1\n  line.startBinding.focus = 0;\n  line.startBinding.gap = 1;\n  line.endBinding.focus = 0;\n  line.endBinding.gap = 1;\n  line.x = parent.x + parent.width;\n  line.y = parent.y + parent.height / 2;\n&#125;;\n\n/**\n * set the middle point of curve\n * @param &#123;any&#125; lineEl the line element of excalidraw\n * @param &#123;number&#125; height height of dot on Y axis\n * @param &#123;number&#125; [ratio=1] ，coefficient of the initial trimming distance of the end point on the Y axis, default is 1\n */\nconst setTopCurveDotOnLine = (lineEl, height, ratio = 1) =&gt; &#123;\n  if (lineEl.points.length &lt; 3) &#123;\n    lineEl.points.splice(1, 0, [defaultDotX, lineEl.points[0][1] - height]);\n  &#125; else if (lineEl.points.length === 3) &#123;\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] - height];\n  &#125; else &#123;\n    lineEl.points.splice(2, lineEl.points.length - 3);\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] - height];\n  &#125;\n  lineEl.points[2][0] = lineEl.points[1][0] + defaultLengthWithCenterDot;\n  // adjust the curvature of the second line segment\n  lineEl.points[2][1] = lineEl.points[1][1] - initAdjLength * ratio * 0.8;\n&#125;;\n\nconst setMidCurveDotOnLine = (lineEl) =&gt; &#123;\n  if (lineEl.points.length &lt; 3) &#123;\n    lineEl.points.splice(1, 0, [defaultDotX, lineEl.points[0][1]]);\n  &#125; else if (lineEl.points.length === 3) &#123;\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1]];\n  &#125; else &#123;\n    lineEl.points.splice(2, lineEl.points.length - 3);\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1]];\n  &#125;\n  lineEl.points[2][0] = lineEl.points[1][0] + defaultLengthWithCenterDot;\n  lineEl.points[2][1] = lineEl.points[1][1];\n&#125;;\n\n/**\n * set the middle point of curve\n * @param &#123;any&#125; lineEl the line element of excalidraw\n * @param &#123;number&#125; height height of dot on Y axis\n * @param &#123;number&#125; [ratio=1] ，coefficient of the initial trimming distance of the end point on the Y axis, default is 1\n */\nconst setBottomCurveDotOnLine = (lineEl, height, ratio = 1) =&gt; &#123;\n  if (lineEl.points.length &lt; 3) &#123;\n    lineEl.points.splice(1, 0, [defaultDotX, lineEl.points[0][1] + height]);\n  &#125; else if (lineEl.points.length === 3) &#123;\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] + height];\n  &#125; else &#123;\n    lineEl.points.splice(2, lineEl.points.length - 3);\n    lineEl.points[1] = [defaultDotX, lineEl.points[0][1] + height];\n  &#125;\n  lineEl.points[2][0] = lineEl.points[1][0] + defaultLengthWithCenterDot;\n  // adjust the curvature of the second line segment\n  lineEl.points[2][1] = lineEl.points[1][1] + initAdjLength * ratio * 0.8;\n&#125;;\n\nconst setTextXY = (rect, text) =&gt; &#123;\n  text.x = rect.x + (rect.width - text.width) / 2;\n  text.y = rect.y + (rect.height - text.height) / 2;\n&#125;;\n\nconst setChildrenXY = (parent, children, line, elementsMap) =&gt; &#123;\n  x = parent.x + parent.width + line.points[2][0];\n  y = parent.y + parent.height / 2 + line.points[2][1] - children.height / 2;\n  distX = children.x - x;\n  distY = children.y - y;\n\n  ea.getElementsInTheSameGroupWithElement(children, sceneElements).forEach((el) =&gt; &#123;\n    el.x = el.x - distX;\n    el.y = el.y - distY;\n  &#125;);\n\n  if (\n    [&quot;rectangle&quot;, &quot;diamond&quot;, &quot;ellipse&quot;].includes(children.type) &amp;&amp;\n    ![null, undefined].includes(children.boundElements)\n  ) &#123;\n    const textDesc = children.boundElements.filter(\n      (el) =&gt; el.type === &quot;text&quot;\n    )[0];\n    if (textDesc !== undefined) &#123;\n      const textEl = elementsMap.get(textDesc.id);\n      setTextXY(children, textEl);\n    &#125;\n  &#125;\n&#125;;\n\n/**\n * returns the height of the upper part of all child nodes\n * and the height of the lower part of all child nodes\n * @param &#123;Number[]&#125; childrenTotalHeightArr\n * @returns &#123;Number[]&#125; [topHeight, bottomHeight]\n */\nconst getNodeCurrentHeight = (childrenTotalHeightArr) =&gt; &#123;\n  if (childrenTotalHeightArr.length &lt;= 0) return [0, 0];\n  else if (childrenTotalHeightArr.length === 1)\n    return [childrenTotalHeightArr[0] / 2, childrenTotalHeightArr[0] / 2];\n  const heightArr = childrenTotalHeightArr;\n  let topHeight = 0,\n    bottomHeight = 0;\n  const isEven = heightArr.length % 2 === 0;\n  const mid = Math.floor(heightArr.length / 2);\n  const topI = mid - 1;\n  const bottomI = isEven ? mid : mid + 1;\n  topHeight = isEven ? 0 : heightArr[mid] / 2;\n  for (let i = topI; i &gt;= 0; i--) &#123;\n    topHeight += heightArr[i];\n  &#125;\n  bottomHeight = isEven ? 0 : heightArr[mid] / 2;\n  for (let i = bottomI; i &lt; heightArr.length; i++) &#123;\n    bottomHeight += heightArr[i];\n  &#125;\n  return [topHeight, bottomHeight];\n&#125;;\n\n/**\n * handle the height of each point in the single-level tree\n * @param &#123;Array&#125; lines\n * @param &#123;Map&#125; elementsMap\n * @param &#123;Boolean&#125; isEven\n * @param &#123;Number&#125; mid &#39;lines&#39; array midpoint index\n * @returns &#123;Array&#125; height array corresponding to &#39;lines&#39;\n */\nconst handleDotYValue = (lines, elementsMap, isEven, mid) =&gt; &#123;\n  const getTotalHeight = (line, elementsMap) =&gt; &#123;\n    return elementsMap.get(line.endBinding.elementId).totalHeight;\n  &#125;;\n  const getTopHeight = (line, elementsMap) =&gt; &#123;\n    return elementsMap.get(line.endBinding.elementId).topHeight;\n  &#125;;\n  const getBottomHeight = (line, elementsMap) =&gt; &#123;\n    return elementsMap.get(line.endBinding.elementId).bottomHeight;\n  &#125;;\n  const heightArr = new Array(lines.length).fill(0);\n  const upI = mid === 0 ? 0 : mid - 1;\n  const bottomI = isEven ? mid : mid + 1;\n  let initHeight = isEven ? 0 : getTopHeight(lines[mid], elementsMap);\n  for (let i = upI; i &gt;= 0; i--) &#123;\n    heightArr[i] = initHeight + getBottomHeight(lines[i], elementsMap);\n    initHeight += getTotalHeight(lines[i], elementsMap);\n  &#125;\n  initHeight = isEven ? 0 : getBottomHeight(lines[mid], elementsMap);\n  for (let i = bottomI; i &lt; lines.length; i++) &#123;\n    heightArr[i] = initHeight + getTopHeight(lines[i], elementsMap);\n    initHeight += getTotalHeight(lines[i], elementsMap);\n  &#125;\n  return heightArr;\n&#125;;\n\n/**\n * format single-level tree\n * @param &#123;any&#125; parent\n * @param &#123;Array&#125; lines\n * @param &#123;Map&#125; childrenDescMap\n * @param &#123;Map&#125; elementsMap\n */\nconst formatTree = (parent, lines, childrenDescMap, elementsMap) =&gt; &#123;\n  lines.forEach((item) =&gt; setCenter(parent, item));\n\n  const isEven = lines.length % 2 === 0;\n  const mid = Math.floor(lines.length / 2);\n  const heightArr = handleDotYValue(lines, childrenDescMap, isEven, mid);\n  lines.forEach((item, index) =&gt; &#123;\n    if (isEven) &#123;\n      if (index &lt; mid) setTopCurveDotOnLine(item, heightArr[index], index + 1);\n      else setBottomCurveDotOnLine(item, heightArr[index], index - mid + 1);\n    &#125; else &#123;\n      if (index &lt; mid) setTopCurveDotOnLine(item, heightArr[index], index + 1);\n      else if (index === mid) setMidCurveDotOnLine(item);\n      else setBottomCurveDotOnLine(item, heightArr[index], index - mid);\n    &#125;\n  &#125;);\n  lines.forEach((item) =&gt; &#123;\n    if (item.endBinding !== null) &#123;\n      setChildrenXY(\n        parent,\n        elementsMap.get(item.endBinding.elementId),\n        item,\n        elementsMap\n      );\n    &#125;\n  &#125;);\n&#125;;\n\nconst generateTree = (elements) =&gt; &#123;\n  const elIdMap = new Map([[elements[0].id, elements[0]]]);\n  let minXEl = elements[0];\n  for (let i = 1; i &lt; elements.length; i++) &#123;\n    elIdMap.set(elements[i].id, elements[i]);\n    if (\n      !(elements[i].type === &quot;arrow&quot; || elements[i].type === &quot;line&quot;) &amp;&amp;\n      elements[i].x &lt; minXEl.x\n    ) &#123;\n      minXEl = elements[i];\n    &#125;\n  &#125;\n  const root = &#123;\n    el: minXEl,\n    totalHeight: minXEl.height,\n    topHeight: 0,\n    bottomHeight: 0,\n    linkChildrensLines: [],\n    isLeafNode: false,\n    children: [],\n  &#125;;\n  const preIdSet = new Set(); // The id_set of Elements that is already in the tree, avoid a dead cycle\n  const dfsForTreeData = (root) =&gt; &#123;\n    if (preIdSet.has(root.el.id)) &#123;\n      return 0;\n    &#125;\n    preIdSet.add(root.el.id);\n    let lines = root.el.boundElements.filter(\n      (el) =&gt;\n        el.type === &quot;arrow&quot; &amp;&amp;\n        !preIdSet.has(el.id) &amp;&amp;\n        elIdMap.get(el.id)?.startBinding?.elementId === root.el.id\n    );\n    if (lines.length === 0) &#123;\n      root.isLeafNode = true;\n      root.totalHeight = root.el.height + 2 * defaultGap;\n      [root.topHeight, root.bottomHeight] = [\n        root.totalHeight / 2,\n        root.totalHeight / 2,\n      ];\n      return root.totalHeight;\n    &#125; else &#123;\n      lines = lines.map((elementDesc) =&gt; &#123;\n        preIdSet.add(elementDesc.id);\n        return elIdMap.get(elementDesc.id);\n      &#125;);\n    &#125;\n\n    const linkChildrensLines = [];\n    lines.forEach((el) =&gt; &#123;\n      const line = el;\n      if (\n        line &amp;&amp;\n        line.endBinding !== null &amp;&amp;\n        line.endBinding !== undefined &amp;&amp;\n        !preIdSet.has(elIdMap.get(line.endBinding.elementId).id)\n      ) &#123;\n        const children = elIdMap.get(line.endBinding.elementId);\n        linkChildrensLines.push(line);\n        root.children.push(&#123;\n          el: children,\n          totalHeight: 0,\n          topHeight: 0,\n          bottomHeight: 0,\n          linkChildrensLines: [],\n          isLeafNode: false,\n          children: [],\n        &#125;);\n      &#125;\n    &#125;);\n\n    let totalHeight = 0;\n    root.children.forEach((el) =&gt; (totalHeight += dfsForTreeData(el)));\n\n    root.linkChildrensLines = linkChildrensLines;\n    if (root.children.length === 0) &#123;\n      root.isLeafNode = true;\n      root.totalHeight = root.el.height + 2 * defaultGap;\n      [root.topHeight, root.bottomHeight] = [\n        root.totalHeight / 2,\n        root.totalHeight / 2,\n      ];\n    &#125; else if (root.children.length &gt; 0) &#123;\n      root.totalHeight = Math.max(root.el.height + 2 * defaultGap, totalHeight);\n      [root.topHeight, root.bottomHeight] = getNodeCurrentHeight(\n        root.children.map((item) =&gt; item.totalHeight)\n      );\n    &#125;\n\n    return totalHeight;\n  &#125;;\n  dfsForTreeData(root);\n  const dfsForFormat = (root) =&gt; &#123;\n    if (root.isLeafNode) return;\n    const childrenDescMap = new Map(\n      root.children.map((item) =&gt; [item.el.id, item])\n    );\n    formatTree(root.el, root.linkChildrensLines, childrenDescMap, elIdMap);\n    root.children.forEach((el) =&gt; dfsForFormat(el));\n  &#125;;\n  dfsForFormat(root);\n&#125;;\n\nconst elements = ea.getViewSelectedElements();\ngenerateTree(elements);\n\nea.copyViewElementsToEAforEditing(elements);\nawait ea.addElementsToView(false, false);\n</code></pre>\n","text":"&#x2F;* format the left to right mind map treeMind map is actually a tree, so you must have a root node. The script will determine the leftm...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#tree\"><span class=\"toc-text\">tree</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#sort\"><span class=\"toc-text\">sort</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#setting\"><span class=\"toc-text\">setting</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#problem\"><span class=\"toc-text\">problem</span></a></li></ol>","author":{"name":"Devmacy","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/01/24/pSYhwB4.jpg","link":"/","description":"数字花园","socials":{"github":"https://github.com/Devmacy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Modify background color opacity","uid":"8fc5f303927e140b24df3a557a9ee147","slug":"Modify background color opacity","date":"2023-07-29T10:00:19.275Z","updated":"2023-07-29T10:00:19.394Z","comments":true,"path":"api/articles/Modify background color opacity.json","keywords":"Digital Garden","cover":[],"text":"&#x2F;* Download this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obs...","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[],"tags":[],"author":{"name":"Devmacy","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/01/24/pSYhwB4.jpg","link":"/","description":"数字花园","socials":{"github":"https://github.com/Devmacy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Mindmap connector","uid":"5e921ced045f3ba1eac86cf604483afc","slug":"Mindmap connector","date":"2023-07-29T10:00:19.271Z","updated":"2023-07-29T10:00:19.390Z","comments":true,"path":"api/articles/Mindmap connector.json","keywords":"Digital Garden","cover":[],"text":"&#x2F;* This script creates mindmap like lines(only right and down side are available). The line will starts according to the creation time ...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"Devmacy","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/01/24/pSYhwB4.jpg","link":"/","description":"数字花园","socials":{"github":"https://github.com/Devmacy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}