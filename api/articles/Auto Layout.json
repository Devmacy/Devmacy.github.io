{"title":"Auto Layout","uid":"93126ca1dba62bd049917d90fc642684","slug":"Auto Layout","date":"2023-07-29T10:00:19.205Z","updated":"2023-07-29T10:00:19.335Z","comments":true,"path":"api/articles/Auto Layout.json","keywords":"Digital Garden","cover":[],"content":"<p>&#x2F;*</p>\n<p><img src=\"https://raw.githubusercontent.com/zsviczian/obsidian-excalidraw-plugin/master/images/scripts-download-raw.jpg\"></p>\n<p>Download this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obsidian.</p>\n<p><img src=\"https://raw.githubusercontent.com/zsviczian/obsidian-excalidraw-plugin/master/images/scripts-auto-layout.png\"></p>\n<p>This script performs automatic layout for the selected top-level grouping objects. It is powered by <a href=\"https://github.com/kieler/elkjs\">elkjs</a> and needs to be connected to the Internet.</p>\n<p>See documentation for more details:<br><a href=\"https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html\">https://zsviczian.github.io/obsidian-excalidraw-plugin/ExcalidrawScriptsEngine.html</a></p>\n<pre><code class=\"javascript\">*/\n\nif (\n  !ea.verifyMinimumPluginVersion ||\n  !ea.verifyMinimumPluginVersion(&quot;1.5.21&quot;)\n) &#123;\n  new Notice(\n    &quot;This script requires a newer version of Excalidraw. Please install the latest version.&quot;\n  );\n  return;\n&#125;\n\nsettings = ea.getScriptSettings();\n//set default values on first run\nif (!settings[&quot;Layout Options JSON&quot;]) &#123;\n  settings = &#123;\n    &quot;Layout Options JSON&quot;: &#123;\n      height: &quot;450px&quot;,\n      value: `&#123;\\n      &quot;org.eclipse.elk.layered.crossingMinimization.semiInteractive&quot;: &quot;true&quot;,\\n      &quot;org.eclipse.elk.layered.considerModelOrder.components&quot;: &quot;FORCE_MODEL_ORDER&quot;\\n&#125;`,\n      description: `You can use layout options to configure the layout algorithm. A list of all options and further details of their exact effects is available in &lt;a href=&quot;http://www.eclipse.org/elk/reference.html&quot; rel=&quot;nofollow&quot;&gt;ELK&#39;s documentation&lt;/a&gt;.`,\n    &#125;,\n  &#125;;\n  ea.setScriptSettings(settings);\n&#125; \n\nif (typeof ELK === &quot;undefined&quot;) &#123;\n  loadELK(doAutoLayout);\n&#125; else &#123;\n  doAutoLayout();\n&#125;\n\nasync function doAutoLayout() &#123;\n  const selectedElements = ea.getViewSelectedElements();\n  const groups = ea\n    .getMaximumGroups(selectedElements)\n    .map((g) =&gt; g.filter((el) =&gt; el.containerId == null)) // ignore text in stickynote\n    .filter((els) =&gt; els.length &gt; 0);\n\n  const stickynotesMap = selectedElements\n    .filter((el) =&gt; el.containerId != null)\n    .reduce((result, el) =&gt; &#123;\n      result.set(el.containerId, el);\n      return result;\n    &#125;, new Map());\n\n  const elk = new ELK();\n  const knownLayoutAlgorithms = await elk.knownLayoutAlgorithms();\n  const layoutAlgorithms = knownLayoutAlgorithms\n    .map((knownLayoutAlgorithm) =&gt; (&#123;\n      id: knownLayoutAlgorithm.id,\n      displayText:\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.layered&quot; ||\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.radial&quot; ||\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.mrtree&quot;\n          ? &quot;* &quot; +\n            knownLayoutAlgorithm.name +\n            &quot;: &quot; +\n            knownLayoutAlgorithm.description\n          : knownLayoutAlgorithm.name + &quot;: &quot; + knownLayoutAlgorithm.description,\n    &#125;))\n    .sort((lha, rha) =&gt; lha.displayText.localeCompare(rha.displayText));\n\n  const layoutAlgorithmsSimple = knownLayoutAlgorithms\n    .map((knownLayoutAlgorithm) =&gt; (&#123;\n      id: knownLayoutAlgorithm.id,\n      displayText:\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.layered&quot; ||\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.radial&quot; ||\n        knownLayoutAlgorithm.id === &quot;org.eclipse.elk.mrtree&quot;\n          ? &quot;* &quot; + knownLayoutAlgorithm.name\n          : knownLayoutAlgorithm.name,\n    &#125;))\n    .sort((lha, rha) =&gt; lha.displayText.localeCompare(rha.displayText));\n\n  // const knownOptions = knownLayoutAlgorithms\n  //   .reduce(\n  //     (result, knownLayoutAlgorithm) =&gt; [\n  //       ...result,\n  //       ...knownLayoutAlgorithm.knownOptions,\n  //     ],\n  //     []\n  //   )\n  //   .filter((value, index, self) =&gt; self.indexOf(value) === index) // remove duplicates\n  //   .sort((lha, rha) =&gt; lha.localeCompare(rha));\n  // console.log(&quot;knownOptions&quot;, knownOptions);\n\n  const selectedAlgorithm = await utils.suggester(\n    layoutAlgorithms.map((algorithmInfo) =&gt; algorithmInfo.displayText),\n    layoutAlgorithms.map((algorithmInfo) =&gt; algorithmInfo.id),\n    &quot;Layout algorithm&quot;\n  );\n\n  const knownNodePlacementStrategy = [\n    &quot;SIMPLE&quot;,\n    &quot;INTERACTIVE&quot;,\n    &quot;LINEAR_SEGMENTS&quot;,\n    &quot;BRANDES_KOEPF&quot;,\n    &quot;NETWORK_SIMPLEX&quot;,\n  ];\n\n  const knownDirections = [\n    &quot;UNDEFINED&quot;,\n    &quot;RIGHT&quot;,\n    &quot;LEFT&quot;,\n    &quot;DOWN&quot;,\n    &quot;UP&quot;\n  ];\n\n  let nodePlacementStrategy = &quot;BRANDES_KOEPF&quot;;\n  let componentComponentSpacing = &quot;10&quot;;\n  let nodeNodeSpacing = &quot;100&quot;;\n  let nodeNodeBetweenLayersSpacing = &quot;100&quot;;\n  let discoComponentLayoutAlgorithm = &quot;org.eclipse.elk.layered&quot;;\n  let direction = &quot;UNDEFINED&quot;;\n\n  if (selectedAlgorithm === &quot;org.eclipse.elk.layered&quot;) &#123;\n    nodePlacementStrategy = await utils.suggester(\n      knownNodePlacementStrategy,\n      knownNodePlacementStrategy,\n      &quot;Node placement strategy&quot;\n    );\n\n    selectedDirection = await utils.suggester(\n      knownDirections,\n      knownDirections,\n      &quot;Direction&quot;\n    );\n    direction = selectedDirection??&quot;UNDEFINED&quot;;\n  &#125; else if (selectedAlgorithm === &quot;org.eclipse.elk.disco&quot;) &#123;\n    const componentLayoutAlgorithms = layoutAlgorithmsSimple.filter(al =&gt; al.id !== &quot;org.eclipse.elk.disco&quot;);\n    const selectedDiscoComponentLayoutAlgorithm = await utils.suggester(\n      componentLayoutAlgorithms.map((algorithmInfo) =&gt; algorithmInfo.displayText),\n      componentLayoutAlgorithms.map((algorithmInfo) =&gt; algorithmInfo.id),\n      &quot;Disco Connected Components Layout Algorithm&quot;\n    );\n    discoComponentLayoutAlgorithm = selectedDiscoComponentLayoutAlgorithm??&quot;org.eclipse.elk.layered&quot;;\n  &#125;\n\n  if (\n    selectedAlgorithm === &quot;org.eclipse.elk.box&quot; ||\n    selectedAlgorithm === &quot;org.eclipse.elk.rectpacking&quot;\n  ) &#123;\n    nodeNodeSpacing = await utils.inputPrompt(&quot;Node Spacing&quot;, &quot;number&quot;, &quot;10&quot;);\n  &#125; else &#123;\n    let userSpacingStr = await utils.inputPrompt(\n      &quot;Components Spacing, Node Spacing, Node Node Between Layers Spacing&quot;,\n      &quot;number, number, number&quot;,\n      &quot;10, 100, 100&quot;\n    );\n    let userSpacingArr = (userSpacingStr??&quot;&quot;).split(&quot;,&quot;);\n    componentComponentSpacing = userSpacingArr[0] ?? &quot;10&quot;;\n    nodeNodeSpacing = userSpacingArr[1] ?? &quot;100&quot;;\n    nodeNodeBetweenLayersSpacing = userSpacingArr[2] ?? &quot;100&quot;;\n  &#125;\n\n  let layoutOptionsJson = &#123;&#125;;\n  try &#123;\n    layoutOptionsJson = JSON.parse(settings[&quot;Layout Options JSON&quot;].value);\n  &#125; catch (e) &#123;\n    new Notice(\n      &quot;Error reading Layout Options JSON, see developer console for more information&quot;,\n      4000\n    );\n    console.log(e);\n  &#125;\n\n  layoutOptionsJson[&quot;elk.algorithm&quot;] = selectedAlgorithm;\n  layoutOptionsJson[&quot;org.eclipse.elk.spacing.componentComponent&quot;] =\n    componentComponentSpacing;\n  layoutOptionsJson[&quot;org.eclipse.elk.spacing.nodeNode&quot;] = nodeNodeSpacing;\n  layoutOptionsJson[&quot;org.eclipse.elk.layered.spacing.nodeNodeBetweenLayers&quot;] =\n    nodeNodeBetweenLayersSpacing;\n  layoutOptionsJson[&quot;org.eclipse.elk.layered.nodePlacement.strategy&quot;] =\n    nodePlacementStrategy;\n  layoutOptionsJson[&quot;org.eclipse.elk.disco.componentCompaction.componentLayoutAlgorithm&quot;] = \n    discoComponentLayoutAlgorithm;\n  layoutOptionsJson[&quot;org.eclipse.elk.direction&quot;] = direction;\n\n  const graph = &#123;\n    id: &quot;root&quot;,\n    layoutOptions: layoutOptionsJson,\n    children: [],\n    edges: [],\n  &#125;;\n\n  let groupMap = new Map();\n  let targetElkMap = new Map();\n  let arrowEls = [];\n\n  for (let i = 0; i &lt; groups.length; i++) &#123;\n    const elements = groups[i];\n    if (\n      elements.length === 1 &amp;&amp;\n      (elements[0].type === &quot;arrow&quot; || elements[0].type === &quot;line&quot;)\n    ) &#123;\n      if (\n        elements[0].type === &quot;arrow&quot; &amp;&amp;\n        elements[0].startBinding &amp;&amp;\n        elements[0].endBinding\n      ) &#123;\n        arrowEls.push(elements[0]);\n      &#125;\n    &#125; else &#123;\n      let elkId = &quot;g&quot; + i;\n      elements.reduce((result, el) =&gt; &#123;\n        result.set(el.id, elkId);\n        return result;\n      &#125;, targetElkMap);\n\n      const box = ea.getBoundingBox(elements);\n      groupMap.set(elkId, &#123;\n        elements: elements,\n        boundingBox: box,\n      &#125;);\n\n      graph.children.push(&#123;\n        id: elkId,\n        width: box.width,\n        height: box.height,\n        x: box.topX,\n        y: box.topY,\n      &#125;);\n    &#125;\n  &#125;\n\n  for (let i = 0; i &lt; arrowEls.length; i++) &#123;\n    const arrowEl = arrowEls[i];\n    const startElkId = targetElkMap.get(arrowEl.startBinding.elementId);\n    const endElkId = targetElkMap.get(arrowEl.endBinding.elementId);\n\n    graph.edges.push(&#123;\n      id: &quot;e&quot; + i,\n      sources: [startElkId],\n      targets: [endElkId],\n    &#125;);\n  &#125;\n\n  const initTopX =\n    Math.min(...Array.from(groupMap.values()).map((v) =&gt; v.boundingBox.topX)) -\n    12;\n  const initTopY =\n    Math.min(...Array.from(groupMap.values()).map((v) =&gt; v.boundingBox.topY)) -\n    12;\n\n  elk\n    .layout(graph)\n    .then((resultGraph) =&gt; &#123;\n      for (const elkEl of resultGraph.children) &#123;\n        const group = groupMap.get(elkEl.id);\n        for (const groupEl of group.elements) &#123;\n          const originalDistancX = groupEl.x - group.boundingBox.topX;\n          const originalDistancY = groupEl.y - group.boundingBox.topY;\n          const groupElDistanceX =\n            elkEl.x + initTopX + originalDistancX - groupEl.x;\n          const groupElDistanceY =\n            elkEl.y + initTopY + originalDistancY - groupEl.y;\n\n          groupEl.x = groupEl.x + groupElDistanceX;\n          groupEl.y = groupEl.y + groupElDistanceY;\n\n          if (stickynotesMap.has(groupEl.id)) &#123;\n            const stickynote = stickynotesMap.get(groupEl.id);\n            stickynote.x = stickynote.x + groupElDistanceX;\n            stickynote.y = stickynote.y + groupElDistanceY;\n          &#125;\n        &#125;\n      &#125;\n\n      ea.copyViewElementsToEAforEditing(selectedElements);\n      ea.addElementsToView(false, false);\n\n      normalizeSelectedArrows();\n    &#125;)\n    .catch(console.error);\n&#125;\n\nfunction loadELK(doAfterLoaded) &#123;\n  let script = document.createElement(&quot;script&quot;);\n  script.onload = function () &#123;\n    if (typeof ELK !== &quot;undefined&quot;) &#123;\n      doAfterLoaded();\n    &#125;\n  &#125;;\n  script.src =\n    &quot;https://cdn.jsdelivr.net/npm/elkjs@0.8.2/lib/elk.bundled.min.js&quot;;\n  document.head.appendChild(script);\n&#125;\n\n/*\n * Normalize Selected Arrows\n */\n\nfunction normalizeSelectedArrows() &#123;\n  let gapValue = 2;\n\n  const selectedIndividualArrows = ea.getMaximumGroups(ea.getViewSelectedElements())\n    .reduce((result, g) =&gt; [...result, ...g.filter(el =&gt; el.type === &#39;arrow&#39;)], []);\n\n  const allElements = ea.getViewElements();\n  for (const arrow of selectedIndividualArrows) &#123;\n    const startBindingEl = allElements.filter(\n      (el) =&gt; el.id === (arrow.startBinding || &#123;&#125;).elementId\n    )[0];\n    const endBindingEl = allElements.filter(\n      (el) =&gt; el.id === (arrow.endBinding || &#123;&#125;).elementId\n    )[0];\n\n    if (startBindingEl) &#123;\n      recalculateStartPointOfLine(\n        arrow,\n        startBindingEl,\n        endBindingEl,\n        gapValue\n      );\n    &#125;\n    if (endBindingEl) &#123;\n      recalculateEndPointOfLine(arrow, endBindingEl, startBindingEl, gapValue);\n    &#125;\n  &#125;\n\n  ea.copyViewElementsToEAforEditing(selectedIndividualArrows);\n  ea.addElementsToView(false, false);\n&#125;\n\nfunction recalculateStartPointOfLine(line, el, elB, gapValue) &#123;\n  const aX = el.x + el.width / 2;\n  const bX =\n    line.points.length &lt;= 2 &amp;&amp; elB\n      ? elB.x + elB.width / 2\n      : line.x + line.points[1][0];\n  const aY = el.y + el.height / 2;\n  const bY =\n    line.points.length &lt;= 2 &amp;&amp; elB\n      ? elB.y + elB.height / 2\n      : line.y + line.points[1][1];\n\n  line.startBinding.gap = gapValue;\n  line.startBinding.focus = 0;\n  const intersectA = ea.intersectElementWithLine(\n    el,\n    [bX, bY],\n    [aX, aY],\n    line.startBinding.gap\n  );\n\n  if (intersectA.length &gt; 0) &#123;\n    line.points[0] = [0, 0];\n    for (let i = 1; i &lt; line.points.length; i++) &#123;\n      line.points[i][0] -= intersectA[0][0] - line.x;\n      line.points[i][1] -= intersectA[0][1] - line.y;\n    &#125;\n    line.x = intersectA[0][0];\n    line.y = intersectA[0][1];\n  &#125;\n&#125;\n\nfunction recalculateEndPointOfLine(line, el, elB, gapValue) &#123;\n  const aX = el.x + el.width / 2;\n  const bX =\n    line.points.length &lt;= 2 &amp;&amp; elB\n      ? elB.x + elB.width / 2\n      : line.x + line.points[line.points.length - 2][0];\n  const aY = el.y + el.height / 2;\n  const bY =\n    line.points.length &lt;= 2 &amp;&amp; elB\n      ? elB.y + elB.height / 2\n      : line.y + line.points[line.points.length - 2][1];\n\n  line.endBinding.gap = gapValue;\n  line.endBinding.focus = 0;\n  const intersectA = ea.intersectElementWithLine(\n    el,\n    [bX, bY],\n    [aX, aY],\n    line.endBinding.gap\n  );\n\n  if (intersectA.length &gt; 0) &#123;\n    line.points[line.points.length - 1] = [\n      intersectA[0][0] - line.x,\n      intersectA[0][1] - line.y,\n    ];\n  &#125;\n&#125;\n</code></pre>\n","text":"&#x2F;* Download this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obs...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"12 mins."},"categories":[],"tags":[],"toc":"","author":{"name":"Devmacy","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/01/24/pSYhwB4.jpg","link":"/","description":"数字花园","socials":{"github":"https://github.com/Devmacy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Box Each Selected Groups","uid":"1f6284048f0d626a1ed81fc1a62dfb0d","slug":"Box Each Selected Groups","date":"2023-07-29T10:00:19.207Z","updated":"2023-07-29T10:00:19.340Z","comments":true,"path":"api/articles/Box Each Selected Groups.json","keywords":"Digital Garden","cover":[],"text":"&#x2F;* Download this file and save to your Obsidian Vault including the first line, or open it in “Raw” and copy the entire contents to Obs...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[],"tags":[],"author":{"name":"Devmacy","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/01/24/pSYhwB4.jpg","link":"/","description":"数字花园","socials":{"github":"https://github.com/Devmacy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Auto Draw for Pen","uid":"e4d1ac459887c21249603be66b9f7f5b","slug":"Auto Draw for Pen","date":"2023-07-29T10:00:19.203Z","updated":"2023-07-29T10:00:19.335Z","comments":true,"path":"api/articles/Auto Draw for Pen.json","keywords":"Digital Garden","cover":null,"text":"&#x2F;*Automatically switches between the select and draw tools, based on whether a pen is being used. Choose the select tool Hover&#x2F;use...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[],"author":{"name":"Devmacy","slug":"blog-author","avatar":"https://s1.ax1x.com/2023/01/24/pSYhwB4.jpg","link":"/","description":"数字花园","socials":{"github":"https://github.com/Devmacy","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}